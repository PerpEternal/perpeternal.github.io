<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[POJ-1050 To the Max]]></title>
    <url>%2F2019%2F03%2F21%2FPOJ-1050%2F</url>
    <content type="text"><![CDATA[题意求最大子矩阵和。 题解枚举列区间，将该区间的值压缩到一起，转化成求一维最大字段。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;vector&gt;#define ll long long#define inf 0x3f3f3f3f#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main() &#123; ios::sync_with_stdio(false); int n, a[101][101],b[101][101]; cin &gt;&gt; n; mem0(b); for0(i, n) &#123; for0(j, n)&#123; cin&gt;&gt;a[i][j]; b[i][j+1]=b[i][j]+a[i][j]; &#125; &#125; int ans=0; for0(i, n) forl(j, i+1, n)&#123; int tmp=0; for0(k, n)&#123; tmp+=b[k][j]-b[k][i]; if (tmp&lt;0) &#123; tmp=0; &#125;else if(tmp&gt;ans)&#123; ans=tmp; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1024 Max Sum Plus Plus]]></title>
    <url>%2F2019%2F03%2F21%2FHDU-1024%2F</url>
    <content type="text"><![CDATA[题意给你一个序列n个数组成，然后让你在里面找到m个子序列，让这m个子序列的和最大。 题解$dp[i][j]$表示的是第j个数字在第i个子序列时的当前最优值。$dp[i][j] = maxx(dp[i][j-1] + num[j] ,maxx(dp[i-1][k]) + num[j])$，k是从1到 $j-1$.可以这么理解这个转移方程，对于当前的这个数字，如果把他放到第i个子序列中有两种情况，一个是他作为第i个子序列的第一个数字，另一个就是不作为第一个数字，作为第一个数字的时候是 $max(dp[i-2][k] + num[j]) ,1&lt;=k&lt;i $的意思是从之前的所有中找到 $i-1$ 个子序列的最大值+当前的值，不做为第一个的时候那么他前面的那个数字一定是i序列的，同一个子序列，又不是作为第一个，那么前面的那个货就一定是同一个子序列的，那么当前的值是$dp[i][j-1] + num[j]$,在两种决策中选择一个最有的就行了，还有就是$max(dp[i-1][k]+num[j])$的这个地方可以开一个数组记录下来，不能每次都跑，跑不起，再有就是这个题目没有给m的范围，所以开不了二维数组（目测不是很大，大的话会超时，但是肯定是先超内存在超时，所以为了保险，还是吧$dp[][]$压缩成一维的）那么状态转移就边成这样了$dp[j]$表示的是 j这个人在当前的这个子序列中的最优值，mk[j]表示的是在上一个子序列中1—j的dp的最大值，所以就变成 $dp[j] = maxx(dp[j-1] + num[j] ,mk[j-1]+num[j])$;还是 max(作为i个子序列的第一个元素，不是第一个元素取一个最大值)。在解释下代码的核心部分。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;ctime&gt;#include &lt;strstream&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int d[1000006],a[1000006],pre_max[2][1000006];int main()&#123; int n,m; while (cin&gt;&gt;m&gt;&gt;n) &#123; memset(d, 0, sizeof(d)); memset(pre_max, 0, sizeof(pre_max)); for (int i=1; i&lt;=n; i++) scanf("%d",&amp;a[i]); int maxx; //pre_max[0][0]=-99999999;pre_max[1][0]=-99999999; for (int i=1; i&lt;=m; i++) &#123; maxx=-9999999; for (int j=i; j&lt;=n; j++) &#123; d[j]=max(d[j-1]+a[j], pre_max[(i+1)%2][j-1]+a[j]); maxx=max(maxx, d[j]); pre_max[i%2][j]=maxx; &#125; &#125; cout&lt;&lt;pre_max[m%2][n]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-2559 Largest Rectangle in a Histogram]]></title>
    <url>%2F2019%2F03%2F21%2FPOJ-2559%2F</url>
    <content type="text"><![CDATA[题意 求柱形图中的最大矩形面积。 题解法一: 求每个点左边连续比它大的最左边的下标，保存在l[]数组里,求每个点右边连续比它大的最右边的下标，保存在r[]数组里 法二: 维护一个单调栈, 如果h大于栈顶元素，则入栈, 否则，将栈内元素出栈，直到满足上面的条件。出栈时，我们要将出栈元素对之后问题的影响全部考虑进行处理，才能保证做法的正确性。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;ctime&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int n,tmp; while (cin&gt;&gt;n&amp;&amp;n) &#123; ll ans=0; vector&lt;pair&lt;int, int&gt; &gt;sta; for0(i, n)&#123; cin&gt;&gt;tmp; int count=0; forn(i, sta.size()-1)&#123; if (sta[i].first&gt;tmp) &#123; count+=sta[i].second; ans=max(ans, (ll)sta[i].first*count); sta.pop_back(); &#125;else break; &#125; sta.push_back(pair&lt;int, int&gt;(tmp,count+1)); &#125; int count=0; forn(i, sta.size()-1)&#123; count+=sta[i].second; ans=max(ans, (ll)sta[i].first*count); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1012]]></title>
    <url>%2F2019%2F03%2F21%2FCF1012%2F</url>
    <content type="text"><![CDATA[B. Chemical table题意 一个 n*m 的矩阵，当涂了三个角时，会自动涂第四个，已有一些点涂色，问最少需要涂几个点。 题解只需n+m-1个就可以填满,当插入点(x1,y1) 时有关系x1&lt;=&gt;y1当插入点(x2,y1) 时有关系 x2&lt;=&gt;y1&lt;=&gt;x1当插入点(x1,y2) 时有关系 y2&lt;=&gt;x1&lt;=&gt;y1&lt;=&gt;x2用并查集来连接 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(4.1e5)using namespace std;int uni[N+1];void init()&#123; for1(i,N)uni[i]=i;&#125;int find_root(int x)&#123; if (uni[x]==x) return x; else return uni[x]=find_root(uni[x]);&#125;int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); init(); int n,m,q,r,c,ans=0; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for0(i,q)&#123; scanf("%d%d",&amp;r,&amp;c); uni[find_root(m+r)]=find_root(c); &#125; for1(i,n+m)if(uni[i]==i)ans++; printf("%d\n",ans-1); return 0;&#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[城市建设]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[题意n 个城市，m 条道路，每条道路有一个权值(可能为负)，每个点有一个权值，表示修建码头的费用(为-1时表示不可以修建码头)。 题解ans1不修建码头的最小生成树ans2额外添加一个0号城市，将可建立码头的城市与它相连，求出的最小生成树当不建码头也能联通时，答案为min(ans1,ans2)，否则答案为 ans2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 2e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct Edge&#123; int u,v,c; Edge()&#123;&#125; Edge(int a,int b,int _c)&#123; u=a,v=b,c=_c; &#125; bool operator &lt;(const Edge y)const&#123; return c&lt;y.c; &#125;&#125;edge[N];int uni[N];int find_r(int x)&#123; if(x==uni[x])return x; else return uni[x]=find_r(uni[x]);&#125;int merge(Edge x)&#123; int fa=find_r(x.u),fb=find_r(x.v); if(fa!=fb)&#123; uni[fa]=fb; return 1; &#125; if(x.c&lt;0)return -1; else return 0;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,c,w,Size=0; ll ans1=0,ans2=0; scanf("%d%d",&amp;n,&amp;m); for0(i,m)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); edge[Size++]=Edge(u,v,c); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); int cnt=0; for0(i,Size)&#123; switch(merge(edge[i]))&#123; case 1: ans1+=edge[i].c; cnt++; break; case -1: ans1+=edge[i].c; &#125; &#125; for1(i,n)&#123; ind(w); if(w&gt;0)edge[Size++]=Edge(0,i,w); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); for0(i,Size)&#123; if(merge(edge[i]))ans2+=edge[i].c; &#125; if(cnt==n-1)ans2=min(ans2,ans1); printf("%lld\n",ans2); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%2F</url>
    <content type="text"><![CDATA[题意$f(x)$为斐波那契数列，求$\large\left(\sum\limits_{i=1}^nf(i)\right)\ mod\ f(m)\ mod \ p​$ $0&lt;n,m,p&lt;1e18$ 题解 f(n+m)=f(n+1)f(m)+f(n)f(m-1) \\ f(n)\ mod\ f(m)=f(n-m)f(m-1)\ mod\ f(m)\\ f(n)\ mod \ f(m)=f(m-1)^{\frac n m}f(n\%m)\ mod\ f(m)\\ f(n)^2=(-1)^{n+1}+f(n-1)f(n+1)\\ f(m-1)^2\ mod\ f(m)=(-1)^m m 为偶数 $\frac n m​$为偶数，$f(n)\ mod\ f(m)=f(n\%m)​$ $\frac n m​$为奇数，$f(n)\ mod\ f(m)=f(m-1)f(n\%m)\ mod\ f(m)​$ m 为奇数 $\frac n m$为偶数，$\frac n {2m}$为偶数，$f(n)\ mod\ f(m)=f(n\%m)$ $\frac n m$为偶数，$\frac n {2m}$为奇数，$f(n)\ mod\ f(m)=f(m)-f(n\%m)$ $\frac n m​$为奇数，$\frac n {2m}​$为偶数，$f(n)\ mod\ f(m)=f(m-1)f(n\%m)\ mod\ f(m)​$ $\frac n m$为奇数，$\frac n {2m}$为奇数，$f(n)\ mod\ f(m)=f(m)-f(m-1)f(n\%m)\ mod\ f(m)$ 简化$f(m-1)f(n\%m)\ mod\ f(m)​$ 性质：若$n\ge1,r\ge2$，则$f(n)f(n+r-1)-f(n+1)f(n+r-2)=(-1)^{n+1}f(r-2)$ 令$k=n\%m,k=n+1,m-1=n+r-2$，则$f(n)f(k-1)-f(m-1)f(k)=(-1)^kf(m-k)$ 所以$f(m-1)f(k)\ mod \ f(m)=(-1)^{k+1}f(m-k)\ mod\ f(m)$ 当$k$为奇时，$f(m-1)f(n\%m)\ mod\ f(m)=f(m-k)$ 当$k$为偶时，$f(m-1)f(n\%m)\ mod\ f(m)=f(m)-f(m-k)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f; ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct matrix &#123; ll a[2][2]; matrix()&#123; mem0(a); &#125;&#125;;ll qMulti(ll x,ll y,ll mod)&#123; //O(1)快速乘 return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod; &#125;matrix mat_mul(matrix x, matrix y) &#123; matrix res; for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) res.a[i][j] = (res.a[i][j] + qMulti(x.a[i][k] , y.a[k][j],mod) ) % mod; return res;&#125;ll mat_pow(ll n) &#123; if (n &lt;= 2) return 1; n -= 2; matrix c, res; c.a[0][0] = c.a[0][1] = c.a[1][0] = 1; for (int i = 0; i &lt; 2; i++) res.a[i][i] = 1; while (n) &#123; if (n % 2) res = mat_mul(res, c); c = mat_mul(c, c); n /= 2; &#125; return (res.a[0][0] + res.a[0][1]) % mod;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll n,m,p; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; mod=p; n+=2; ll k=n/m; if(n%m==0)&#123; cout&lt;&lt;((mat_pow(m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; int Sign; if(m%2)Sign=-1; else Sign=1; if(k%2)&#123; k/=2; if(k%2==0)Sign=1; if(n%m%2==0)Sign=-Sign; if(Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; k/=2; if(k%2&amp;&amp;Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125; &#125; return 0;&#125; 引用https://blog.csdn.net/acdreamers/article/details/21822165]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形排版]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9B%BE%E5%BD%A2%E6%8E%92%E7%89%88%2F</url>
    <content type="text"><![CDATA[题意小明需要在一篇文档中加入 N 张图片，其中第 i 张图片的宽度是 Wi，高度是 Hi。假设纸张的宽度是 M，小明使用的文档编辑工具会用以下方式对图片进行自动排版： 该工具会按照图片顺序，在宽度 M 以内，将尽可能多的图片排在一行。该行的高度是行内最高的图片的高度。例如在 M=10 的纸张上依次打印 3x4, 2x2, 3x3 三张图片，则效果如下图所示，这一行高度为4。(分割线以上为列标尺，分割线以下为排版区域；数字组成的矩形为第x张图片占用的版面) 如果当前行剩余宽度大于0，并且小于下一张图片，则下一张图片会按比例缩放到宽度为当前行剩余宽度(高度向上取整)，然后放入当前行。例如再放入一张4x9的图片，由于剩余宽度是2，这张图片会被压缩到2x5，再被放入第一行的末尾。此时该行高度为5： 如果当前行剩余宽度为0，该工具会从下一行开始继续对剩余的图片进行排版，直到所有图片都处理完毕。此时所有行的总高度和就是这 N 张图片的排版高度。例如再放入11x1, 5x5, 3x4 的图片后，效果如下图所示，总高度为11： 现在由于排版高度过高，图片的先后顺序也不能改变，小明只好从 N 张图片中选择一张删除掉以降低总高度。他希望剩余N-1张图片按原顺序的排版高度最低，你能求出最低高度是多少么？ 题解预处理以第 i 张图为行首的最低高度，然后枚举删图。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;pii a[N],b[N];int suf[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m,n,w,h; scanf("%d%d",&amp;m,&amp;n); for0(i,n)&#123; scanf("%d%d",&amp;w,&amp;h); a[i]=pii(w,h); &#125; for0(i,n)&#123; w=m; h=0; int len=i; for(;len&lt;n&amp;&amp;w;len++)&#123; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; // cout&lt;&lt;h&lt;&lt;endl; b[i]=pii(len,h); &#125; // puts(""); // for0(i,n)cout&lt;&lt;b[i].first&lt;&lt;' '&lt;&lt;b[i].second&lt;&lt;endl; for(int i=n-1;i&gt;=0;i--)&#123; suf[i]=suf[b[i].first]+b[i].second; &#125; // for0(i,n)cout&lt;&lt;suf[i]&lt;&lt;endl; int ans=inf,flag=0,tot=0; while(flag&lt;n)&#123; for(int i=flag;i&lt;b[flag].first;i++)&#123; w=m; h=0; int len=flag; for(;len&lt;n&amp;&amp;w;len++)&#123; if(len==i)continue; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; ans=min(ans,tot+h+suf[len]); &#125; tot+=b[flag].second; flag=b[flag].first; // tot+= &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格子刷油漆]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%A0%BC%E5%AD%90%E5%88%B7%E6%B2%B9%E6%BC%86%2F</url>
    <content type="text"><![CDATA[题意给一个$2*N$的矩阵，可以从任意一个格子刷起，但只能移动到和它相邻的格子（可以对角），求总的方案数，对$1e9+7​$取模。 题解设a[n]为起点为某一角落长度为n终点任意的情况数，b[n]为起点为某一角落长度为n终点必须同列的情况数。 $b[i]=2^{i-1}$ 当起点在四个角落，以左上角为例 情况一，先向下移动，再向右移动某个位置，情况数相当于 做长度为i-1的终点任意的情况数*2 因为不需要在回到第一列，而且到第二列的时候可能是第一行或者第二行，即$a[i-1]*2$ 情况二，从起点出发最终回到第一列的第二行，那么情况数就是b[i]。 先进入第二列，然后返回第一列另一个位置，然后再回第二列，即$22a[i-2]$ 当起点在中间 情况一，向左运动后回到第i列然后向右运动 情况二，向右运动后回到第i列然后向左运动 \sum\limits_{i=2}^{n-1}2*(b[i+1]*a[n-i]+b[n-i+2]*a[i-1]) $a[1]=1,a[2]=6$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll a[N],b[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,ans=0; b[1]=1; forl(i,2,1e3)&#123; b[i]=b[i-1]*2%mod; &#125; a[1]=1;a[2]=6; forl(i,3,1e3)&#123; a[i]=(2ll*a[i-1]+b[i]+4ll*a[i-2])%mod; &#125; ind(n); if(n==1)&#123; puts("2"); return 0; &#125; ans=4ll*a[n]%mod; forl(i,2,n-1)&#123; ans=(ans+2ll*(b[i+1]*a[n-i]%mod+b[n-i+2]*a[i-1]%mod))%mod; &#125; printf("%d\n",ans); return 0;&#125; 引用https://blog.csdn.net/qq_35078631/article/details/54730870]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高僧斗法]]></title>
    <url>%2F2019%2F03%2F20%2F%E9%AB%98%E5%83%A7%E6%96%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题意n 个物品放在阶梯，向上移动物品，不能越过挡在前面的物品，最后物品都挤在高段台阶，不能移动的输。 题解两两一组，当移动上面的，可以移动下面的相同距离，所以可以把每组之间的间距看作一堆石子，转化为 Nim 博弈。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vii v,vv;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int x; while(~ind(x))v.pb(x); int Xor=0; for(int i=0;i+1&lt;v.size();i+=2)&#123; vv.pb(v[i+1]-v[i]-1); Xor^=vv.back(); &#125; if(Xor)&#123; for0(i,v.size()-1)&#123; forl(j,v[i]+1,v[i+1]-1)&#123; if(i%2)&#123; if((Xor^vv[i/2])==vv[i/2]+j-v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125;else&#123; if((Xor^vv[i/2])==vv[i/2]-j+v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125; &#125; &#125; &#125;else puts("-1"); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国王的烦恼]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[题意n 个点 m 条边，每条边有一个权值表示该边消失的时间，求有新的点不联通的时刻的数量。 题解以时间从大到小排序，用并查集反向建图，注意同时刻只能计一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e4;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int uni[N];int find_r(int x)&#123; if(uni[x]==x)return x; else return uni[x]=find_r(uni[x]);&#125;bool merge(int a,int b)&#123; int fa=find_r(a),fb=find_r(b); if(fa==fb)return 0; uni[fa]=fb; return 1;&#125;struct edg&#123; int u,v,w; bool operator &lt; (const edg y)const&#123; return w&gt;y.w; &#125;&#125;edge[10*N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; scanf("%d%d",&amp;n,&amp;m); for1(i,n)uni[i]=i; for0(i,m)scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); sort(edge,edge+m); int ans=0,time=0; for0(i,m)&#123; // cout&lt;&lt;edge[i].u&lt;&lt;' '&lt;&lt;edge[i].v&lt;&lt;' '&lt;&lt;edge[i].w&lt;&lt;endl; if(merge(edge[i].u,edge[i].v))&#123; if(edge[i].w!=time)&#123; time=edge[i].w; ans++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1062]]></title>
    <url>%2F2019%2F03%2F02%2FCF1062%2F</url>
    <content type="text"><![CDATA[D. Fun with Integers题意You are given a positive integer n​ greater or equal to 2. For every pair of integers a and b (2≤|𝑎|,|𝑏|≤𝑛2≤|a|,|b|≤n), you can transform a into b if and only if there exists an integer x such that 1&lt;|x| and (a⋅x=b or b⋅x=a), where |x| denotes the absolute value of x. After such a transformation, your score increases by |x| points and you are not allowed to transform a into b nor b into a anymore. Initially, you have a score of 0. You can start at any integer and transform it as many times as you like. What is the maximum score you can achieve? 题解答案为 2~n 每个数的因子( 范围为$[2,n)$ )之和。 \Huge\sum s_i代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; ll ans=0; cin&gt;&gt;n; forl(i,2,n)&#123; ans+=1ll*i*(n/i-1); &#125; cout&lt;&lt;ans*4&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1076]]></title>
    <url>%2F2019%2F03%2F02%2FCF1076%2F</url>
    <content type="text"><![CDATA[D. Edge Deletion题意the length of the shortest path from vertex 1 to vertex i as $d_i$ . You have to erase some edges of the graph so that at most k edges remain. Let’s call a vertex i good if there still exists a path from 1 to i with length $d_i$ after erasing the edges. Your goal is to erase the edges in such a way that the number of good vertices is maximized. 题解先跑个最短路，再搜索，取最短路上的边。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf = 0x3f3f3f3f;const ll mod = 1e9 + 7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b) &#123; return sign(a - b); &#125;struct Edge &#123; int v, w, nxt, no;&#125; edge[2 * N];int fir[N], cnt;void addedge(int u, int v, int w, int no) &#123; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].nxt = fir[u]; edge[cnt].no = no; fir[u] = cnt++;&#125;struct node &#123; int u; ll d; node(int u, ll d) : u(u), d(d) &#123;&#125; bool operator&lt;(const node &amp;a) const &#123; return d &gt; a.d; &#125;&#125;;bool used[N];ll d[N];void dijkstra() &#123; priority_queue&lt;node&gt; que; meminf(d); d[1] = 0; que.push(node(1, d[1])); while (!que.empty()) &#123; int u = que.top().u; que.pop(); if (used[u]) continue; used[u] = 1; for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] &gt; d[u] + w) &#123; d[v] = d[u] + w; que.push(node(v, d[v])); &#125; &#125; &#125;&#125;bool used_edge[N];void init() &#123; mem_1(fir); cnt = 0;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif // ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); init(); int n, m, k, u, v, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for1(i, m) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w, i); addedge(v, u, w, i); &#125; if (k == 0) &#123; puts("0\n"); return 0; &#125; dijkstra(); queue&lt;int&gt; que; que.push(1); mem0(used); used[1] = 1; int ans = 0; while (que.size()) &#123; int u = que.front(); que.pop(); for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] == d[u] + w) &#123; used_edge[edge[i].no] = 1; used[v] = 1; ans++; if (ans == k) break; que.push(v); &#125; &#125; if (ans == k) break; &#125; printf("%d\n", ans); for1(i, m) &#123; if (used_edge[i]) printf("%d ", i); &#125; puts(""); return 0;&#125; E. Vasya and a Tree题意给一颗树，将 v 和与 v 距离小于 d 的 v 的子节点的权值加上 x，输出所有节点的权值。 题解保存每个点每次加权的终点和 x。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vi;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vi node[N];int dep[N];ll change[N];bool vis[N];int maxx;void dfs(int r,int dph)&#123; dep[r]=dph; vis[r]=1; maxx=max(maxx,dph); for(int v:node[r])if(vis[v]==0)dfs(v,dph+1);&#125;struct da&#123; int end,x; da()&#123;&#125; da(int a,int b):end(a),x(b)&#123;&#125;&#125;;vector&lt;da&gt; weight[N];ll tmpc[N];void ddfs(int r,int depth,ll sum)&#123; for(auto i:weight[r])&#123; sum+=i.x; tmpc[i.end]+=i.x; &#125; change[r]+=sum; sum-=tmpc[depth]; vis[r]=1; for(int v:node[r])if(vis[v]==0)ddfs(v,depth+1,sum); for(auto i:weight[r])tmpc[i.end]-=i.x;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,d,x; ind(n); for0(i,n-1)&#123; scanf("%d%d",&amp;u,&amp;v); node[u].push_back(v); node[v].push_back(u); &#125; dfs(1,1); ind(m); for0(i,m)&#123; scanf("%d%d%d",&amp;v,&amp;d,&amp;x); weight[v].push_back(da(min(dep[v]+d,maxx),x)); &#125; mem0(vis); ddfs(1,1,0); for1(i,n)printf("%lld ",change[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
</search>
