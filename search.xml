<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F20%2Fa%2F</url>
    <content type="text"><![CDATA[—- title: 2014ICPC-Anshanmathjax: truedate: 2019-09-20 15:52:47tags: dp brute force polyacategories: icpc H. NAND题意给一个真值表，问最少使用多少个二输入与非门能够实现这个真值表的功能。 题解初始值 $15 - 00001111$ $51-00110011$ $85-01010101$ 用一个 $vector$ 表示当前具有的表达式，每次 $dfs$ 都选取两个做与非运算，加入队列再继续 $dfs$ ，有以下几个剪枝 标记 $vector$ 中的元素，避免重复加入 $dfs$ 的参数传入上一次的选取的两个值的下标，每次只取上一次右边的数 代码123456789101112131415161718192021222324252627282930int ans[256];vii v;bool vis[256];void dfs(int dep,int l,int r)&#123; if(dep==11)return; int len=v.size(); for(int i=l;i&lt;len;i++) for(int j=(i==l?r:0);j&lt;=i;j++)&#123;//只取小于i的数，避免重复 int tm=255^(v[i]&amp;v[j]); ans[tm]=min(ans[tm],dep); if(!vis[tm])&#123; vis[tm]=1; v.pu_b(tm); dfs(dep+1,i,j); v.pop_back(); vis[tm]=0; &#125; &#125;&#125;int main() &#123; v.pu_b(15);v.pu_b(51);v.pu_b(85); meminf(ans); ans[0]=vis[0]=ans[255]=vis[255]=1; for(int i:v)ans[i]=vis[i]=1; dfs(2,0,0); for0(i,256)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125; J. Square题意给你一个 $n*n(n\le8)$ 的棋盘，上面有一些格子必须是黑色。其它可以染黑或者染白。对于一个棋盘，定义它的优美度为它上面最大的连续白色子正方形的边长，对于每个 $0\le k\le n$，问有多少种染色方案使得棋盘的优美度为 $k$ ？ 题解将问题转化为求优美度小于 $k$ 的染色方案， $dp[i][sta]$ 表示第 $i$ 行状态为 $sta$ 的方案数，状态为一个 $k$ 进制数，第 $j$ 位表示区间 $j\sim j+k-1$ (每行下标从 $0$ 开始)往上延伸都为白色的最大高度，接下来枚举每行的染色方案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960ull ans[10];ull dp[10][1200];int val[10];int Pow[10][10];char s[10];int main() &#123; int t,n; for (int i = 1; i &lt;= 9; i++)&#123; Pow[i][0]=1; for (int j = 1; j &lt;= 9; j++)Pow[i][j]=Pow[i][j-1]*i; &#125; in(t); ans[0]=dp[0][0]=1; while(t--)&#123; in(n); int tot=0; for (int i = 1; i &lt;= n; i++)&#123; in(s); val[i]=0; for (int j = 0; j &lt; n; j++)&#123; val[i]*=2; if(s[j]=='o')val[i]++,tot++; &#125; &#125; for (int k = 2; k &lt;= n; k++)&#123; ull tmp=0; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 0; j &lt; Pow[k][n-k+1]; j++)dp[i][j]=0; for(int s=val[i];;s=(s-1)&amp;val[i])&#123; for(int t=0;t&lt;Pow[k][n-k+1];t++)&#123; if(!dp[i-1][t])continue; bool is=1; ll mask=Pow[2][k]-1; int tt=t,ts=t; for(int j=0;j&lt;=n-k;j++,mask*=2)&#123; if((s&amp;mask)==mask)&#123; if(tt%k==k-1)is=0; else ts+=Pow[k][j]; &#125;else&#123; ts-=(tt%k)*Pow[k][j]; &#125; tt/=k; &#125; if(is)dp[i][ts]+=dp[i-1][t]; &#125; if(s==0)break; &#125; &#125; for (int i = 0; i &lt; Pow[k][n-k+1]; i++)tmp+=dp[n][i]; ans[k-1]=tmp; &#125; __int128 tm=1; tm&lt;&lt;=tot; ans[n]=tm-ans[n-1]; for(int i=n-1;i&gt;0;i--) ans[i]-=ans[i-1]; for (int i = 0; i &lt; n+1; i++)out((ll)(ans[i]%mod),1); &#125; return 0;&#125; K. Colorful Toy题意给 $N$ 个点，$M$ 条边，用 $C$ 种颜色给点染色，其中图形旋转后相同的染色方案只算一种，求有多少种不同的染色方案。 题解因为给的点都是整数点，图形只有在旋转 $90^\circ 180^\circ,270^\circ$ 时才可能与原图重合，旋转方案只有四种。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175struct Point&#123; db x,y; Point()&#123;&#125; Point(db _x,db _y) : x(_x),y(_y)&#123;&#125; Point operator + (const Point &amp;k1) const&#123;return Point(k1.x+x,k1.y+y);&#125; Point operator - (const Point &amp;k1) const&#123;return Point(x-k1.x,y-k1.y);&#125; Point operator * (const db k1) const&#123;return Point(x*k1,y*k1);&#125; Point operator / (const db k1) const&#123;return Point(x/k1,y/k1);&#125; db operator * (const Point b) const&#123;return x * b.x + y * b.y;&#125;//点积 db operator ^ (const Point b) const&#123;return x * b.y - y * b.x;&#125;//叉积,顺时针为负 bool operator == (const Point &amp;k1) const&#123;return db_cmp(x,k1.x)==0&amp;&amp;db_cmp(y,k1.y)==0;&#125; Point &amp; operator += (const Point &amp;k1) &#123;x+=k1.x;y+=k1.y;return *this;&#125; Point &amp; operator -= (const Point &amp;k1) &#123;x-=k1.x;y-=k1.y;return *this;&#125; Point &amp; operator *= (const db k1) &#123;*this=*this*k1;return *this;&#125; Point &amp; operator /= (const db k1) &#123;*this=*this/k1;return *this;&#125; Point rotate(db k1)&#123;return Point(x*cos(k1)-y*sin(k1),x*sin(k1)+y*cos(k1));&#125;// 逆时针旋转 Point rotate90()&#123;return Point(-y,x);&#125; db abs()&#123;return sqrt(x*x+y*y);&#125; db abs2()&#123;return x*x+y*y;&#125; Point unit()&#123;return *this/abs();&#125; db angle()&#123;return atan2(y,x);&#125; void out()&#123;printf("%.10f %.10f\n",x,y);&#125;&#125;;typedef Point Vector;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;map&lt;pii,int&gt;ma;bool Map[100][100];int ying [100];bool vis[100];int qu(db x)&#123; int tt=x; if(db_cmp(x,tt)==0)return tt; else if(db_cmp(x,tt-1)==0)return tt-1; else if(db_cmp(x,tt+1)==0)return tt+1; else return inf;&#125;bool check(pair&lt;db,db&gt;x)&#123; if(qu(x.fi)&lt;inf&amp;&amp;qu(x.se)&lt;inf)return 1; else return 0;&#125;int main() &#123; int t,n,m,c,u,v; in(t); while(t--)&#123; ma.clear(); in(n,m,c); db tx=0,ty=0; for1(i,n)&#123; in(u,v); ma[pii(u,v)]=i; tx+=u; ty+=v; &#125; assert(ma.size()==n); mem0(Map); for0(i,m)&#123; in(u,v); Map[u][v]=Map[v][u]=1; &#125; pii center; ll ans=qPow(c,n,mod); if(qu(tx/n*2)==inf||qu(ty/n*2)==inf)&#123; out(ans,1); continue; &#125;else center=pii(qu(tx/n*2),qu(ty/n*2)); int mu=1; bool is=1; mem0(vis); for(auto i:ma)&#123; pii p=i.fi; int id=i.se; pii op(center.fi-p.fi,center.se-p.se); if(ma.count(op))&#123; v=ma[op]; if(vis[v])&#123; is=0; break; &#125;else&#123; vis[v]=1; ying[id]=v; &#125; &#125;else &#123; is=0; break; &#125; &#125; if(is)&#123; for1(i,n) for1(j,n)&#123; if(Map[i][j])&#123; if(!Map[ying[i]][ying[j]])&#123; is=0; goto ss; &#125; &#125; &#125; &#125; ss: if(is)&#123; ans=(ans+qPow(c,(n+1)/2,mod))%mod; mu++; &#125;else &#123; out(ans,1); continue; &#125; Point cen(center.fi/2.0,center.se/2.0); // pair&lt;db,db&gt; cen=pair&lt;db,db&gt;(center.fi/2.0,center.se/2.0); // cout&lt;&lt;cen.x&lt;&lt; ' '&lt;&lt;cen.y&lt;&lt;endl&lt;&lt;endl; mem0(vis); for(auto i:ma)&#123; pii p=i.fi; int id=i.se; Vector dir(p.fi-cen.x,p.se-cen.y); // cout&lt;&lt;dir.x&lt;&lt;' '&lt;&lt;dir.y&lt;&lt;endl; dir=dir.rotate90(); // cout&lt;&lt;dir.x&lt;&lt;' '&lt;&lt;dir.y&lt;&lt;endl; dir=dir+cen; pair&lt;db,db&gt;tmp(dir.x,dir.y); // cout&lt;&lt;tmp.fi&lt;&lt; ' '&lt;&lt;tmp.se&lt;&lt;endl; // cout&lt;&lt;check(tmp)&lt;&lt;endl; if(check(tmp))&#123; pii op(qu(tmp.fi),qu(tmp.se)); // cout&lt;&lt;op.fi&lt;&lt;' '&lt;&lt;op.se&lt;&lt;endl; if(ma.count(op))&#123; v=ma[op]; if(vis[v])&#123; is=0; break; &#125;else&#123; vis[v]=1; ying[id]=v; &#125; &#125;else &#123; is=0; break; &#125; &#125;else&#123; is=0; break; &#125; &#125; if(is)&#123; for1(i,n) for1(j,n)&#123; if(Map[i][j])&#123; if(!Map[ying[i]][ying[j]])&#123; is=0; goto sp; &#125; &#125; &#125; &#125; sp: // cout&lt;&lt;is&lt;&lt;endl; if(is)&#123; mu+=2; ans=(ans+2*qPow(c,(n+3)/4,mod))%mod; // puts("fdsfs"); &#125; // out(ans,1); // out(mu,1); out(ans*qPow(mu,mod-2,mod)%mod,1); &#125; return 0;&#125; title: 2017-ACM-ICPC-Asia-Shenyangmathjax: truedate: 2019-04-14 20:56:47tags: mathcategories: icpc A. BBP Formula题意 \pi=\sum_{k=0}^{\infty}\frac 1 {16^k}\left( \frac 4 {8k+1}-\frac 2 {8k+4}-\frac 1 {8k+5}-\frac 1 {8k+6}\right)求 $\pi$ 十六进制表达的小数点后第 $n$ 位. 题解求十进制小数的十六进制形式, 去掉整数部分, 小数部分乘 16 得到的数的整数部分就是小数点后第一位的十六进制值, 以此类推. 16^n\sum_{k=0}^{\infty}\frac 1 {16^k} \frac 4 {8k+1} =\sum_{k=0}^{n}\frac {4*16^{n-k}\%(8k+1)} {8k+1}+\sum_{k=n+1}^{\infty}\frac 4 {16^{k-n}(8k+1)}代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int n;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;db fun(int a,int b)&#123; db ans=0; for0(i,n+1)&#123; ll w=a*qPow(16,n-i,8*i+b)%(8*i+b); ans+=(db)w/(8*i+b); &#125; ll ppow=1; for1(i,15)&#123; ppow*=16; // cout&lt;&lt;ppow&lt;&lt;endl; ans+=(db)a/ppow/(8*(i+n)+b); &#125; return ans;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; in(t); for1(ca,t)&#123; in(n); n--; db ans=fun(4,1)-fun(2,4)-fun(1,5)-fun(1,6); // cout&lt;&lt;ans&lt;&lt;endl; while(ans&lt;0)ans++; while(ans&gt;1)ans--; // cout&lt;&lt;ans&lt;&lt;endl; int k=ans*16; // cout&lt;&lt;k&lt;&lt;endl; if(k&gt;=10)printf("Case #%d: %d %c\n",ca,n+1,k-10+'A'); else printf("Case #%d: %d %d\n",ca,n+1,k); &#125; return 0;&#125; F. Heron and His Triangle题意设三角形的三条边为 $t-1,t,t+1$ ，给一个 $n(1\le n\le 1e30)$ ，求大于 $n$ 且三角形面积为整数的最小 $t$ 题解由海伦公式得 S=\sqrt {p(p-a)(p-b)(p-c)}\ ,p=\frac {a+b+c}2\\ S=\frac t 2\sqrt {3\left(\left(\frac t 2\right)^2-1\right)}\\ assume\qquad x=\frac t 2\\ x^2-3y^2=1\\ x_n=4x_{n-1}-x_{n-2}代码123456789101112131415161718192021222324252627282930import java.io.*;import java.util.*;import java.math.*; public class Main&#123; public static void main(String[] args) throws IOException&#123; Scanner sc =new Scanner(System.in); int t; t = sc.nextInt(); BigInteger n,maxn=new BigInteger("1000000000000000000000000000000"); Vector&lt;BigInteger&gt;v = new Vector&lt;&gt;(); v.add(BigInteger.valueOf(4)); v.add(BigInteger.valueOf(14)); while(v.lastElement().compareTo(maxn)==-1) &#123; int qq = v.size(); v.add(v.elementAt(qq-1).multiply(BigInteger.valueOf(4)).subtract(v.elementAt(qq-2))); &#125; while(t--!=0) &#123; n=sc.nextBigInteger(); for(Iterator&lt;BigInteger&gt; iter = v.iterator();iter.hasNext();) &#123; BigInteger tmp=iter.next(); if(tmp.compareTo(n)&gt;=0) &#123; System.out.println(tmp); break; &#125; &#125; &#125; sc.close(); &#125;&#125; title: 2018ICPC-Ningxiamathjax: truedate: 2019-09-13 16:38:56tags: dp data structurecategories: icpc E. 2-3-4 Tree题意裸的 $B+$ 树 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sz(a))#define mem_1(a) memset(a, -1, sz(a))#define mem0(a) memset(a, 0, sz(a))#define memcp(a,b) memcpy(a,b,sz(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define sz(a) (int)sizeof(a)typedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内 int inf = 0x3f3f3f3f;ll inf_ll = 0x3f3f3f3f3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e5;/*-----------------------------------head----------------------------------------------*/const int k=4;struct Node&#123; int cnt; bool isLeaf; int a[3]; Node *child[k]; Node()&#123; isLeaf=1; cnt=0; mem0(child); &#125; void out()&#123; assert(cnt); out0(a,cnt); &#125;&#125;*root;void del(Node*rt)&#123; if(rt-&gt;isLeaf)delete rt; else&#123; for(int i=0;i&lt;=rt-&gt;cnt;i++)del(rt-&gt;child[i]); delete rt; &#125;&#125;pair&lt;Node*,int&gt; split(Node *rt)&#123; rt-&gt;cnt=1; Node *tmp=new Node; tmp-&gt;cnt=1; tmp-&gt;a[0]=rt-&gt;a[2]; tmp-&gt;isLeaf=rt-&gt;isLeaf; tmp-&gt;child[0]=rt-&gt;child[2]; tmp-&gt;child[1]=rt-&gt;child[3]; pair&lt;Node*,int&gt; tmm=pair&lt;Node*,int&gt;(tmp,rt-&gt;a[1]); if(rt==root)&#123; Node *p=new Node; p-&gt;cnt=1; p-&gt;a[0]=tmm.se; p-&gt;isLeaf=0; p-&gt;child[0]=rt; p-&gt;child[1]=tmp; root=p; &#125; return tmm;&#125;void add(Node *rt,int x)&#123; rt-&gt;a[rt-&gt;cnt++]=x; sort(rt-&gt;a,rt-&gt;a+rt-&gt;cnt);&#125;pair&lt;Node*,int&gt; insert(Node *rt,int x)&#123; int id; for(id=0;id&lt;rt-&gt;cnt;id++)&#123; if(x&lt;rt-&gt;a[id])&#123; break; &#125; &#125; if(rt-&gt;cnt==k-1)&#123; pair&lt;Node*,int&gt; ret = split(rt); if(rt-&gt;isLeaf)&#123; if(id&lt;2)add(rt,x); else add(ret.fi,x); return ret; &#125;else&#123; if(id&gt;1)rt=ret.fi; pair&lt;Node*,int&gt;tmp= insert(rt,x); if(tmp.se)&#123; if(id%2)&#123; rt-&gt;cnt++; rt-&gt;child[2]=tmp.fi; rt-&gt;a[1]=tmp.se; &#125;else &#123; rt-&gt;cnt++; rt-&gt;a[1]=rt-&gt;a[0]; rt-&gt;a[0]=tmp.se; rt-&gt;child[2]=rt-&gt;child[1]; rt-&gt;child[1]=tmp.fi; &#125; &#125; return ret; &#125; &#125;else&#123; if(rt-&gt;isLeaf)&#123; add(rt,x); &#125;else&#123; pair&lt;Node*,int&gt;tmp= insert(rt-&gt;child[id],x); if(tmp.se)&#123; for(int i=rt-&gt;cnt;i&gt;=id+1;i--)&#123; rt-&gt;a[i]=rt-&gt;a[i-1]; rt-&gt;child[i+1]=rt-&gt;child[i]; &#125; rt-&gt;cnt++; rt-&gt;a[id]=tmp.se; rt-&gt;child[id+1]=tmp.fi; &#125; &#125; return pair&lt;Node*,int&gt;(0,0); &#125;&#125;void dfs(Node *rt)&#123; rt-&gt;out(); if(!rt-&gt;isLeaf)&#123; for0(i,rt-&gt;cnt+1)dfs(rt-&gt;child[i]); &#125;&#125;int main() &#123; int t,n,x; in(t); for1(ca,t)&#123; root=new Node; in(n); for0(i,n)&#123; in(x); insert(root,x); &#125; printf("Case #%d:\n",ca); dfs(root); del(root); &#125; return 0;&#125; G. Factories题意给一棵树，选择 $k(1\le k\le 100)$ 个叶节点，使得两两之间的路径和最小。 题解 $dp[i][j]$ 表示在以 $i$ 为根的子树中选择 $j$ 个叶节点的最小花费，其中不仅包括 $j$ 个节点两两之间的路径，还包括 $j$ 个节点经过节点 $i$ 与另外 $k-j$ 相连的路径和。 转移方程为 $dp[u][i]=min(dp[u][i],dp[u][i-j]+dp[v][j]+j\times (k-j)\times dis[u][v])$ 状态转移的时 $i$ 应该从大到小枚举，避免先更新了较小值后面又使用。另外还需要记录一下每个节点的有效值的范围，不然会 $TLE$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sz(a))#define mem_1(a) memset(a, -1, sz(a))#define mem0(a) memset(a, 0, sz(a))#define memcp(a,b) memcpy(a,b,sz(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define sz(a) (int)sizeof(a)typedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内 int inf = 0x3f3f3f3f;ll inf_ll = 0x3f3f3f3f3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 1.1e5;/*-----------------------------------head----------------------------------------------*/struct Node&#123; int v; ll w; Node(int _v,int _w)&#123;v=_v;w=_w;&#125;&#125;;vector&lt;Node&gt; node[N];ll dp[N][110];ll ans;int k;int cnt[N];//记录每个节点有效值的范围void dfs(int u,int fa)&#123; for(auto v:node[u])&#123; if(v.v==fa)continue; dfs(v.v,u); int tmp=cnt[u]; for(int i=k;i&gt;0;i--)&#123; for(int j=min(cnt[v.v],i);j&gt;0&amp;&amp;i-j&lt;=tmp;j--)&#123; cnt[u]=max(cnt[u],i); dp[u][i]=min(dp[u][i],dp[u][i-j]+dp[v.v][j]+v.w*j*(k-j)); &#125; &#125; &#125; ans=min(ans,dp[u][k]);&#125;int main() &#123; int t,n,u,v,w; in(t); for1(ca,t)&#123; in(n,k); ans=inf_ll; for1(i,n)&#123; node[i].clear(); meminf(dp[i]); dp[i][0]=0; cnt[i]=0; &#125; int root=1; for0(i,n-1)&#123; in(u,v,w); node[u].push_back(Node(v,w)); node[v].pu_b(Node(u,w)); if(node[u].size()&gt;1)root=u; if(node[v].size()&gt;1)root=v; &#125; for1(i,n)if(node[i].size()==1)dp[i][1]=0,cnt[i]++; dfs(root,0); assert(ans!=inf_ll); printf("Case #%d: %lld\n",ca,ans); &#125; return 0;&#125; 题意题解代码12 title: 2018河北省省赛mathjax: truedate: 2019-05-01 20:44:15tags: dp hash mathcategories: ccpc E. K Multiple Longest Commom Subsequence题意两个数组 $1\le k,n,m\le 1e3$, 问最长 $k$ 倍公共子序列是多少, $k$ 倍子序列指的是, 将子序列等分, 每份为 $k$ 个数, 且这 $k$ 个数相同. 如 $1,1,2,2$ 是一个 $2$ 倍子序列 题解$\text{pre_a[i]}$ 表示从 $i$ 开始往前数, 第 $k$ 个 $a[i]$ 的下标 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445int pre_a[N],pre_b[N];int t,k,n,m,x,a[N],b[N],cnt[N],dp[N][N];queue&lt;int&gt;que[N];int main() &#123; in(t); while(t--)&#123; in(k,n,m); mem0(pre_a); mem0(pre_b); for1(i,1000)while(que[i].size())que[i].pop(); for1(i,n)&#123; in(x); a[i]=x; que[x].push(i); if(que[x].size()==k)&#123; int qw=que[x].front(); que[x].pop(); pre_a[i]=qw; &#125; &#125; for1(i,1000)while(que[i].size())que[i].pop(); for1(i,m)&#123; in(x); b[i]=x; que[x].push(i); if(que[x].size()==k)&#123; int qw=que[x].front(); que[x].pop(); pre_b[i]=qw; &#125; &#125; mem0(dp); for1(i,n) for1(j,m)&#123; dp[i][j]=max(dp[i][j],max(dp[i-1][j],dp[i][j-1])); if(a[i]==b[j])&#123; if(pre_a[i]&amp;&amp;pre_b[j]) dp[i][j]=max(dp[i][j],dp[ pre_a[i]-1 ][ pre_b[j]-1 ]+1); &#125; &#125; outln(dp[n][m]*k); &#125; return 0;&#125; F. Defending Plan Support题意给一棵树, 每个点有权值 $\omega(i)$, 每条边有权值 $d(i,j)$, 找一个点 $x$ 使 $F(x)=\sum \omega(i)\times d(x,i)$ 最小 题解以 $1$ 为根节点画出这棵树, 设 $j$ 的父节点为 $i$, $tot=\sum\omega(i)$, $sum[i]$ 表示以 $i$ 为根节点的子树的权值和 F(j)=F(i)+d(i,j)\times(tot-2*sum[j])代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll dp[N],ans,tot;int sum[N],n,w[N],x,y,z;bool vis[N];vector&lt;pii&gt;v[N];int dfs(int rt,ll len)&#123; ans+=len*w[rt]; int tmp=w[rt]; for(auto i:v[rt])&#123; if(vis[i.fi]==0)&#123; vis[i.fi]=1; tmp+=dfs(i.fi,len+i.se); &#125; &#125; return sum[rt]=tmp;&#125;void dfs2(int rt)&#123; for(auto i:v[rt])&#123; if(vis[i.fi]==0)&#123; vis[i.fi]=1; dp[i.fi]=dp[rt]+i.se*tot-2ll*i.se*sum[i.fi]; ans=min(ans,dp[i.fi]); dfs2(i.fi); &#125; &#125;&#125;int main() &#123; in(n); for0(i,n-1)&#123; in(x,y,z); // tot+=z; v[x].pb(pii(y,z)); v[y].pb(pii(x,z)); &#125; for1(i,n)&#123; in(w[i]); tot+=w[i]; &#125; vis[1]=1; dfs(1,0); mem0(vis); vis[1]=1; dp[1]=ans; dfs2(1); outln(ans); return 0;&#125; K. Bitmap题意给一个 $n\times n(1 \leq n \leq 2000)$, 一个 $m\times m(1 \leq m \leq 1000,m\le n)$ 的矩阵, 值的范围为 $[0,255]$, 问 $A$ 中有几个 $B$, 只要每个元素相差一个定值就视为相同 题解hash, 枚举 $A$ 中 $B$ 的左上角 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e3;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;const int M=1.1e3;ull Pow[2][M],Hash[2][N][N],seed[2]=&#123;131,233&#125;,hash_b,hash2[M][M],offset;int a[N][N],b[M][M],n,m;void init()&#123; Pow[0][0]=Pow[1][0]=1; ull tmp[2]; tmp[0]=tmp[1]=0; for0(i,2) for1(j,m)&#123; Pow[i][j]=Pow[i][j-1]*seed[i]; tmp[i]+=Pow[i][j-1]; &#125; offset=tmp[0]*tmp[1]; for1(i,n) for1(j,n)&#123; Hash[0][i][j]=Hash[0][i][j-1]*seed[0]+a[i][j]; Hash[1][i][j]=Hash[1][i-1][j]*seed[1]+Hash[0][i][j]; &#125; for1(i,m)&#123; for1(j,m)hash2[i][j]=hash2[i][j-1]*seed[0]+b[i][j]; hash_b=hash_b*seed[1]+hash2[i][m]; &#125; hash_b-=b[1][1]*offset;&#125;ull get2(int x1,int y1,int x2,int y2)&#123; return Hash[1][x2][y2]-Hash[1][x1-1][y1]*Pow[1][m]; &#125;ull get(int x1,int y1,int x2,int y2)&#123; return get2(x1,y2,x2,y2)-get2(x1,y1-1,x2,y1-1)*Pow[0][m]-a[x1][y1]*offset;&#125;int main() &#123; in(n,m); for1(i,n) for1(j,n)in(a[i][j]); for1(i,m) for1(j,m)in(b[i][j]); init(); int ans=0; for(int i=1;i+m-1&lt;=n;i++) for(int j=1;j+m-1&lt;=n;j++)&#123; if(get(i,j,i+m-1,j+m-1)==hash_b)ans++; &#125; outln(ans); return 0;&#125; I. Beautiful Array题意长度为 $y$, 乘积为 $x$ 的序列的个数 如 $x=2,y=2$, $[1,2],[2,1],[-1,-2],[-2,-1]$ 题解分解 $x$, x=p_1^{a_1}*p_2^{a_2}\cdots p_m^{a_m}对方案数来说, 不同素因子是独立的, 对于 $p_i$, 其贡献相当于将 $a_i$ 个相同的球放进不同的盒子, 且允许有空, 为 \large C_{a_i+y-1}^{y-1}再考虑负数, 负号只能为偶数个, 其贡献为 \large C_y^0+C_y^2+C_y^4+\cdots=2^{y-1}代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;bool notPrime[N+1];int prime[N+1],num_prime=0;void get_prime()&#123; notPrime[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!notPrime[i]) prime[num_prime++]=i; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;=N;j++)&#123; int k = i*prime[j]; notPrime[k] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125;const int M =2.1e6;ll fac[M],inv[M];ll C(ll a,ll b)&#123; if(b&gt;a)return 0; return fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;void init()&#123;//快速计算阶乘的逆元 fac[0]=fac[1]=1; for(int i=2;i&lt;M;i++)fac[i]=fac[i-1]*i%mod; inv[M-1] = qPow(fac[M-1], mod - 2, mod); for (int i = M - 2; i &gt;= 0; i--) inv[i] = (inv[i + 1] * (i + 1)) % mod;&#125;int main() &#123; int t,x,y; in(t); get_prime(); init(); while(t--)&#123; in(x,y); if(y==0)&#123; puts("0"); continue; &#125;else if(x==0)&#123; puts("1"); continue; &#125; ll ans=1; for(int i=0;i&lt;num_prime&amp;&amp;x!=1;i++)&#123; if(x%prime[i]==0)&#123; int cnt=0; while(x%prime[i]==0)&#123; x/=prime[i]; cnt++; &#125; ans=ans*C(cnt+y-1,y-1)%mod; &#125; &#125; if(x!=1)ans=ans*y%mod; ans=ans*qPow(2,y-1,mod)%mod; outln(ans); &#125; return 0;&#125; title: 2019HDU多校-Day8mathjax: truedate: 2019-08-20 18:47:49tags: categories:F. Acesrc and Travel题意给一颗树，每个点有两个权值 $a_i,b_i$ ，两个人博弈，交替选择节点，A 获得 $a_i$ ，B 获得 $b_i$ ，每次只能选取与上一个人相邻的节点。 题解先以任意点为根节点，算出这种情况的结果，再利用换根的方法求出所有节，要注意处理好根节点和叶节点的情况 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;void out(int a,bool ln)&#123;printf("%d%c",a," \n"[ln]);&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a," \n"[ln]);&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a," \n"[ln]);&#125;const db pi = acos((db)-1);const ll inf =1e18;const db eps = 1e-8;const int N = 1.1e5;const int M = 2.1e5;const ll mod = 1e9;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;vii node[N];ll w[N];pll dp[N][2];ll ans;void dfs(int u,int fa)&#123; ll max_fi=-inf,max_se=-inf,min_fi=inf,min_se=inf; if(fa&amp;&amp;node[u].size()==1)&#123;//非根叶节点 dp[u][0]=pll(w[u],-inf); dp[u][1]=pll(w[u],inf); return; &#125; for(auto i:node[u])&#123; if(i!=fa)&#123; dfs(i,u); if(dp[i][0].fi+w[u]&lt;min_fi)&#123; min_se=min_fi; min_fi=dp[i][0].fi+w[u]; &#125;else min_se=min(min_se,dp[i][0].fi+w[u]); if(dp[i][1].fi+w[u]&gt;max_fi)&#123; max_se=max_fi; max_fi=dp[i][1].fi+w[u]; &#125;else max_se=max(max_se,dp[i][1].fi+w[u]); &#125; &#125; dp[u][0]=pll(max_fi,max_se); dp[u][1]=pll(min_fi,min_se);&#125;void dfs2(int u ,int fa ,ll max1,ll min0)&#123; if(u!=1)&#123; if(node[u].size()==1) ans=max(ans,min0+w[u]); else&#123; if(min0+w[u]&lt;dp[u][1].fi)ans=max(ans,min0+w[u]); else ans=max(ans,dp[u][1].fi); &#125; &#125; for(int v:node[u])&#123; if(v!=fa)&#123; ll tmin,tamx; if(dp[u][1].fi==dp[v][0].fi+w[u])tamx=min(min0+w[u],dp[u][1].se); else tamx=min(min0+w[u],dp[u][1].fi); if(dp[u][0].fi==dp[v][1].fi+w[u])tmin=max(max1+w[u],dp[u][0].se); else tmin=max(max1+w[u],dp[u][0].fi); // cout&lt;&lt;v&lt;&lt;' '&lt;&lt;tmin&lt;&lt; ' '&lt;&lt;tamx&lt;&lt;endl; dfs2(v,u,tamx,tmin); &#125; &#125;&#125;int main() &#123; int t,n,u,v,x; in(t); while(t--)&#123; in(n); for1(i,n)in(w[i]); for1(i,n)&#123; node[i].clear(); in(x); w[i]-=x; &#125; for0(i,n-1)&#123; in(u,v); node[u].pu_b(v); node[v].pu_b(u); &#125; dfs(1,0); ans=dp[1][1].fi; if(node[1].size()==1) dfs2(node[1][0],1,w[1],w[1]);// 特判根节点只连有一个点的情况 else dfs2(1,0,-inf,inf); out(ans,1); &#125; return 0;&#125; title: 2019ICPC-Nanchangmathjax: truedate: 2019-09-20 17:06:22tags: dp data structurecategories: icpc C. Hello 2019 (cf-705e)题意输入一个字符串，区间询问 $[s_l,s_r]$ 中，删去最少的字符，使得出现子序列 $”2019”$ ，而不出现 $”2018”$ 题解 $5$ 个状态： 0 - $””$ 1 - $”2”$ 2 - $”20”$ 3 - $”201”$ 4 - $”2019”$ 使用一个 $5\times5$ 的矩阵来表示每个点的状态转移所需要的代价，区间查询即这个区间的矩阵的乘积，这里的乘积有些不同，有点像 $floyd$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sz(a))#define mem_1(a) memset(a, -1, sz(a))#define mem0(a) memset(a, 0, sz(a))#define memcp(a,b) memcpy(a,b,sz(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define sz(a) (int)sizeof(a)typedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内 int inf = 0x3f3f3f3f;ll inf_ll = 0x3f3f3f3f3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e5;/*-----------------------------------head----------------------------------------------*/char s[N],t[N];struct node&#123; int a[5][5]; node()&#123;meminf(a);&#125; node operator+(const node&amp; Y)const&#123; node res; for0(i,5) for0(j,5) for0(k,5)&#123; res.a[i][j]=min(res.a[i][j],a[i][k]+Y.a[k][j]); &#125; return res; &#125;&#125;Sum[N&lt;&lt;2];void PushUp(int rt)&#123;Sum[rt]=Sum[rt&lt;&lt;1]+Sum[rt&lt;&lt;1|1];&#125;//PushUp函数更新节点信息 ，这里是求和void Build(int l,int r,int rt)&#123; //Build函数建树，l,r表示当前节点区间，rt表示当前节点编号 if(l==r) &#123;//若到达叶节点 // scanf("%d",&amp;Sum[rt]); //Sum[rt]=A[l];//储存数组值 for0(i,5)Sum[rt].a[i][i]=0; if(t[l]=='2')&#123; Sum[rt].a[0][0]=1; Sum[rt].a[0][1]=0; &#125;else if(t[l]=='0')&#123; Sum[rt].a[1][1]=1; Sum[rt].a[1][2]=0; &#125;else if(t[l]=='1')&#123; Sum[rt].a[2][2]=1; Sum[rt].a[2][3]=0; &#125;else if(t[l]=='9')&#123; Sum[rt].a[3][3]=1; Sum[rt].a[3][4]=0; &#125;else if(t[l]=='8')&#123; Sum[rt].a[3][3]=1; Sum[rt].a[4][4]=1; &#125; return; &#125; int m=(l+r)&gt;&gt;1; Build(l,m,rt&lt;&lt;1); Build(m+1,r,rt&lt;&lt;1|1); PushUp(rt);//更新信息 &#125;node Query(int L,int R,int l,int r,int rt)&#123;//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号 if(L &lt;= l &amp;&amp; r &lt;= R)&#123;//在区间内，直接返回 return Sum[rt]; &#125; int m=(l+r)&gt;&gt;1; node ANS; if(L &lt;= m) ANS=ANS+ Query(L,R,l,m,rt&lt;&lt;1); if(R &gt; m) ANS=ANS+ Query(L,R,m+1,r,rt&lt;&lt;1|1); return ANS;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,q; in(n,q); in(s+1); for(int i = 1; i &lt;= n; i++)&#123; t[i] = s[n - i + 1]; &#125; Build(1,n,1); int l,r; while(q--)&#123; in(l,r); node tmp=Query(n-r+1,n-l+1,1,n,1); if(tmp.a[0][4]==inf)out(-1,1); else out(tmp.a[0][4],1); &#125; return 0;&#125; 题意题解代码12 title: 2019ICPC-Shanghaimathjax: truedate: 2019-09-16 16:50:00tags: dfs dp fftcategories: icpc C. Triple题意给三个序列，分别从中选取一个数，输出能够构成一个三角形（线段也算）的方案数。 题解使用 $FFT$ 减去不符合条件的方案 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define sz(a) (int)sizeof(a)typedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for(int i=0;i&lt;n;i++)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for(int i=1;i&lt;=n;i++)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for(int i=0;i&lt;n;i++)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for(int i=1;i&lt;=n;i++)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for(int i=0;i&lt;n;i++)in(a[i]);&#125;void in1(int a[],int n)&#123;for(int i=1;i&lt;=n;i++)in(a[i]);&#125;void in0(ll a[],int n)&#123;for(int i=0;i&lt;n;i++)in(a[i]);&#125;void in1(ll a[],int n)&#123;for(int i=1;i&lt;=n;i++)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内 int inf = 0x3f3f3f3f;ll llinf = 0x3f3f3f3f3f3f3f3f;ll mod = 1e9+7;const int M = 1.1e6;const int N = 3.1e5;/*-----------------------------------head----------------------------------------------*/typedef complex &lt;double&gt; cp;struct FFT&#123; int n, R[N]; cp a[N], b[N]; const double pi=acos(-1); void init(int bound)&#123; //bound是积多项式的最高次幂 int L(0); for(n=1;n&lt;=bound;n&lt;&lt;=1,L++); for(int i=0;i&lt;n;i++)R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1)),a[i]=b[i]=0; &#125; void fft(cp* a, int opt)&#123; int i, j, k; cp wn, w, x, y; for(i=0;i&lt;n;i++)if(i&gt;R[i])swap(a[i],a[R[i]]); for(i=1;i&lt;n;i&lt;&lt;=1)&#123; wn=cp(cos(pi/i),opt*sin(pi/i)); for(j=0;j&lt;n;j+=i&lt;&lt;1) for(w=cp(1,0),k=0;k&lt;i;k++,w=w*wn)&#123; x=a[k+j], y=a[k+j+i]*w; a[k+j]=x+y, a[k+j+i]=x-y; &#125; &#125; if(opt==-1)for(i=0;i&lt;n;i++)a[i]/=n; &#125; void run()&#123; fft(a,1), fft(b,1); for(int i=0;i&lt;n;i++)a[i]*=b[i]; fft(a,-1); &#125;&#125;fft;ll ans;int cnta[N],cntb[N],cntc[N];void fun(int aa[],int bb[],int c[])&#123; for (int i = 0; i &lt;fft.n; i++)fft.a[i]=cp(aa[i]); for (int i = 0; i &lt;fft.n; i++)fft.b[i]=cp(bb[i]); fft.run(); ll pre=0; for(int i=0;i&lt;=1e5;i++)&#123; ans-=pre*c[i]; pre+=fft.a[i].real()+0.1; &#125;&#125;int tn;int main() &#123; int t,x; in(t); fft.init(2e5); for(int ca=1;ca&lt;=t;ca++)&#123; for (int i = 1; i &lt;= 1e5; i++)cnta[i]=cntb[i]=cntc[i]=0; in(tn); ans=1ll*tn*tn*tn; if(tn&lt;=1000)&#123; for (int i = 1; i &lt;= tn; i++)&#123; in(cnta[i]); &#125; for (int i = 1; i &lt;= tn; i++)&#123; in(cntb[i]); &#125; for (int i = 1; i &lt;= tn; i++)&#123; in(x); cntc[x]++; &#125; for (int i = 1; i &lt;= 1e5; i++)cntc[i]+=cntc[i-1]; ans=0; for (int i = 1; i &lt;= tn; i++) for (int j = 1; j &lt;= tn; j++)&#123; ans+=cntc[min(100000,cnta[i]+cntb[j])]-cntc[max(0,abs(cnta[i]-cntb[j])-1)]; &#125; &#125;else&#123; for (int i = 1; i &lt;= tn; i++)&#123; in(x); cnta[x]++; &#125; for (int i = 1; i &lt;= tn; i++)&#123; in(x); cntb[x]++; &#125; for (int i = 1; i &lt;= tn; i++)&#123; in(x); cntc[x]++; &#125; fun(cnta,cntb,cntc); fun(cnta,cntc,cntb); fun(cntb,cntc,cnta); &#125; printf("Case #%d: %lld\n",ca,ans); &#125; return 0;&#125; D. Counting Sequences I题意输入一个 $n$ ，问长度为 $n$ 的数列，满足 $a_1+a_2+\cdots+a_n=a_1\times a_2\times\cdots\times a_n$ 的方案数。 题解这样的序列满足 $1$ 的数量为 非 $1$ 部分的乘积减去非 $1$ 部分的和，我们只需要枚举非 $1$ 部分就可以了 设序列有 $k$ 种数，每种数有 $c_i$ 个，则方案数为 $\huge C_{n}^{c_1}\times C_{n-c_1}^{c_2}\times\cdots\times C_{n-c_1-\cdots-c_{i-1}}^{c_i}\times\cdots\times C_{c_k}^{c_k}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sz(a))#define mem_1(a) memset(a, -1, sz(a))#define mem0(a) memset(a, 0, sz(a))#define memcp(a,b) memcpy(a,b,sz(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define sz(a) (int)sizeof(a)typedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内int inf = 0x3f3f3f3f;ll inf_ll = 0x3f3f3f3f3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 3.1e3;/*-----------------------------------head----------------------------------------------*/ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;ll fac[N],inv[N];ll C(ll a,ll b)&#123; if(b&gt;a)return 0; return fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;void init()&#123;//快速计算阶乘的逆元 fac[0]=fac[1]=1; for(int i=2;i&lt;N;i++)fac[i]=fac[i-1]*i%mod; inv[N-1] = qPow(fac[N-1], mod - 2, mod); for (int i = N - 2; i &gt;= 0; i--) inv[i] = (inv[i + 1] * (i + 1)) % mod;&#125;ll ans[3300];//总个数，当前的最小值，当前的最小值的个数，总乘积，总和，大于当前最小值的数的贡献void dfs(int dep,int now,int cnt,ll mul,ll tot,ll w)&#123; int num1=mul-tot; if(dep+num1&gt;3000)return; ans[dep+num1]=(ans[dep+num1]+w*C(dep,cnt)%mod*C(dep+num1,num1)%mod)%mod; dfs(dep+1,now,cnt+1,mul*now,tot+now,w);//再取一个当前最小值 for(int i=now-1;i&gt;=2;i--)&#123;//取一个更小的值 dfs(dep+1,i,1,mul*i,tot+i,w*C(dep,cnt)%mod); &#125;&#125;int main() &#123; //freopen("a.txt","w",stdout); init(); for(int i=2;i&lt;=3000;i++)&#123; dfs(1,i,1,i,i,1); &#125; int t,n; in(t); while(t--)&#123; in(n); out(ans[n],1); &#125; return 0;&#125; F. Rhyme scheme题意对 $n$ 个元素划分集合，每一种划分对应一个长度为 $n$ 的字符串，对这 $B_n$ 个字符串按字典序排序，问第 $k$ 个是什么。 如 $n=3$ 时，字符串为 $AAA,AAB,ABA,ABB,ABC$ 题解设 $dp[n][i][j]$ 表示对于 $n$ 个元素，前 $i$ 个元素被分为了 $j$ 个集合，剩余 $n-i$ 个元素划分集合的方案数。 dp[n][i][j]=j*dp[n][i+1][j]+dp[n][i+1][j+1]然后再在字典树上查找答案就可以了 代码123456789101112131415161718192021222324252627282930313233343536__int128 dp[30][30][30];int main() &#123; for1(i,26)&#123; for1(j,i)dp[i][i][j]=1; for(int j=i-1;j&gt;=0;j--)&#123; for1(k,j)dp[i][j][k]=k*dp[i][j+1][k]+dp[i][j+1][k+1]; &#125; out(dp[i][1][1]); puts(""); &#125; int n,t; char s[30]; in(t); for1(ca,t)&#123; in(n);in(s); __int128 k=0; for(int i=0,len=strlen(s);i&lt;len;i++)&#123; k*=10; k+=s[i]-'0'; &#125; printf("Case #%d: ",ca); int cnt=0; for1(i,n)&#123; for1(j,cnt+1)&#123; int tm=max(cnt,j); if(k&lt;=dp[n][i][tm])&#123; cnt=tm; putchar('A'+j-1); break; &#125;else k-=dp[n][i][tm]; &#125; &#125; puts(""); &#125; return 0;&#125; J. Stone game题意 $n(1\le n\le300)$ 堆石子，每堆石子有 $a_i(1\le a_i\le 500)$ 个，问有多少种取法使得取走的数量大于等于剩余的数量而且按这种取法丢弃掉任意一堆都将会小于等于剩余的石子数 题解对石子数从大到小排序， $dp[i]$ 表示总共取 $i$ 的方案数 代码12345678910111213141516171819202122232425ll dp[N];int a[400];int main() &#123; int t,n; in(t); while(t--)&#123; in(n); ll tot=0; for0(i,n)in(a[i]),tot+=a[i]; sort(a,a+n,greater&lt;int&gt;()); ll ans=0; mem0(dp); dp[0]=1; int maxx=0; for0(i,n)&#123; maxx+=a[i]; for(int j=maxx;j-a[i]&gt;=0;j--)&#123; dp[j]=(dp[j]+dp[j-a[i]])%mod; if(2*j&gt;=tot&amp;&amp;2*j&lt;=tot+a[i])ans=(ans+dp[j-a[i]])%mod;//注意加的是dp[j-a[i]]而不是dp[j]，因为dp[j-a[i]]才表示取了a[i]后总和为j的方案数 &#125; &#125; out(ans,1); &#125; return 0;&#125; title: 2019ICPC-Shenyangmathjax: truedate: 2019-09-19 20:42:35tags: dpcategories: icpc D. Fish eating fruit题意将树上任意两点之间的距离按取模 $3$ 分类，分别求出三种情况的路径和 题解 解法1: $dp1[u][j]$ 表示以 $u$ 为根节点的树，树上任意两点之间的距离取模 $3$ 为 $j$ 的路径和 $dp2[u][j]$ 表示以 $u$ 为根节点的树，树上的点到 $u$ 的距离取模 $3$ 为 $j$ 的路径和 $dp3[u][j]$ 表示以 $u$ 为根节点的树，树上的点到 $u$ 的距离取模 $3$ 为 $j$ 的节点数 解法2: 根据模 3 的余数设计 dp 方程 $dp[i][k]$ 统计距 i 模 3 为 k 的子节点的数目 $fp[i][k]$ 统计距 i 模 3 为 k 的非子节点的数目（父节点，兄弟节点，兄弟节点 的子节点） $ans[i][k]$ 统计距 i 模 3 为 k 的子节点到 i 的距离和 $fans[i][k]$ 统计距 i 模 3 为 k 的非子节点距离和 代码1234567891011121314151617181920212223242526272829303132333435363738ll dp1[N][3],dp2[N][3],dp3[N][3];vector&lt;pii&gt; node[N];int n;void dfs(int u,int fa)&#123; dp3[u][0]=1; for(auto i:node[u])&#123; int v=i.fi,w=i.se; if(v==fa)continue; dfs(v,u); for0(i,3)dp1[u][i]=(dp1[u][i]+dp1[v][i])%mod; for0(i,3) for0(j,3)&#123; int tm=(i+j+w)%3; dp1[u][tm]=(dp1[u][tm]+dp2[u][i]*dp3[v][j]%mod+dp2[v][j]*dp3[u][i]%mod+dp3[v][j]*dp3[u][i]%mod*w%mod)%mod; &#125; for0(i,3)dp2[u][(w+i)%3]=(dp2[u][(w+i)%3]+dp2[v][i]+w*dp3[v][i])%mod; for0(i,3)dp3[u][(w+i)%3]=(dp3[u][(w+i)%3]+dp3[v][i])%mod; &#125; return ;&#125;int main() &#123; int u,v,w; while(~in(n))&#123; for0(i,n)&#123; node[i].clear(); mem0(dp1[i]);mem0(dp2[i]);mem0(dp3[i]); &#125; for0(i,n-1)&#123; in(u,v,w); node[u].push_back(pii(v,w)); node[v].push_back(pii(u,w)); &#125; dfs(0,-1); for0(i,3)dp1[0][i]=dp1[0][i]*2%mod; out0(dp1[0],3); &#125; return 0;&#125; 题意题解代码12 title: 2019牛客多校-Day1mathjax: truedate: 2019-08-13 19:16:14tags: math categories: 牛客B. Integration题意已知 $\Large \int_{0}^{\infty} \frac{1}{1+x^{2}} \mathrm{d} x=\frac{\pi}{2}$ ，求 $\Large\frac{1}{\pi} \int_{0}^{\infty} \frac{1}{\prod_{i=1}^{n}\left(a_{i}^{2}+x^{2}\right)} \mathrm{d} x$ 题解由 $\large\frac 1 a\times \frac 1 b=(\frac 1 a-\frac 1 b)\times \frac 1 {(b-a)}$ ，获得启发，化乘为加，令 $\large c_i=\prod\limits_{j\ne i}\frac 1 {a_j^2-a_i^2}$ ，则 $\large\prod \frac 1 {(a_i^2+x^2)}=\sum \frac {c_i}{a_i^2+x^2}$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d ",*ptr);&#125;void outln(initializer_list&lt;int&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d\n",*ptr);&#125;void out(initializer_list&lt;ll&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld ",*ptr);&#125;void outln(initializer_list&lt;ll&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld\n",*ptr);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln? '\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln? '\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln? '\n':' ');&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e3;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int a[N];ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; while(~in(n))&#123; for1(i,n)in(a[i]); // if(n==1)&#123; // out(qPow(2ll*a[1],mod-2,mod),1); // continue; // &#125; ll ans=0; for1(i,n)&#123; ll tm=1; for1(j,n)&#123; if(j!=i)&#123; tm=tm*((1ll*a[j]*a[j]%mod-1ll*a[i]*a[i]%mod+mod)%mod)%mod; // tm=tm*qPow((1ll*a[j]*a[j]%mod-1ll*a[i]*a[i]%mod+mod)%mod,mod-2,mod)%mod; &#125; &#125; ans=(ans+qPow(2*a[i],mod-2,mod)*qPow(tm,mod-2,mod)%mod)%mod; &#125; out(ans,1); &#125; return 0;&#125; C. Euclidean Distance题意给一个点 $(\frac {a_1} m,\frac {a_2} m,\cdots,\frac {a_n} m)(-m\le a_i\le m)$ ，找到一个点 $P(p_1,p_2,\cdots,p_n)(p_i\ge 0,\sum p_i=1)$ 使得 $\sum (\frac {a_i}m-p_i)^2$ 最小 题解对 $a_i$ 排序，逐渐减小最大的 $a_i$ ，使得序列的最大值尽可能小 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970bool cmp(int x,int y)&#123; return x&gt;y;&#125;ll gcd(ll x,ll y)&#123; return y?gcd(y,x%y):x;&#125;struct fraction&#123; ll son, mom; fraction()&#123;&#125; fraction(ll a,ll b)&#123; if(a)&#123;ll gc=gcd(abs(a),abs(b));if(b&lt;0) son=-a/gc,mom=-b/gc;else son=a/gc,mom=b/gc;&#125; else son=0,mom=1; &#125; bool operator==(const fraction &amp;x)const&#123; return son==x.son&amp;&amp;mom==x.mom; &#125; bool operator!=(const fraction &amp;x)const&#123; return !(son==x.son&amp;&amp;mom==x.mom); &#125; bool operator&lt;(const fraction &amp;y)const&#123; return son * y.mom &lt; y.son * mom; &#125; bool operator&lt;=(const fraction &amp;y)const&#123; return son * y.mom &lt;= y.son * mom; &#125; fraction operator*(const fraction &amp;y)const&#123; return fraction(son*y.son,mom*y.mom); &#125; fraction operator+(const fraction &amp;y)const&#123; return fraction(son * y.mom + y.son * mom,mom*y.mom); &#125; fraction operator/(const fraction &amp;y)const&#123; return fraction(son*y.mom,mom*y.son); &#125; fraction operator-(const fraction &amp;y)const&#123; return fraction(son * y.mom - y.son * mom,mom*y.mom); &#125; void display()&#123; if(mom==1)printf("%lld\n",son); else printf("%lld/%lld\n",son,mom); &#125;&#125;;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,a[N]; while(~in(n))&#123; in(m); for0(i,n)in(a[i]); sort(a,a+n,cmp); int remain=m; int i=1; for(;i&lt;n;i++)&#123; if(i*(a[i-1]-a[i])&lt;=remain)&#123; remain-=i*(a[i-1]-a[i]); &#125;else break; &#125; fraction ans=fraction(i*a[i-1]*a[i-1]-2*remain*a[i-1],1)+fraction(remain*remain,i); for(;i&lt;n;i++)&#123; ans=ans+fraction(a[i]*a[i],1); &#125; ans=ans/fraction(m*m,1); ans.display(); &#125; return 0;&#125; title: 2019牛客多校-Day4mathjax: truedate: 2019-08-09 17:13:44tags: string categories: 牛客I. String题意定义两个字符串不等为 $a\ne b \&amp;\&amp; a\ne rev(b) $ 给一个字符串，问由它的子串构成的 任意两个元素都不等 的最大集合有多大 题解显然答案为 $a,rev(a)$ 中本质不同的子串的数量除 2，注意若子串为回文串则只被计了一次，所以还需要加上一个 $a$ 中本质不同回文串的数量再除 2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 4.1e5;const int M = 4.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int t1[N],t2[N],c[N],srank[N],height[N],sa[N];bool cmp(int *r,int a,int b,int l)&#123; return r[a] == r[b] &amp;&amp; r[a+l] == r[b+l];&#125;void DA(int str[],int n,int m)&#123;//m为字符串中的最大值+1 n++; int i, j, p, *x = t1, *y = t2; //第一轮基数排序，如果s 的最大值很大，可改为快速排序 for(i = 0;i &lt; m;i++)c[i] = 0; for(i = 0;i &lt; n;i++)c[x[i] = str[i]]++; for(i = 1;i &lt; m;i++)c[i] += c[i-1]; for(i = n-1;i &gt;= 0;i--)sa[--c[x[i]]] = i; for(j = 1;j &lt;= n; j &lt;&lt;= 1)&#123; p = 0; //直接利用sa 数组排序第二关键字 for(i = n-j; i &lt; n; i++)y[p++] = i;//后面的j 个数第二关键字为空的最小 for(i = 0; i &lt; n; i++)if(sa[i] &gt;= j)y[p++] = sa[i] - j;//这样数组y保存的就是按照第二关键字排序的结果 //基数排序第一关键字 for(i = 0; i &lt; m; i++)c[i] = 0; for(i = 0; i &lt; n; i++)c[x[y[i]]]++; for(i = 1; i &lt; m;i++)c[i] += c[i-1]; for(i = n-1; i &gt;= 0;i--)sa[--c[x[y[i]]]] = y[i];//根据sa 和x 数组计算新的x 数组 swap(x,y); p = 1; x[sa[0]] = 0; for(i = 1;i &lt; n;i++)x[sa[i]] = cmp(y,sa[i-1],sa[i],j)?p-1:p++; if(p &gt;= n)break; m = p;//下次基数排序的最大值 &#125; int k = 0; n--; for(i = 0;i &lt;= n;i++)srank[sa[i]] = i; for(i = 0;i &lt; n;i++)&#123; if(k)k--; j = sa[srank[i]-1]; while(str[i+k] == str[j+k])k++; height[srank[i]] = k; &#125;&#125;const int C = 26;struct Palindromic_Tree &#123; int next[N][C] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[N] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[N] ;//cnt[i]表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的） int num[N] ;//num[i]表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数。 int len[N] ;//len[i]表示节点i表示的回文串的长度 int S[N] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int newnode ( int l ) &#123;//新建节点 for ( int i = 0 ; i &lt; C ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125; PAM;int r[N];char s[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(s); ll n=strlen(s); s[n]='`'; PAM.init(); for0(i,n) &#123; s[2*n-i]=s[i]; PAM.add(s[i]); &#125; ll m=2*n+1; for0(i,m)r[i]=s[i]-'`'+1; r[m]=0; DA(r,m,30); ll ans=PAM.p-2+m*(m+1)/2-(n+1)*(n+1); for(int i=2;i&lt;=m;i++)ans-=height[i]; outln(ans/2); return 0;&#125; title: 2019-牛客多校-Day5mathjax: truedate: 2019-08-08 08:35:54tags: math categories: 牛客C. generator 2题意给出 $n, x_{0}, a, b, p \quad\left(1 \leq n \leq 10^{18}, 0 \leq x_{p}, a, b&lt;p \leq 10^{9}+9,\text{p is a prime number}\right)$ ，$q$次询问，问在序列 $x_0,x_1,\cdots,x_{n-1}$ 中最小的 $i$ ，使得 $x_i=v$ 题解需要手写Hash，对于 GSBS 中的 $c_im-r_i$ ，因为有多组，且 $a,p$ 都不变，我们可以预处理 $\large a^{im}$ ，每组样例的时间复杂度为 $\frac p m+qm $ ，所以 $m=\sqrt{\frac p q}$ 时，总的时间复杂度最小 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e6;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;struct Hash &#123; static const int MOD = 2e6+7; static const int N = 2e6; ll head[MOD + 10], nx[N], top; ll hs[N], id[N]; void init() &#123; memset(head, -1, sizeof head); top = 0; &#125; void insert(ll x, ll y) &#123;//x-key y-val ll k = x % MOD; hs[top] = x; id[top] = y; nx[top] = head[k]; head[k] = top++; &#125; ll find(ll x) &#123; ll k = x % MOD; for (int i = head[k]; i != -1; i = nx[i]) &#123; if (hs[i] == x) &#123; return id[i]; &#125; &#125; return -1; &#125;&#125;hs;ll m,n;ll BSGS(ll a, ll b, ll p) &#123; // a^x == b (mod p) if(b==1)return 0; ll ans=p-1; for (ll i = 0; i &lt; m; ++i) &#123; if(hs.find(b)&gt;=0)&#123; ans=min(ans,hs.find(b)-i); &#125; b = b * a % p; &#125; if(ans==p-1||ans&gt;=n) return -1; else return ans;&#125;int main() &#123; int t,x,a,b,q; ll p; ll v; in(t); whiel(t--)&#123; in(n); in(x,a,b); in(p); in(q); if(a==1)&#123; while(q--)&#123; in(v); ll an=(v-x+p)%p*qPow(b,p-2,p)%p; if(an&lt;n)outln(an); else outln(-1); &#125; &#125;else if(a==0)&#123; while(q--)&#123; in(v); if(v==x)outln(0); else if(v==b&amp;&amp;n&gt;1)outln(1); else outln(-1); &#125; &#125;else&#123; m = ceil(sqrt(1.0*p/q)); ll tt = qPow(a,m,p), vv= 1; hs.init(); for ( ll i = 1; ; ++i) &#123; vv = vv * tt % p; if(hs.find(vv)==-1) hs.insert(vv,i*m); if(i*m&gt;=p)break; &#125; while(q--)&#123; in(v); ll c=b*qPow(a-1,p-2,p)%p; v=(v+c)%p*qPow(x+c,p-2,p)%p; outln(BSGS(a,v,p)); &#125; &#125; &#125; return 0;&#125; title: BZOJ-3992mathjax: truedate: 2019-08-30 16:10:20tags: ntt 快速幂categories: bzoj 题意集合 $S\subseteq \{x|x\in[0,m-1]\}$ ，由这些数组成一个长度为 $N$ 的数列，给定整数 $r(r\in[0,m-1])$，求满足数列中所有数的乘积 $\mod m$ 的值等于 $r$ 的不同的数列的有多少个。 题解将 $S$ 和 $x$ 由 $m$ 的原根来表示，这样就可以变乘为加，将集合 $S$ 表示为 $\large f(x)=a_0x^0+a_1x^1+\cdots+a_{m-2}x^{m-2}$ ， $a_i$ 表示 $g^i$ 是否属于 $S$ 将 $f(x)$ 看作一个整体，使用快速幂和 $NTT$ 求解 $f(x)^n$ ，答案就为 $x^r$ 的系数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;typedef int itn;// void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;// void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;// void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;// void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;// void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;// void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;ll inf =0x3f3f3f3f;ll mod = 1004535809;const int M = 2.1e5;const int N = 4.1e4;/*-----------------------------------head----------------------------------------------*/ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int factor[50];int num_factor = 0;void decomposition(ll n) &#123; num_factor = 0; int m=(int)sqrt(n+0.5); for(int i=2;i&lt;=m;i++)&#123; if(n%i==0)&#123; factor[num_factor]=i; while(n%i==0)n/=i; num_factor++; &#125; &#125; if (n &gt; 1) factor[num_factor++] =n;&#125;int root(int m)&#123;//求a在模m意义下的阶 int phi=m-1; decomposition(phi); int g=2; while(1)&#123; bool yes=1; for0(i,num_factor)&#123; if(qPow(g,phi/factor[i],m)==1)&#123; yes=0; break; &#125; &#125; if(yes)break; g++; &#125; return g;&#125;int Map[N];int n,r[N];ll g=3,inv_g,inv_n;void init(int a,int b)&#123; int L=0;n=1; while(n &lt; a + b) n &lt;&lt;= 1,L++; inv_g=qPow(3,mod-2,mod); inv_n = qPow(n,mod-2,mod); for(int i = 0; i &lt; n; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); &#125;inline void NTT(int *A, int type) &#123;//type=1 系数-&gt;点值 ; type=-1 点值-&gt;系数 for(int i = 0; i &lt; n; i++) if(i &lt; r[i]) swap(A[i], A[r[i]]); for(int mid = 1; mid &lt; n; mid &lt;&lt;= 1) &#123; ll Wn = qPow( type == 1 ? g : inv_g , (mod - 1) / (mid &lt;&lt; 1),mod); for(int j = 0; j &lt; n; j += (mid &lt;&lt; 1)) &#123; ll w = 1; for(int k = 0; k &lt; mid; k++, w = (w * Wn) % mod) &#123; int x = A[j + k], y = w * A[j + k + mid] % mod; A[j + k] = (x + y) % mod, A[j + k + mid] = (x - y + mod) % mod; &#125; &#125; &#125; if(type==-1) for0(i,n)A[i]=A[i]*inv_n%mod;&#125;int ans[N],a[N],b[N];int m;void mult(int a[],int b[])&#123; NTT(a,1); NTT(b,1); for(int i=0;i&lt;n;i++) a[i]=1ll*a[i]*b[i]%mod; NTT(a, -1); for(int i=m-1;i&lt;2*m-1;i++)&#123; a[i%(m-1)]=(a[i%(m-1)]+a[i])%mod; a[i]=0; &#125;&#125;int main() &#123; int N,x,s,y; in(N,m,x,s); int rt=root(m),tm=1; for(int i=0;i&lt;m-1;i++)&#123; Map[tm]=i; tm=tm*rt%m; &#125; Map[0]=m-1; x=Map[x]; bool have0=0; for0(i,s)&#123; in(y); a[Map[y]]=1; if(y==0)have0=1; &#125; if(x==m-1)&#123; if(have0)&#123; out((qPow(s,N,mod)-qPow(s-1,N,mod)+mod)%mod,1); &#125;else out(0,1); return 0; &#125; ans[0]=1;a[m-1]=0; init(m-1,m-1); while(N)&#123; if(N%2)&#123; memcpy(b,a,sizeof(int)*(2*m)); memcp(b,a); mult(ans,b); &#125; memcpy(b,a,sizeof(int)*(2*m)); mult(a,b); N/=2; &#125; out(ans[x],1); return 0;&#125; title: CF-1062date: 2019-03-02 21:33:31tags: mathcategories: cfmathjax: true D. Fun with Integers题意You are given a positive integer n​ greater or equal to 2. For every pair of integers a and b (2≤|𝑎|,|𝑏|≤𝑛2≤|a|,|b|≤n), you can transform a into b if and only if there exists an integer x such that 1&lt;|x| and (a⋅x=b or b⋅x=a), where |x| denotes the absolute value of x. After such a transformation, your score increases by |x| points and you are not allowed to transform a into b nor b into a anymore. Initially, you have a score of 0. You can start at any integer and transform it as many times as you like. What is the maximum score you can achieve? 题解答案为 2~n 每个数的因子( 范围为$[2,n)$ )之和。 \Huge\sum s_i代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; ll ans=0; cin&gt;&gt;n; forl(i,2,n)&#123; ans+=1ll*i*(n/i-1); &#125; cout&lt;&lt;ans*4&lt;&lt;endl; return 0;&#125; title: CF-1076date: 2019-03-02 21:17:02tags: data structurecategories: cfmathjax: true D. Edge Deletion题意the length of the shortest path from vertex 1 to vertex i as $d_i$ . You have to erase some edges of the graph so that at most k edges remain. Let’s call a vertex i good if there still exists a path from 1 to i with length $d_i$ after erasing the edges. Your goal is to erase the edges in such a way that the number of good vertices is maximized. 题解先跑个最短路，再搜索，取最短路上的边。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf = 0x3f3f3f3f;const ll mod = 1e9 + 7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b) &#123; return sign(a - b); &#125;struct Edge &#123; int v, w, nxt, no;&#125; edge[2 * N];int fir[N], cnt;void addedge(int u, int v, int w, int no) &#123; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].nxt = fir[u]; edge[cnt].no = no; fir[u] = cnt++;&#125;struct node &#123; int u; ll d; node(int u, ll d) : u(u), d(d) &#123;&#125; bool operator&lt;(const node &amp;a) const &#123; return d &gt; a.d; &#125;&#125;;bool used[N];ll d[N];void dijkstra() &#123; priority_queue&lt;node&gt; que; meminf(d); d[1] = 0; que.push(node(1, d[1])); while (!que.empty()) &#123; int u = que.top().u; que.pop(); if (used[u]) continue; used[u] = 1; for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] &gt; d[u] + w) &#123; d[v] = d[u] + w; que.push(node(v, d[v])); &#125; &#125; &#125;&#125;bool used_edge[N];void init() &#123; mem_1(fir); cnt = 0;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif // ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); init(); int n, m, k, u, v, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for1(i, m) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w, i); addedge(v, u, w, i); &#125; if (k == 0) &#123; puts("0\n"); return 0; &#125; dijkstra(); queue&lt;int&gt; que; que.push(1); mem0(used); used[1] = 1; int ans = 0; while (que.size()) &#123; int u = que.front(); que.pop(); for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] == d[u] + w) &#123; used_edge[edge[i].no] = 1; used[v] = 1; ans++; if (ans == k) break; que.push(v); &#125; &#125; if (ans == k) break; &#125; printf("%d\n", ans); for1(i, m) &#123; if (used_edge[i]) printf("%d ", i); &#125; puts(""); return 0;&#125; E. Vasya and a Tree题意给一颗树，将 v 和与 v 距离小于 d 的 v 的子节点的权值加上 x，输出所有节点的权值。 题解保存每个点每次加权的终点和 x。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vi;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vi node[N];int dep[N];ll change[N];bool vis[N];int maxx;void dfs(int r,int dph)&#123; dep[r]=dph; vis[r]=1; maxx=max(maxx,dph); for(int v:node[r])if(vis[v]==0)dfs(v,dph+1);&#125;struct da&#123; int end,x; da()&#123;&#125; da(int a,int b):end(a),x(b)&#123;&#125;&#125;;vector&lt;da&gt; weight[N];ll tmpc[N];void ddfs(int r,int depth,ll sum)&#123; for(auto i:weight[r])&#123; sum+=i.x; tmpc[i.end]+=i.x; &#125; change[r]+=sum; sum-=tmpc[depth]; vis[r]=1; for(int v:node[r])if(vis[v]==0)ddfs(v,depth+1,sum); for(auto i:weight[r])tmpc[i.end]-=i.x;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,d,x; ind(n); for0(i,n-1)&#123; scanf("%d%d",&amp;u,&amp;v); node[u].push_back(v); node[v].push_back(u); &#125; dfs(1,1); ind(m); for0(i,m)&#123; scanf("%d%d%d",&amp;v,&amp;d,&amp;x); weight[v].push_back(da(min(dep[v]+d,maxx),x)); &#125; mem0(vis); ddfs(1,1,0); for1(i,n)printf("%lld ",change[i]); puts(""); return 0;&#125; title: CF-11mathjax: falsedate: 2019-03-22 11:24:36tags: dp categories: cfD. A Simple Task题意求出一个n个点m个边的图，求简单环有多少（没有重复点和边）。（n&lt;20） 题解用S能记录状态（有多少个点在路径中），那么如何找环能确保不重不漏啦，对于一个环，找出他的特异性记录，一个环，如果以最小点为环的“起始点”，则每个环都被记录啦两次。用dp[s][i]表示路径s的当前点为i的次数，枚举下一点，如果形成环就加上答案，否则记录下一边。由于题目求的是超过三个点的简单环，而之前所求两个点也会被记录。减掉就可以啦。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(25)using namespace std;ll dp[1&lt;&lt;19][N];int n,m;bool a[N][N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); scanf("%d%d",&amp;n,&amp;m); int u,v; ll ans=0; for0(i,m)&#123; scanf("%d%d",&amp;u,&amp;v); u--;v--; a[u][v]=a[v][u]=1; &#125; for0(i,n)dp[1&lt;&lt;i][i]=1; for(int i=1;i&lt;1&lt;&lt;n;i++)&#123; int st; for0(k,n) if(i&amp;(1&lt;&lt;k))&#123; st=k; break; &#125; for(int k=st+1;k&lt;n;k++)&#123; if(dp[i][k]==0)continue; if(a[k][st]&amp;&amp;__builtin_popcount(i)&gt;2)ans+=dp[i][k]; &#125; for(int j=st;j&lt;n;j++)&#123; if(dp[i][j]==0)continue; for(int k=st+1;k&lt;n;k++) if(a[j][k]&amp;&amp;!(i&amp;(1&lt;&lt;k)))dp[i+(1&lt;&lt;k)][k]+=dp[i][j]; &#125; &#125; printf("%lld\n",ans/2); return 0;&#125; 引用 https://blog.csdn.net/m0_37953323/article/details/77169608---title: CF-1139mathjax: truedate: 2019-03-30 21:00:47tags: dp math number theorycategories: cf D. Steps to One题意每次从$1\sim m$从等概率的选择一个数, 直到所有选择的数的 gcd 为 1, 问操作的次数的期望是多少? 题解1设$f[n]$表示当前 gcd 为 n 还需要的步数的期望 f[n]=1+\frac {\sum\limits_{i=1}^mf[gcd(i,n)]} m\\ \sum\limits_{i=1}^mf[gcd(i,n)]=\sum\limits_{d|n}f[d]\sum\limits_{i=1}^me[gcd(i,n)==d]\\ \sum\limits_{i=1}^me[gcd(i,n)==d]=\sum\limits_{i=1}^{\lfloor \frac m d\rfloor}\epsilon[gcd(i,\frac n d)] \\=\sum\limits_{i=1}^{\lfloor \frac m d\rfloor}\sum\limits_{t|gcd(i,\frac n d)}\mu(t)=\sum\limits_{t|\frac n d}\mu(t)\lfloor \frac m {dt}\rfloor\\ 接下来把右边f[n]的项提出来\\ (m-\lfloor\frac m n\rfloor)f[n]=m+\sum\limits_{d|n,d\ne n}f[d]\sum\limits_{t|\frac n d}\mu(t)\lfloor \frac m {dt}\rfloor\\ ans=1+\frac {\sum\limits_{i=1}^mf[i]} m题解2设$E[n|i]$表示 gcd 为 n 的倍数的期望步数 k=\lfloor\frac m n\rfloor\\ E[n|i]=\sum\limits_{j=1}^{\infty}j*\frac {k^j} {m^j}=\frac {\frac k m} {1-\frac k m}=\frac k {m-k}\\ ans=1+E[i>1]=1+\sum_{j=2}^m-\mu(j)E[j|i]代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//解1int f[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m; cin&gt;&gt;m; for1(i,m)&#123; for(int j=1;j*j&lt;=i;j++)&#123; if(i%j==0)&#123; if(i/j==j)&#123; fac[i].pb(j); &#125;else&#123; fac[i].pb(j); fac[i].pb(i/j); &#125; &#125; &#125; &#125; get_prime(); f[1]=0; ll tot=0; forl(n,2,m)&#123; ll t_tmp=m; for0(j,fac[n].size())&#123; ll d=fac[n][j]; if(d==n)continue; ll cnt=0; for0(k,fac[n/d].size())&#123; int t=fac[n/d][k]; cnt=(cnt+(ll)mu[t]*(m/d/t)%mod)%mod; &#125; t_tmp=(t_tmp+f[d]*cnt%mod)%mod; &#125; f[n]=t_tmp*qPow(m-m/n,mod-2,mod)%mod; tot=(tot+f[n])%mod; // cout&lt;&lt;f[n]&lt;&lt;endl; &#125; printf("%lld\n",(tot*qPow(m,mod-2,mod)%mod+1)%mod); return 0;&#125;//解2bool notPrime[N+1];int prime[N+1],num_prime=0,mu[N+1];void get_prime()&#123; notPrime[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!notPrime[i]) &#123; prime[num_prime++]=i; mu[i]=1; &#125; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;=N;j++)&#123; int k = i*prime[j]; notPrime[k] = 1; if(i % prime[j] == 0)break; else mu[k]=mod-mu[i]; &#125; &#125;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=ans*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return ans;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m; in(m); get_prime(); ll ans=1; forl(i,2,m)&#123; ll k=m/i; ans=(ans+mu[i]*k%mod*qpow(m-k,mod-2)%mod)%mod; &#125; printf("%lld\n",ans); return 0;&#125; 引用 https://www.cnblogs.com/zyt1253679098/p/10584706.htmlhttps://blog.csdn.net/neuq_zsmj/article/details/88830388---title: CF-1144mathjax: truedate: 2019-04-01 13:58:55tags: greedy dp data structurecategories: cf F. Graph Without Long Directed Paths题意一个严格递增的数列, 一个严格递减的数列, 将它们保持原相对顺序不变合并在一起. 给出合并后的数列. 题解1 (greedy)维护一个递增数列 A, 一个递减的数列 B, 当只能插入一个数列的时候插入对应数列, 当两个都不能插入时输出”NO”, 当两个都能插入时, 若下一个数大于当前数, 插入 A, 否则插入 B. 题解2 (dp)$dp[ i ][ 0 ]$表示处理完前 $i$ 个， 第 $i$ 个是递增序列序列里的元素，递减序列的最大值。 $dp[ i ][ 1 ]$表示处理完前 $i$ 个， 第 $i$ 个是递减序列序列里的元素，递增序列的最小值。 https://www.cnblogs.com/CJLHY/p/10634175.html 代码123456789101112131415161718192021222324252627282930313233343536373839int a[N],flag[N];vii Inc,Dec;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; in(n); for0(i,n)in(a[i]); Inc.pb(-1); Dec.pb(3e5); for0(i,n)&#123; if(Inc.back()&gt;=a[i]&amp;&amp;Dec.back()&lt;=a[i])&#123; puts("NO"); return 0; &#125; if(Inc.back()&gt;=a[i])&#123; flag[i]=1; Dec.pb(a[i]); continue; &#125; if(Dec.back()&lt;=a[i])&#123; Inc.pb(a[i]); continue; &#125; if(a[i+1]&gt;a[i])&#123; Inc.pb(a[i]); &#125;else &#123; flag[i]=1; Dec.pb(a[i]); &#125; &#125; puts("YES"); for0(i,n)printf("%d ",flag[i]); puts(""); return 0;&#125; title: CF-1148Emathjax: truedate: 2019-06-04 17:32:04tags: greedy categories: cfEarth Wind and Fire题意给两个长度为 $n$ 个数组 $a,b$, 如果 $a_i\le a_j$ 可以取一个 $d(0\le 2*d\le a_j-a_i)$ , 然后 $a_i+d,a_j-d$ , 问如何操作可以让 $a$ 变为 $b$ 题解对 $a,b$ 排序, 将 $a_i$ 变为 $b_i$, 用一个 $stack$ 维护 $a$ 中待加值的元素 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758pii a[N];int b[N];bool cmp(pii x,pii y)&#123; return x.fi&lt;y.fi;&#125;struct da&#123; int i,j,d; da(int q,int w,int e)&#123; i=q;j=w;d=e; &#125;&#125;;vector&lt;da&gt;v;stack&lt;int&gt;les;int main() &#123; int n; in(n); for1(i,n)&#123; in(a[i].fi); a[i].se=i; &#125; for1(i,n)in(b[i]); sort(a+1,a+1+n,cmp); sort(b+1,b+n+1); bool yes=1; for1(i,n)&#123; if(a[i].fi&gt;b[i])&#123; a[i].fi-=b[i]; while(a[i].fi&amp;&amp;les.size())&#123; int no=les.top(); les.pop(); int minn=min(a[no].fi,a[i].fi); if(a[no].fi&gt;a[i].fi)les.push(no); a[i].fi-=minn; a[no].fi-=minn; v.pu_b(da(a[no].se,a[i].se,minn)); &#125; if(a[i].fi)&#123; yes=0; break; &#125; &#125;else if(a[i].fi&lt;b[i])&#123; a[i].fi=b[i]-a[i].fi; les.push(i); &#125; &#125; if(les.size()==0&amp;&amp;yes)&#123; puts("YES"); assert(v.size()&lt;=5*n); outln((int)v.size()); for(auto i:v)&#123; printf("%d %d %d\n",i.i,i.j,i.d); &#125; &#125;else &#123; puts("NO"); &#125; return 0;&#125; title: CF-1151mathjax: truedate: 2019-04-22 19:14:54tags: dp categories: cfE. Number of Components题意一条链, 每个点的权值为 $a_i(1\le a_i\le n)$ , $f(l,r)$ 表示仅保留权值在 $[l,r]$ 之间的点的联通分量 求 \sum\limits_{l=1}^{n} \sum\limits_{r=l}^{n} f(l, r)题解统计每个点的贡献, 只有当取 $a_i$ 不取 $a_{i+1}$ 时, $a_i$ 才有贡献 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x; ll pre; in(n); ll ans=0; in(pre); ans+=pre*(n+1-pre); for0(i,n-1)&#123; in(x); if(x&gt;pre)&#123; ans+=(x-pre)*(n+1-x); pre=x; &#125;else if(x&lt;pre)&#123; ans+=(pre-x)*x; pre=x; &#125; &#125; outln(ans); return 0;&#125; F. Sonya and Informatics题意数组 $a$ 有 $n$ 个数, 这些数由 $0,1$ 构成, 等概率交换任意两个数的位置, 问最后得到一个不下降的数列的概率, 答案对 $1e9+7$ 取模 题解设 $x$ 表示 $0$ 的个数, $dp[i][j]$ 表示操作 $i$ 次后前 $x$ 个数中 $0$ 的个数为 $j$ 的概率, 答案为 $dp[k][x]$ 可以发现状态转移方程与 $i$ 无关, 可以用矩阵快速幂做 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[110];ll matrix[110][110];ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int n,k,x=0,xx=0;void fun(ll c[110][110],ll b[110][110])&#123; ll tmp[110][110]; mem0(tmp); for0(i,x+1) for0(j,x+1) for0(k,x+1)tmp[i][j]=(tmp[i][j]+c[i][k]*b[k][j])%mod; memcp(c,tmp);&#125;ll Com(ll a)&#123; if(a&lt;2)return 0; return a*(a-1)/2;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // cout&lt;&lt;qPow(3,mod-2,mod)&lt;&lt;endl; in(n,k); ll C=n*(n-1)/2,inv_C=qPow(C,mod-2,mod); inv_C=qPow(inv_C,k,mod); for1(i,n)&#123; in(a[i]); if(!a[i])x++; &#125; ll A=Com(x),B=Com(n-x); for1(i,x)if(!a[i])xx++; int minn=max(0,2*x-n); // cout&lt;&lt;x&lt;&lt;' '&lt;&lt;xx&lt;&lt;' '&lt;&lt;minn&lt;&lt;endl; forl(i,minn,x)&#123; int p1=0,p2=0; if(i-1&gt;=minn)&#123; matrix[i-1][i]=p1=(x-i+1)*(x-i+1); &#125; if(i+1&lt;=x)&#123; matrix[i+1][i]=p2=(i+1)*(n-2*x+i+1); &#125; matrix[i][i]=A+B+i*(x-i)+(n-2*x+i)*(x-i); &#125; ll an[110][110]; for0(i,x+1)an[i][i]=1; while(k)&#123; if(k&amp;1)fun(an,matrix); fun(matrix,matrix); k&gt;&gt;=1; &#125; outln(an[xx][x]*inv_C%mod); return 0;&#125; title: CF-1152mathjax: truedate: 2019-08-27 20:56:07tags: dp categories: cfD. Neko and Aki’s Prank题意将长度为 $2n$ 的所有合法括号匹配放入字典树中，求这棵树的最大的边集，边集里的边两两不相连 题解对于括号匹配 $(((),()((,(()($ 来说，其子树是一样的， $dp[i][j]$ 表示深度为 $i$ 的左括号比右括号多 $j$ 的括号匹配的答案，我们直接贪心的取边，能取就取，使用一个 $vis[i][j]$ 来标记点是否取了，$dp[i][j]=dp[i+1][j+1]+dp[i+1][j-1]+(vis[i+1][j+1]==0||vis[i+1][j-1]==0)$，注意判断 $[i][j]$ 是否是合法的节点 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e3;/*-----------------------------------head----------------------------------------------*/int dp[N][N],n;bool vis[N][N];bool check(int i,int j)&#123; if(j&gt;=0&amp;&amp;j&lt;=n&amp;&amp;(i-j)%2==0&amp;&amp;i+j&lt;=2*n)retrun 1; else retrun 0;&#125;int main() &#123; in(n); for(int i=2*n-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;=min(n,i);j++)&#123; bool flag=0; if(check(i+1,j-1))&#123; if(vis[i+1][j-1]==0)vis[i+1][j-1]=1,flag=1; dp[i][j]=(dp[i][j]+dp[i+1][j-1])%mod; &#125; if(check(i+1,j+1))&#123; if(vis[i+1][j+1]==0&amp;&amp;flag==0)flag=1,vis[i+1][j+1]=1; dp[i][j]=(dp[i][j]+dp[i+1][j+1])%mod; &#125; if(flag)&#123; vis[i][j]=1,dp[i][j]=(dp[i][j]+1)%mod; &#125; &#125; &#125; out(dp[0][0],1); return 0;&#125; title: CF-1154mathjax: truedate: 2019-04-19 17:37:00tags: dp mathcategories: cf E. Two Teams题意一个 $1\sim n$ 的排列, 从大到小删数, 当删一个数时将其左右的 $k$ 个数也删了, 若某个数是第奇数次删的输出 1, 否则输出 2 题解维护两个数组 $l[i],r[i] $ 分别表示第 $i$ 个数左边, 右边的数所在的地方 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int l[N],r[N],Map[N],ans[N],a[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,k; in(n,k); for1(i,n)&#123; in(a[i]); Map[a[i]]=i; l[i]=i-1; r[i]=i+1; &#125; int flag=-1; for(int i=n;i&gt;=1;i--)&#123; if(Map[i])&#123; int poi=Map[i],ml=poi,mr=poi; for(int i=poi,j=0;i&lt;=n&amp;&amp;j&lt;=k;j++,mr=i=r[i])&#123; ans[i]=flag; Map[a[i]]=0; &#125; ml=poi=l[poi]; for(int i=poi,j=0;i&lt;=n&amp;&amp;j&lt;k;j++,ml=i=l[i])&#123; ans[i]=flag; Map[a[i]]=0; &#125; r[ml]=mr; l[mr]=ml; if(flag==-1)flag=-2; else flag=-1; &#125; &#125; for1(i,n)out(-ans[i]); puts(""); return 0;&#125; F. Shovels Shop题意$n$ 个物品, 其价格分别为 $a_i$ , 有 $m$ 种折扣, 买 $x_i$ 件物品, 便宜的 $y_i$ 件免费, 买 $k(\le 2000)$ 件的最小花费 题解$dp[i]$ 表示买 $i$ 件物品的最小花费 $dp[i]=min(dp[i-1]+a[i],dp[i-j]+pre[i]-pre[ i-cost[j] ])$ $cost[i]$ 表示买 $i$ 件物品最小需要支付的物品数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],dp[2003],cost[2003],pre[2003];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,k,x,y; meminf(cost); in(n,m,k); for1(i,n)in(a[i]); for0(i,m)&#123; in(x,y); if(x&lt;2001) cost[x]=min(cost[x],x-y); &#125; sort(a+1,a+n+1); for1(i,k)pre[i]=pre[i-1]+a[i]; for1(i,k)&#123; dp[i]=dp[i-1]+a[i]; for1(j,i) if(cost[j]&lt;inf) dp[i]=min(dp[i],dp[i-j]+pre[i]-pre[i-cost[j]]); &#125; outln(dp[k]); return 0;&#125; G. Minimum Possible LCM题意给 $n(2\le n \le 1e6)$ 个数, 求最大的 $lcm(a_i,a_j) (1\le a_i\le 1e7)$ 题解枚举 $gcd(a_i,a_j)$ , 找到最小的 $a_i, a_j$ 时间复杂度 $O(\frac {10^7}1+\frac {10^7}2+\frac {10^7}3+\cdots+\frac {10^7}{10^7})\approx O(10^7log(10^7))$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e7;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N][3];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x,maxx=0; in(n); for1(i,n)&#123; in(x); maxx=max(maxx,x); if(a[x][0]==0)&#123; a[x][1]=i; a[x][0]=1; &#125;else if(a[x][0]==1)&#123; a[x][2]=i; a[x][0]=2; &#125; &#125; ll minn=1e18; pii ans; for1(g,maxx)&#123; ll x1=0; for(int j=g;j&lt;=maxx;j+=g)&#123; if(x1)&#123; if(a[j][0])&#123; if(x1*j/g&lt;minn)&#123; ans=pii(a[x1][1],a[j][1]); minn=x1*j/g; &#125; break; &#125; &#125;else&#123; if(a[j][0]==1)&#123; x1=j; &#125;else if(a[j][0]==2)&#123; x1=j; if(x1*x1/g&lt;minn)&#123; ans=pii(a[x1][1],a[j][2]); minn=x1*j/g; &#125; break; &#125; &#125; &#125; &#125; if(ans.fi&gt;ans.se)swap(ans.fi,ans.se); printf("%d %d\n",ans.fi,ans.se); return 0;&#125; title: CF-1174Dmathjax: truedate: 2019-06-04 18:09:48tags: implementation categories: cfEhab and the Expected XOR Problem题意给 $n(1\le n\le 18),x(1\le x&lt;2^{18})$ , 构造一个数组 $a(1\le a_i&lt;2^n)$ , 使得这个数组的任意子段的异或和不为 0 或 $x$ 题解要使得这个数组的任意子段的异或和不为 0, 只需要保证数组的前缀和都不同就可以了. 假设 $A\text^B=x$ , 可以将 $[0,2^n-1]$ 分为两部分, 没部分里面的数两两异或都不为 $x$ 代码12345678910111213141516171819202122232425262728bool vis[N];vii v;int main() &#123; int n,x; in(n,x); int p=(1&lt;&lt;n); if(x&gt;=p)&#123; outln(p-1); for1(i,p-1)&#123; out(i^(i-1)); &#125; &#125;else&#123; p-=2; outln(p/2); v.pu_b(0); vis[x]=1; for1(i,p+1)&#123; if(vis[i]==0)&#123; v.pu_b(i); vis[i]=vis[i^x]=1; &#125; &#125; for1(i,(int)v.size()-1)&#123; out(v[i]^v[i-1]); &#125; &#125; return 0;&#125; title: CF-1174Emathjax: truedate: 2019-06-06 19:55:53tags: dp categories: cfEhab and the Expected GCD Problem题意定义 $f(p)$ 表示 一个排列 $p$ 的 $g_1,g_2 \cdots g_n$ 的种类数, $g_i$ 表示该排列前 $i $ 个数的 $gcd$ $f_{max}(n)$ 表示 $n$ 的排列的最大 $f$ 值 给 $n$ 求 $f(p)=f_{max}(n)$ 的方案数 题解显然 要让 $f$ 最大, 排列的第一个数为 $2^k$ 或 $2^{k-1}3$ , 设 $dp[i][x][t]$ 表示前 $i$ 个数的 $gcd$ 为 $\large 2^{x} 3^y$ 的方案数 dp[i][x][y]=dp[i-1][x][y]*max(f[x][y]-i+1,0)+\\dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])+dp[i-1][x][y+1]*(f[x][y]-f[x][y+1]$f[x][y]$ 表示 $\Large \lfloor \frac n {2^x*3^y}\rfloor$ , 答案为 $dp[n][0][0]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int dp[N][21][3];int n;int f[21][3];int pp[N];int main() &#123; in(n); ll pre=1; for1(i,N)&#123; pre=pre*i%mod; pp[i]=pre; &#125; for0(i,21) for0(j,3)&#123; f[i][j]=n/((1&lt;&lt;i)*pow(3,j)); &#125; if(n&lt;4)&#123; if(n==2)puts("1"); else if(n==3)puts("4"); return 0; &#125; int k=0,tn=n; while(tn)&#123; tn/=2; k++; &#125; k--; dp[1][k][0]=1; if((1&lt;&lt;(k-1))*3&lt;=n)dp[1][k-1][1]=1; itn i,cnt; for(i=2;i&lt;=n;i++)&#123; itn x,y; cnt=0; for0(j,k)&#123; x=j; y=0; dp[i][x][y]=(1ll*dp[i-1][x][y]*max(f[x][y]-i+1,0)%mod+1ll*dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])%mod+1ll*dp[i-1][x][y+1]*(f[x][y]-f[x][y+1])%mod)%mod; if(dp[i][x][y])cnt++; y=1; dp[i][x][y]=(1ll*dp[i-1][x][y]*max(f[x][y]-i+1,0)%mod+1ll*dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])%mod+1ll*dp[i-1][x][y+1]*(f[x][y]-f[x][y+1])%mod)%mod; if(dp[i][x][y])cnt++; &#125; if(dp[i][0][0]&amp;&amp;cnt==1)break; &#125; // outln(i); outln(1ll*dp[i][0][0]*pp[n-i]%mod); return 0;&#125; title: CF-1175Dmathjax: truedate: 2019-06-07 13:33:20tags: greedy categories: cfArray Splitting题意将一个长度为 $n$ 的序列 $a_i$ 顺序不变的分为非空的 $k$ 部分, 设 $f(i)$ 表示 $a_i$ 在第 $f(i)$ 部分 求 $\sum\limits_{i=1}^na_i*f(i)$ 题解在 $[1,n]$ 中选 $k$ 个点 $b_i$ (其中一个为 1)将序列分为 $k$ 份, 答案为 $\sum\limits_{i=1}^ksuf[i]$ , $suf[i]$ 表示从 $i$ 开始的后缀和 所以直接对后缀排序, 取最大的 $k$ 个 代码1234567891011121314151617181920int a[N];ll suf[N];bool cmp(ll x,ll y)&#123; return x&gt;y;&#125;int main() &#123; int n,k; in(n,k); for0(i,n)in(a[i]); for(itn i=n-1;i&gt;=0;i--)&#123; suf[i]=suf[i+1]+a[i]; &#125; sort(suf+1,suf+n,cmp); ll ans=0; for0(i,k)&#123; ans+=suf[i]; &#125; outln(ans); return 0;&#125; title: CF-1176Dmathjax: truedate: 2019-06-12 17:32:51tags: greedy sorting number theorycategories: cf 题意 题解排序, 从大到小处理, 若当前最大的为素数, 那它一定是 $b$, 若当前最大数为合数, 那它一定是 $a$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3e6;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int Div[N];int prime[N],num_prime=0;void get_prime()&#123; for(int i=2;i&lt;N;i++)&#123; if(!Div[i]) &#123; prime[num_prime++]=i; Div[i]=-num_prime; &#125; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;N;j++)&#123; int k = i*prime[j]; Div[k] = i; if(i % prime[j] == 0) break; &#125; &#125;&#125;itn n,a[400005],cnt[N];int main() &#123; get_prime(); in(n); for0(i,2*n)&#123; in(a[i]); cnt[a[i]]++; &#125; sort(a,a+2*n); for(int i=2*n-1;i&gt;=0;i--)&#123; if(cnt[a[i]])&#123; if(Div[a[i]]&gt;0)&#123; out(a[i]); cnt[a[i]]--; cnt[Div[a[i]]]--; &#125;else&#123; int tmp=-Div[a[i]]; out(tmp); cnt[tmp]--; cnt[a[i]]--; &#125; &#125; &#125; return 0;&#125; title: CF-1183Fmathjax: truedate: 2019-06-30 20:10:56tags: math categories: cf题意给 $n$ 个数，选至多 $3$ 个，且两两不为倍数关系，问最大值是多少 题解排序，若最大值不取 $a_n$，那只有一种可能 $\frac 1 2 a_n ,\frac 1 3 a_n,\frac 1 5 a_n $，因为如果最大值包含不为 a_n 的因子，那么显然取 a_n 更优。易证，若取 $a_n$ ，一定会取 不为 $a_n$ 因子的最大值， 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125; int a[N];unordered_set&lt;int&gt;s;int main() &#123; int q,n; in(q); while(q--)&#123; in(n); for0(i,n)&#123; in(a[i]); s.insert(a[i]); &#125; sort(a,a+n); n=unique(a,a+n)-a; int maxx=a[n-1]; int tmp=maxx; if(maxx%2==0&amp;&amp;maxx%3==0&amp;&amp;maxx%5==0&amp;&amp;s.count(maxx/2)&amp;&amp;s.count(maxx/3)&amp;&amp;s.count(maxx/5))&#123; maxx=maxx/30*31; &#125; for(int i=n-2;i&gt;=0;i--)&#123; if(tmp%a[i])&#123; for(int j=i-1;j&gt;=0;j--)&#123; if(tmp%a[j]&amp;&amp;a[i]%a[j])&#123; tmp+=a[j]; break; &#125; &#125; tmp+=a[i]; break; &#125; &#125; outln(max(maxx,tmp)); s.clear(); &#125; return 0;&#125; title: CF-1183Gmathjax: truedate: 2019-06-28 20:49:30tags: greedy categories: cfG. Candy Box (hard version)题意$q(1\le q\le 2e5)$ 次询问，每次询问$n(1\le n\le 2e5)$ 个物体，每个物体的种类为 $a_i(1\le a_i\le n)$，喜欢与否为 $f_i(0\le f_i\le1)$，要尽量取多的物体，要求每种物体的数量不同，在保证数量最多的情况下，要让喜欢的最少 题解按种类数排序，总数记为 $x_i$ ，$f=0$ 的数量为 $y_i$，从 $n-&gt;1$ 扫描，对于当前 $i$，将满足条件的 $y_i$ 加入优先队列 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;pii a[N];priority_queue&lt;int&gt;Q;int main() &#123; itn q,n,x,y; in(q); whiel(q--)&#123; in(n); for0(i,n)&#123; in(x,y); a[x].fi++; a[x].se+=y; &#125; sort(a+1,a+n+1); ll an1=0,an2=0; int id=n; for(itn i=n;i;i--)&#123; while(id&amp;&amp;a[id].fi&gt;=i)&#123; Q.push(a[id--].se); &#125; if(Q.size())&#123; an1+=i; an2+=min(i,Q.top()); Q.pop(); &#125; &#125; for1(i,n)a[i]=pii(0,0); whiel(Q.size())Q.pop(); out(an1); outln(an2); &#125; return 0;&#125; title: CF-1189Emathjax: truedate: 2019-07-06 14:03:37tags: number theory categories: cfE. Count Pairs题意You are given a prime number $p, n$ integers $a_{1}, a_{2}, \ldots, a_{n}(all a_i are different),$ and an integer $k$ Find the number of pairs of indexes $(i, j)(1 \leq i&lt;j \leq n)$ for which $\left(a_{i}+a_{j}\right)\left(a_{i}^{2}+a_{j}^{2}\right) \equiv k \bmod p$ 题解 (a_i-a_j)(a_i+a_j)(a_i^2+a_j^2)\equiv (a_i-a_j)k\ \bmod p\\ a_i^4-ka_i\equiv a_j^4-ka_j\bmod p代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125; unordered_map&lt;int,int&gt;m; int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,p,k; ll a; in(n,p,k); for0(i,n)&#123; in(a); a=((a*a%p*a%p*a%p-a*k%p)%p+p)%p; m[a]++; &#125; ll ans=0; for(auto i:m)&#123; ans+=1l*i.se*(i.se-1)/2; &#125; outln(ans); return 0;&#125; title: CF-1195Emathjax: truedate: 2019-07-29 17:00:01tags: two pointers data structurecategories: cf 题意给一个 $nm(1 \leq n, m \leq 3000)$ 的矩阵，求每一个 $ab$ 的子矩阵中最小值之和 题解先求出每一行长度为 $b$ 的序列的最小值，再求每一列长度为 $a$ 的序列的最小值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3.1e3;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125; int minn[N][N],h[N][N],q[N];// q[i]表示从 i 开始长度为 len 的序列中的最小值的下标ll ans;void fun(int x,int n,int a)&#123; int l=1,r=0; for1(i,n)&#123; whiel(i-q[l]+1&gt;a&amp;&amp;l&lt;=r)l++; while(h[x][q[r]]&gt;h[x][i]&amp;&amp;l&lt;=r)r--; q[++r]=i; // cout&lt;&lt;i&lt;&lt;' '&lt;&lt;l&lt;&lt;' '&lt;&lt;q[l]&lt;&lt;endl; minn[x][i]=h[x][q[l]]; &#125;&#125;void fun2(int x,int n,int a)&#123; int l=1,r=0; for(int i=1;i&lt;=n;i++)&#123; whiel(i-q[l]+1&gt;a&amp;&amp;l&lt;=r)l++; while(minn[q[r]][x]&gt;minn[i][x]&amp;&amp;l&lt;=r)r--; q[++r]=i; if(i&gt;=a) ans+=minn[q[l]][x]; // minn[x][i]=h[x][q[l]]; &#125;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,a,b,g,x,y,z; in(n,m,a,b); in(g,x,y,z); for0(i,n*m)&#123; h[i/m+1][i%m+1]=g; g=(1ll*g*x+y)%z; &#125; // for1(i,n)&#123; // for1(j,m)&#123; // out(h[i][j]); // &#125; // puts(""); // &#125; for1(i,n)&#123; fun(i,m,b); &#125; // for1(i,m)out(minn[1][i]); // puts(""); for(int i=b;i&lt;=m;i++)&#123; fun2(i,n,a); &#125; outln(ans); return 0;&#125; title: CF-1203Fmathjax: truedate: 2019-08-15 17:42:13tags: greedy dpcategories: cf 题意给两个序列 $a[],b$ ，你拥有的技能点为 $r(1\le r\le 3e4)$ ，只有当技能点 $\ge a_i$ 时，才可以做第 $i$ 份工作，技能点加上 $b_i$ 问他能否完成这 $n$ 份工作 如果不能，最多能完成几份 题解 显然，对于 $b_i\ge 0$ ，我们以 $a_i$ 排序；对于 $b_i&lt; 0$ ，我们以 $a_i+b_i$ 排序。因为对于 $x,y$ 两个工作，假设 $xa+xb&lt;ya+yb$ ，如果 $r+xb&lt;ya$ ，那么一定有 $r+yb&lt;ax$ 对于 $b_i\ge 0$ 容易求解；对于 $b_i&lt; 0$ ，使用 $dp$ 来求解，同样以 $a_i+b_i$ 排序，$dp[i][j]$ 表示前 $i$ 份工作剩余 $j$ 技能点的最大完成数。 代码12345678910111213141516171819202122232425262728293031323334353637int dp[N];vector&lt;pii&gt;q,w;bool cmp(pii x,pii y)&#123; retrun x.fi+x.se&gt;y.fi+y.se;&#125;int main() &#123; int n,r,a,b; in(n,r); for0(i,n)&#123; in(a,b); if(b&gt;=0)&#123; q.pu_b(pii(a,b)); &#125;else&#123; w.pu_b(pii(a,b)); &#125; &#125; sort(q.begin(),q.end()); sort(w.begin(),w.end(),cmp); int ans=0; for(auto i:q)&#123; if(r&gt;=i.fi)&#123; r+=i.se; ans++; &#125;else&#123; break; &#125; &#125; int maxx=0; for(auto i:w)&#123; for(int j=max(i.fi,-i.se);j&lt;=r;j++)&#123; dp[j+i.se]=max(dp[j]+1,dp[j+i.se]); maxx=max(dp[j+i.se],maxx); &#125; &#125; out(ans+maxx,1); return 0;&#125; title: CF-1207mathjax: truedate: 2019-08-29 20:28:00tags: data structure binary indexed tree dfs ac automationcategories: cf G. Indie Album题意有 $n$ 个字符串,对于第 $i$ 个字符串通过以下两种方式中的一个给出。 $1 c$，该字符串只含一个字符 $c$ 。 $2 x c$ ,该字符串为第 $x(1\le x&lt;i)$ 个字符串末尾添加一个字符 $c$ 得到。 有 $m$ 次询问，每次询问给出一个字符串 $s$ 和位置编号 $x$,问在上述第 $x$ 个字符串中，字符串 $s$ 出现了几次。 题解对询问构建 $AC$自动机，因为文本串是树形结构，我们可以跑一个 $dfs$ 枚举所有文本串，每次都添加一个字符，当回溯回去的时候删除这个字符对答案的贡献。 因为每个匹配串在文本串中出现的次数为将文本串在 $AC$自动机上跑一遍并将走到的位置权值 $+1$，该字符串所对应的 $fail$ 节点的子树权值和。所以我们拎出 $fail$ 树，对其 $dfs$ 序构造树状数组。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;ll inf =0x3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 4.1e5;/*-----------------------------------head----------------------------------------------*/ const int MAX = 26;int tot;vii failTree[N];struct Node &#123; int id; Node *Next[MAX]; Node *Fail; //失配指针,类似next数组,最大的next是和自身比较,fail是和其它匹配串比较 Node() &#123; memset(Next, 0, sizeof(Next)); Fail = 0; id=tot++; &#125;&#125; * root,*pp;int Insert(char s[]) &#123; Node *p = root; int len=strlen(s); for(int i=0;i&lt; len;i++) &#123; int c = s[i] - 'a'; if (p-&gt;Next[c] == NULL) &#123; Node *newnode = new Node; p-&gt;Next[c] = newnode; p = newnode; &#125; else p = p-&gt;Next[c]; &#125; return p-&gt;id;&#125;void BuildFail() &#123; queue&lt;Node *&gt; que; root-&gt;Fail=root; for(int i=0;i&lt;26;i++)&#123; if(root-&gt;Next[i])&#123; root-&gt;Next[i]-&gt;Fail=root; que.push(root-&gt;Next[i]); &#125;else root-&gt;Next[i]=root; &#125; while (!que.empty()) &#123; Node *p = que.front(); que.pop(); failTree[p-&gt;Fail-&gt;id].pu_b(p-&gt;id); for(int i=0;i&lt;26;i++)&#123; if(p-&gt;Next[i])&#123; p-&gt;Next[i]-&gt;Fail=p-&gt;Fail-&gt;Next[i]; que.push(p-&gt;Next[i]); &#125;else p-&gt;Next[i]=p-&gt;Fail-&gt;Next[i]; &#125; &#125;&#125;int L[N],R[N],cnt;void Dfs(int rt)&#123; L[rt]=cnt++; for(int v:failTree[rt])&#123; Dfs(v); &#125; R[rt]=cnt-1;&#125;int sum[N];void add(int p,int x,int n)&#123; //a[p]+=x,数组为[1,n] while(p&amp;&amp;p&lt;=n)sum[p]+=x,p+=p&amp;-p;&#125;ll query(int p)&#123; ll ans = 0; while(p)ans+=sum[p],p-=p&amp;-p; return ans;&#125;struct NODE&#123; char c; vector&lt;pii&gt; v;&#125;a[N]; vii node[N];char s[N];int ans[N];void dfs(int rt)&#123; for(int v:node[rt])&#123; Node *tmp=pp; pp = pp-&gt;Next[c-'a']; add(L[pp-&gt;id],1,cnt-1); for(auto i:a[v].v)ans[i.se]=query(R[i.fi])-query(L[i.fi]-1); dfs(v); add(L[pp-&gt;id],-1,cnt-1); pp=tmp; &#125;&#125;int main() &#123; int n,m,tp,v; root = new Node; pp=root; in(n); for1(i,n)&#123; in(tp); if(tp==1)&#123; in(s); node[0].pu_b(i); &#125;else&#123; in(v);in(s); node[v].pu_b(i); &#125; a[i].c=s[0]; &#125; in(m); for1(i,m)&#123; in(v);in(s); a[v].v.pu_b(pii(Insert(s),i)); &#125; BuildFail(); Dfs(0); dfs(0); for1(i,m)out(ans[i],1); return 0;&#125; title: CF-1208mathjax: truedate: 2019-08-27 20:23:53tags: constructive categories: cfC. Magic Grid题意给一个 $n(n\%4=0)$ ，将 $0\sim n^2-1$ 填入 $n\times n$ 的矩阵里，使得每行每列的异或和相同。 题解 \begin{matrix} 0 & 1 & 2&3 \\ 4 & 5 & 6 &7\\ 8 & 9&10 &11\\ 12 & 13&14 &15\\ \end{matrix}因为 $n$ 是 $4$ 的倍数，将这个 $4\times4$ 的矩阵看作一个整体来填充矩阵即可，以为这个矩阵每个元素加上 $16k$ 不会影响结果 title: CF-1215Emathjax: truedate: 2019-09-18 15:37:30tags: dp categories: cf题意 $n(2\le n\le 4e5)$ 个物品，每个的颜色为 $a_i(1\le a_i\le 20)$ ，仅允许将相邻的物品两两交换，问使得相同颜色的物品聚集到一起的最小花费 题解预处理 $tran[i][j]$ 表示仅考虑颜色 $i,j$ 时，将所有颜色为 $i$ 的物品移到所有颜色为 $j$ 的物品前面的花费，然后再使用状压 $dp$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sz(a))#define mem_1(a) memset(a, -1, sz(a))#define mem0(a) memset(a, 0, sz(a))#define memcp(a,b) memcpy(a,b,sz(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define sz(a) (int)sizeof(a)typedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内 int inf = 0x3f3f3f3f;ll inf_ll = 0x3f3f3f3f3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e5;/*-----------------------------------head----------------------------------------------*/ll tran[30][30];vii node[30];ll dp[1&lt;&lt;20];int main() &#123; int n,x; in(n); for1(i,n)&#123; in(x); node[x-1].pu_b(i); &#125; meminf(dp); dp[0]=0; for0(i,20) for0(j,20)&#123; if(i==j)continue; int l=node[i].size(),r=node[j].size(); while(l&amp;&amp;r)&#123; if(node[i][l-1]&lt;node[j][r-1])&#123; r--; &#125;else&#123; tran[i][j]+=r; l--; &#125; &#125; &#125; for(int i=1;i&lt;(1&lt;&lt;20);i++)&#123; for0(j,20)&#123; if(i&amp;(1&lt;&lt;j))&#123; ll sum=0; for0(k,20)&#123; if(i&amp;(1&lt;&lt;k))sum+=tran[j][k]; &#125; dp[i]=min(dp[i],dp[i-(1&lt;&lt;j)]+sum); &#125; &#125; &#125; out(dp[(1&lt;&lt;20)-1],1); return 0;&#125; title: CF-675mathjax: falsedate: 2019-03-22 10:25:05tags: greedy data structurecategories: cf C. Money Transfers题意有n家银行围成一个圈，有个人在有些银行里欠了钱，在一些银行里有存钱，欠的钱总数等于存的钱总数。现在可以有操作，如果两个银行相邻，那么就能在一个银行转任意多的钱到另一个银行。问最少的操作次数，使得在所有银行的存款钱数都为0。 题解首先我们要发现第一个贪心。如果有一段子串，里面的数字之和等于0，那么在这段子串中移动数字，所需要的代价为子串长度len-1，那么问题就转换成了，我们在这个圈中能找到多少段子串，里面的数字之和等于0，而且段数越多越好，记为k，那么很明显，答案就是n-k，现在问题来了，如何来求满足题意的最大的k。首先，我们考虑用前缀和来存放，如果遇到两个位置，前缀和相等，那么中间那一段数字之和肯定等于0。接下来就是一个跳跃性的思考了，那么如果某个前缀和的值出现了k次，是不是就是我们上述的k呢？答案是正确的！假如有k个位置的前缀和相等，那么中间k-1段子串内数字之和一定都是0，由于总数是0，那么最前面和最后面连着的那一段也肯定是0，所以，我们记录所有的前缀和的值，然后排序。然后用取尺法记录一个数出现的最多次数，就做完了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;strstream&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define MOD 1000000007#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int n,maxx=1,tmp; ll pre=0; map&lt;ll,int&gt;log; cin&gt;&gt;n; for0(i, n)&#123; cin&gt;&gt;tmp; pre+=tmp; if (log.count(pre)) &#123; log[pre]++; maxx=max(maxx, log[pre]); &#125;else log[pre]=1; &#125; cout&lt;&lt;n-maxx&lt;&lt;endl; return 0;&#125; title: CF-883mathjax: truedate: 2019-03-27 20:14:29tags: dp binary searchcategories: cf I. Photo Processing题意将 n 个数分堆，要保证每堆不少于 k 个数，每堆的值为这堆数中的最大值减去最小值，取这些值中的最大值，要是这个最大值最小。 题解二分答案，$dp$ 判断是否可行。$dp[i]$ 表示将 $1\sim i$ 划分成满足条件的区间，能划分最远的地方。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],n,k,dp[N];bool check(int x)&#123; int last=0; forl(i,k,n)&#123; int j=dp[i-k]; if(a[i]-a[j+1]&lt;=x)last=i; dp[i]=last; &#125; return dp[n]==n;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(n,k); for1(i,n)in(a[i]); sort(a+1,a+1+n); int l=0,r=1e9,mid; while(l&lt;=r)&#123; mid=(l+r)/2; if(check(mid))r=mid-1; else l=mid+1; &#125; printf("%d\n",l); return 0;&#125; title: HDU-1024 Max Sum Plus Plusdate: 2019-03-21 23:01:40tags: dpcategories: hdu mathjax: true题意给你一个序列n个数组成，然后让你在里面找到m个子序列，让这m个子序列的和最大。 题解$dp[i][j]$表示的是第j个数字在第i个子序列时的当前最优值。$dp[i][j] = maxx(dp[i][j-1] + num[j] ,maxx(dp[i-1][k]) + num[j])$，k是从1到 $j-1$.可以这么理解这个转移方程，对于当前的这个数字，如果把他放到第i个子序列中有两种情况，一个是他作为第i个子序列的第一个数字，另一个就是不作为第一个数字，作为第一个数字的时候是 $max(dp[i-2][k] + num[j]) ,1&lt;=k&lt;i $的意思是从之前的所有中找到 $i-1$ 个子序列的最大值+当前的值，不做为第一个的时候那么他前面的那个数字一定是i序列的，同一个子序列，又不是作为第一个，那么前面的那个货就一定是同一个子序列的，那么当前的值是$dp[i][j-1] + num[j]$,在两种决策中选择一个最有的就行了，还有就是$max(dp[i-1][k]+num[j])$的这个地方可以开一个数组记录下来，不能每次都跑，跑不起，再有就是这个题目没有给m的范围，所以开不了二维数组（目测不是很大，大的话会超时，但是肯定是先超内存在超时，所以为了保险，还是吧$dp[][]$压缩成一维的）那么状态转移就边成这样了$dp[j]$表示的是 j这个人在当前的这个子序列中的最优值，mk[j]表示的是在上一个子序列中1—j的dp的最大值，所以就变成 $dp[j] = maxx(dp[j-1] + num[j] ,mk[j-1]+num[j])$;还是 max(作为i个子序列的第一个元素，不是第一个元素取一个最大值)。在解释下代码的核心部分。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;ctime&gt;#include &lt;strstream&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int d[1000006],a[1000006],pre_max[2][1000006];int main()&#123; int n,m; while (cin&gt;&gt;m&gt;&gt;n) &#123; memset(d, 0, sizeof(d)); memset(pre_max, 0, sizeof(pre_max)); for (int i=1; i&lt;=n; i++) scanf("%d",&amp;a[i]); int maxx; //pre_max[0][0]=-99999999;pre_max[1][0]=-99999999; for (int i=1; i&lt;=m; i++) &#123; maxx=-9999999; for (int j=i; j&lt;=n; j++) &#123; d[j]=max(d[j-1]+a[j], pre_max[(i+1)%2][j-1]+a[j]); maxx=max(maxx, d[j]); pre_max[i%2][j]=maxx; &#125; &#125; cout&lt;&lt;pre_max[m%2][n]&lt;&lt;endl; &#125; return 0;&#125; title: HDU-4055 Number Stringmathjax: truedate: 2019-03-22 11:02:29tags: dp categories: hdu题意给你一个字符串s，s[i] = ‘D’表示排列中a[i] &gt; a[i+1]，s[i] = ‘I’表示排列中a[i] &lt; a[i+1]。 比如排列 {3, 1, 2, 7, 4, 6, 5} 表示为字符串 DIIDID。 题解很巧妙的DP做法，$dp[i][j]$表示前i个满足字符串条件的结尾为j的 i 的排列，注意是i的排列，前面并没有数大于i。那又是如何往下递推呢？ 如果s[i - 1]是’ I ‘，那么$dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + .. + dp[i-1][1]$如果s[i - 1]是‘D’，那么$dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + … + dp[i-1][i]$，因为要令当前位为j，如果前面出现过j，就令前面的所有大于等于j的数+1，就能构造出新的排列了。 比如{1, 3, 5, 2, 4}，要在第六位插入3,令 &gt;= 3的数都+1，于是就构造出新的 排列{1, 4, 6, 2, 5, 3}。然后代码的话处理出前缀和$sum[i][j]$，就不用$dp[i][j]$了。 代码123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;typedef __int64 ll; const int maxn = 1000 + 5;const int mod = 1000000007; ll sum[maxn][maxn];char s[maxn]; int main() &#123; while(scanf("%s", s) != -1) &#123; int len = strlen(s); sum[0][1] = 1; for(int i = 1;i &lt;= len; i++) &#123; for(int j = 1;j &lt;= i+1; j++) &#123; sum[i][j] = sum[i][j-1]; if(s[i-1] != 'D') sum[i][j] += sum[i-1][j-1]; if(s[i-1] != 'I') sum[i][j] += sum[i-1][i] - sum[i-1][j-1] + mod; sum[i][j] %= mod; &#125; &#125; printf("%I64d\n", sum[len][len+1]); &#125; return 0;&#125; 引用https://blog.csdn.net/jayye1994/article/details/12361481---title: HDU-4651mathjax: truedate: 2019-03-22 11:19:37tags: math categories: hdu题意整数拆分，$(1\le n\le 10^5)$ 题解使用五边形定理 P(n)=\sum\limits_{k=1}^n(-1)^{k+1}\left [P\left( n-\frac 1 2k(3k-1)\right)+P\left( n-\frac 1 2k(3k+1)\right )\right ]其中n-\frac 1 2k(3k-1)>=0 , n-\frac 1 2k(3k+1)>=0 ，注意两个条件要分开判断，有大于0的就加上相应的f，不是两个同时成立或者不成立 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(1.1e5)using namespace std;int p[N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); p[0]=1; for1(i,100005)&#123; ll fl=1,an=0,flag=1; while(1)&#123; ll tmp=fl*(3*fl-1)/2; if(i-tmp&lt;0)break; an=(an+flag*p[i-tmp]+mod)%mod; tmp=fl*(3*fl+1)/2; if(i-tmp&lt;0)break; an=(an+flag*p[i-tmp]+mod)%mod; fl++; flag*=-1; &#125; p[i]=an; // printf("%d\n",tmp); &#125; int t,n; ind(t); while(t--)&#123; ind(n); printf("%d\n",p[n]); &#125; return 0;&#125; title: HDU-5970 最大公约数mathjax: truedate: 2019-03-22 10:15:43tags: math categories: hdu题意给一个函数 12345678910int f(int x,int y)&#123; int c=0; while(y&gt;0)&#123; c++; t=x%y; x=y; y=t; &#125; return c*x*x;&#125; 给出n,m,p，求$\Large\sum\limits_{i=1}^n\sum\limits_{j=1}^m\lfloor\frac {i*j} {f(i,j)}\rfloor$ 题解 ans=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{i+j*k\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor\\=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*(k+p*c))} {c*x*x}\rfloor\\ =\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor+\frac {p*j*j} {x*x}代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)using namespace std;#define mod (int)(1e9 + 7)#define N (int)(1.1e5)int f[700][700], c[700][700];void fun(int x, int y) &#123; int b = 0, i = x, j = y; while (y) &#123; b++; int tmp = x % y; x = y; y = tmp; &#125; c[i][j] = b; f[i][j] = b * x * x;&#125;int main() &#123;#ifndef ONLINE_JUDGE //freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif for1(i, 666) for1(j, 666) fun(i, j); int t; ind(t); while (t--) &#123; int n, m, p; ll ans = 0; scanf("%d%d%d", &amp;n, &amp;m, &amp;p); for1(j, m) &#123; for (int i = 1; i &lt;= j &amp;&amp; i &lt;= n; i++) &#123; int k = (n - i) / j; int tt = c[i][j] * j * j / f[i][j]; for (int q = 0; q &lt; c[i][j]&amp;&amp;q&lt;=k ; q++) &#123; //if (i + q * j &gt; n) break; //ll t = (n - (i + j * q)) / (c[i][j] * j) + 1; ll t=(k-q)/c[i][j]+1; ll tmp=(i+j*q)*j/f[i][j]; ans=(ans+tmp*t%p+(t-1)*t/2%p*tt%p)%p; // ll b = (i + j * q) * j / f[i][j]; // ans = (ans + b * t % p + (t - 1) * t / 2 % p * tt % p) % p; &#125; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125; title: HDU-6189mathjax: truedate: 2019-06-12 21:44:21tags: math categories: hdu题意给出 $n(\le 30), a(1\le a\le 1e9)$ , 求在 $[1,2^n]$ 范围内有多少个 $b$ 能够满足 $a^{b} \equiv b^{a}(\bmod 2^n)$ 题解 https://blog.csdn.net/hyesuixin/article/details/77855821 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; int n,a; whiel(~in(n,a))&#123; int ta=a,k=0,maxn=1&lt;&lt;n; whiel(ta%2==0)&#123; k++; ta/=2; &#125; if(k&amp;&amp;n)&#123; itn kk=n/a; if(n%a)kk++; int ans=0; int low=n/k; if(n%k==0)low--; for1(i,low)&#123; if(qPow(a,i,maxn)==qPow(i,a,maxn))ans++; &#125; kk=1&lt;&lt;kk; ans+=(1&lt;&lt;n)/kk-low/kk; outln(ans); &#125;else &#123; puts("1"); &#125; &#125; return 0;&#125; title: HDU-6223mathjax: truedate: 2019-06-18 15:25:19tags: greedy categories: hdu题意长度为 $n(1\le n \le 2e6)$ 的数组 $(0\le a_i\le 9)$, 下标为 $[0,n-1]$ , 你要取 $n$ 个数构成一个长度为 $n$ 的数组 $b$ , 假设第一次选 $a[i]$ , 则 $b[1]=a[i], b[2]=a[(i^2+1)\%n],\cdots$ 输出字典序最小的 $b$ 题解显然取的下标序列存在循环节, 由打表可知, 循环节的长度不会超过 $21$, 所以我们只用枚举前 $21*20$ (循环节的最大$lcm$)位就可以找到保证 $b$ 字典序最小的起始点, 好像数据太水了,只用枚举前 21​ 位就可以了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.6e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;char s[N],ans[N];int main() &#123; int t,n; in(t); for1(ca,t)&#123; in(n); in(s); printf("Case #%d: ",ca); ll loo; for0(i,n)ans[i]='0'; for0(i,n)&#123; bool yes=0; ll ti=i; for0(j,22)&#123; if(s[ti]&lt;ans[j])&#123; if(yes)ans[j]=s[ti]; else break; &#125;else if(s[ti]&gt;ans[j])&#123; yes=1; ans[j]=s[ti]; &#125; ti=(ti*ti+1)%n; &#125; if(yes)loo=i; &#125; for0(i,n)&#123; putchar(s[loo]); loo=(loo*loo+1)%n; &#125; puts(""); &#125; return 0;&#125; title: HDU-6284mathjax: truedate: 2019-06-04 21:22:51tags: dp categories: hduLongest Increasing Subsequence题意有一个长度为 $n$ 的数组 $a(0\le a_i\le n)$ ,$f(x)$ 表示把 $0$ 变成 $x$ , 序列的 $LIS(严格递增)$ , 求$\sum\limits_{i=1}^ni\times f(i)$ 题解设 $bg[i], en[i]$ 分别表⽰以点 $i$ 开始、结束的 $LIS$ ⻓度，$L$ 是原来的 $LIS$ ⻓度。对于每个 $i$，找出它下⼀个 $0$ 后⾯的 $a[j]$ 满⾜ $en[i]+bg[j] = L$，那么当 $x$ 在 $[a[i] + 1, a[j] − 1]$ 的区间内时，答案是 $L + 1$. 从后往前扫, 用一个数组 $\text{max_r[i]}$ 记录扫过的最后一个 $0$ 右边区域的 $bg=i$ 的最大值 以 $0$ 为分隔, 用一个 $vector$ 存当前分块的 $ \text{max_r}$ 值, 当遇到下一个 $0$ 的时候更新 $\text{max_r}$ , 注意当 $bg=L$ 时要特殊考虑 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const int inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],bg[N],en[N],dp[N],fu[N],max_r[N];vector&lt;pii&gt; peding;int l_bound(int l,int r,int x)&#123; r--; whiel(l&lt;=r)&#123; int mid=(l+r)/2; if(dp[mid]&gt;x)l=mid+1; else r=mid-1; &#125; return l;&#125;int main() &#123; itn n; whiel(~in(n))&#123; int L=0; for1(i,n)in(a[i]); for1(i,n)max_r[i]=fu[i]=0; for1(i,n)&#123; if(a[i])&#123; if(L)&#123; if(a[i]&gt;dp[L-1])&#123; dp[L++]=a[i]; en[i]=L; &#125;else&#123; int p=lower_bound(dp,dp+L,a[i])-dp; dp[p]=min(dp[p],a[i]); en[i]=p+1; &#125; &#125;else&#123; dp[L++]=a[i]; en[i]=L; &#125; &#125; &#125; L=max(L,1); ll ans=(1ll+n)*n/2*L; L=0; for(itn i=n;i&gt;0;i--)&#123; if(a[i])&#123; if(L)&#123; if(a[i]&lt;dp[L-1])&#123; dp[L++]=a[i]; bg[i]=L; &#125;else&#123; int p=l_bound(0,L,a[i]); dp[p]=max(dp[p],a[i]); bg[i]=p+1; &#125; &#125;else&#123; dp[L++]=a[i]; bg[i]=L; &#125; &#125; &#125; max_r[0]=0; peding.clear(); for(itn i=n;i&gt;0;i--)&#123; if(a[i])&#123; if(max_r[L-en[i]]&gt;a[i])&#123; fu[a[i]+1]++; fu[max_r[L-en[i]]]--; &#125; peding.pu_b(pii(bg[i],a[i])); &#125;else&#123; max_r[0]=n+1; whiel(peding.size())&#123; pii kk=peding.back(); peding.po_b(); if(kk.fi==L)&#123; fu[1]++; fu[kk.se]--; &#125;else&#123; max_r[kk.fi]=max(max_r[kk.fi],kk.se); &#125; &#125; &#125; &#125; for1(i,n)&#123; fu[i]+=fu[i-1]; if(fu[i])ans+=i; &#125; outln(ans); &#125; return 0;&#125; title: HDU-6285mathjax: truedate: 2019-06-03 17:40:22tags: graph combinationcategories: hdu 题意在一个 $n$ 个点的完全图中，第 $i$ 个点的权值为 $2^i$，选择一些边，需要选择一些点使得所有边至少有一个端点被覆盖，同时权值之和最小。在上述情况下，给出选择的点的权值和，问有多少种选择边的方案符合这种选点。 题解对于每一个选定的点, 总有一条边连着它和权值比它大的未被选的点, 设数量为 $cnt1$, 权值比它小的点可取可不取, 设数量为 $cnt2$, 则该点的贡献为 (2^{cnt1}-1)\times2^{cnt2}代码12345678910111213141516171819202122232425262728293031323334353637string s;ll f[N];ll fun(int a,int b)&#123; ll qq=(f[a]-1+mod)%mod; return qq*f[b]%mod;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,a,b; f[0]=1; for1(i,100005)&#123; f[i]=f[i-1]*2%mod; &#125; while(cin&gt;&gt;n&gt;&gt;s)&#123; a=b=0; ll ans=1; for(int i=0;i&lt;s.size();i++)&#123; if(s[i]=='1')a++; &#125; n-=s.size(); for(int i=s.size()-1,j=0;i&gt;=0;i--,j++)&#123; if(s[i]=='1')&#123; b++; ans=fun(n+i-a+b,j)*ans%mod; // cout&lt;&lt;n+i-a+b&lt;&lt;' '&lt;&lt;j&lt;&lt;endl; &#125; &#125; outln(ans); &#125; return 0;&#125; title: HDU-6592mathjax: truedate: 2019-08-07 08:38:22tags: greedy dpcategories: hdu 题意给一个序列 $a[]$ ，找出最长的单峰序列，输出该序列的下标，输出字典序最大和最小的情况 题解易证，当取第一个峰的时候字典序最小，当取最后一个峰的时候字典序最大。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3.1e5;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],f[N],g[N],pre[N],ans[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; while(~in(n))&#123; for1(i,n)in(a[i]); int len=0; for1(i,n)&#123; int posi=upper_bound(pre+1,pre+1+len,a[i])-pre; // out(posi); if(posi==len+1)&#123; if(a[i]&gt;pre[len])&#123; pre[++len]=a[i]; f[i]=len; &#125;else f[i]=len; &#125;else&#123; if(a[i]&gt;pre[posi-1])&#123; pre[posi]=a[i]; f[i]=posi; &#125;else&#123; f[i]=posi-1; &#125; &#125; &#125; // puts(""/); len=0; for1(i,n)&#123; int j=n-i+1; int posi=upper_bound(pre+1,pre+1+len,a[j])-pre; if(posi==len+1)&#123; if(a[j]&gt;pre[len])&#123; pre[++len]=a[j]; g[j]=len; &#125;else g[j]=len; &#125;else&#123; if(a[j]&gt;pre[posi-1])&#123; pre[posi]=a[j]; g[j]=posi; &#125;else&#123; g[j]=posi-1; &#125; &#125; &#125; int maxx=0,Fi=0,La=0; for1(i,n)maxx=max(maxx,f[i]+g[i]-1); for1(i,n)&#123; if(f[i]+g[i]-1==maxx)&#123; if(!Fi)Fi=i; La=i; &#125; &#125; int tail=f[Fi]; ans[tail]=Fi; for(int i=Fi-1;i&gt;0;i--)&#123; if(f[i]+1&gt;=tail&amp;&amp;f[i]&lt;f[Fi])&#123; if(a[ans[f[i]+1]]&gt;a[i])&#123; tail=f[i]; ans[f[i]]=i; &#125; &#125; &#125; // assert(tail==1); tail=f[Fi]; // cout&lt;&lt;tail&lt;&lt;endl; for(int i=Fi+1;i&lt;=n;i++)&#123; if(a[i]&lt;a[ans[tail]]&amp;&amp;g[i]+1==g[ans[tail]])&#123; ans[++tail]=i; &#125; &#125; for1(i,maxx)&#123; printf("%d%c",ans[i]," \n"[i==maxx]); &#125; tail=maxx-g[La]+1; ans[tail]=La; for(int i=La+1;i&lt;=n;i++)&#123; if(g[i]+tail&gt;=maxx&amp;&amp;g[i]&lt;g[La])&#123; if(a[ans[maxx-g[i]]]&gt;a[i])&#123; tail=maxx-g[i]+1; ans[tail]=i; &#125; &#125; &#125; // assert(tail==maxx); tail=maxx-g[La]+1; for(int i=La-1;i&gt;0;i--)&#123; if(a[i]&lt;a[ans[tail]]&amp;&amp;f[i]+1==f[ans[tail]])&#123; ans[--tail]=i; &#125; &#125; for1(i,maxx)&#123; printf("%d%c",ans[i]," \n"[i==maxx]); &#125; &#125; return 0;&#125; title: HDU-6635mathjax: truedate: 2019-08-08 18:08:18tags: dp 期望categories: hdu 题意给两个排列 $a , b$ ，$a$ 一开始全都封闭，从左到右遍历 $b$ ，每次释放一个 $\Large a_{b_i}$ ，问每个时刻，释放后的序列 $a$ 的 $LIS$ 题解考虑时间倒流， 看作一个完整的排列按照一定顺序依次删除每个数， 然后每次需要计算 $LIS$ 的长度。 首先在 $O(n log n) $ 的时间内求出 $LIS$，并找到任意一个 $LIS$。当删除 x 时，如果 x 不在之前找 到的那个 LIS 中，那么显然 LIS 的长度是不会变化的，否则暴力重新计算出新的 LIS 即可。因为数据随机，因此 LIS 的期望长度是 $O( \sqrt n)$，删除的 x 位于 LIS 中的概率是 $\frac 1 {\sqrt n}$ ，也就是说期望时间复杂度为$O(n \sqrt n log n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e4;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],pre[N],b[N],ans[N],cnt,n,pp[N],pr[N];bool vis[N],cho[N];void redo()&#123; cnt=0; mem0(cho); int last=0; for1(i,n)&#123; if(!vis[i])&#123; int posi=upper_bound(pre+1,pre+1+cnt,a[i])-pre; // printf("sa%d %d\n",i,a[i]); if(posi==cnt+1)&#123; pre[++cnt]=a[i]; pr[cnt]=i; pp[i]=pr[cnt-1]; last=i; // printf("sa%d\n",i); // sta[cnt].push(i); &#125;else &#123; pre[posi]=a[i]; pr[posi]=i; pp[i]=pr[posi-1]; // no[i]=posi; // sta[posi].push(i); &#125; &#125; &#125; while(last)&#123; cho[last]=1; // out(last); last=pp[last]; &#125; // puts("");&#125;void del(int x)&#123; vis[x]=1; if(cho[x])redo();&#125;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; in(t); whiel(t--)&#123; in(n); mem0(vis); for1(i,n)in(a[i]); for1(i,n)in(b[i]); redo(); for(int i=n;i&gt;0;i--)&#123; ans[i]=cnt; del(b[i]); &#125; for1(i,n)&#123; if(i==n)outln(ans[i]); else out(ans[i]); &#125; &#125; return 0;&#125; title: LightOJ-1197 Help Hanzomathjax: falsedate: 2019-03-22 11:00:23tags: math categories: lightoj题意求a~b间素数个数(1 ≤ a ≤ b &lt; 2^31, b - a ≤ 100000). 题解b-a这个区间比较小，所以可以用区间素数筛选的办法解决这个题目。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem1(a) memset(a, 1 , sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;const int N=100005;bool a[N+1];vector&lt;int&gt; prime;void getPrime()&#123; memset(a,true,sizeof(a)); for(int i=2;i&lt;=N;i++)&#123; if(a[i]) prime.push_back(i); for(int j=0;j&lt;(int)prime.size()&amp;&amp;i*prime[j]&lt;=N;j++)&#123; a[i*prime[j]]=false; if(!(i%prime[j])) break; &#125; &#125;&#125;int main()&#123; //ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); //freopen("in.txt", "r", stdin); ll t,a,b; bool isprime[100005]; getPrime(); //cout&lt;&lt;prime.size(); cin&gt;&gt;t; for1(k,t)&#123; int ans=0; cin&gt;&gt;a&gt;&gt;b; mem1(isprime); for(int i=0;prime[i]*prime[i]&lt;=b&amp;&amp;i&lt;(int)prime.size();i++)&#123; ll l=a/prime[i]; if (l*prime[i]&lt;a) l++; if (l&lt;2) l=2; for (; l*prime[i]&lt;=b; l++) isprime[l*prime[i]-a]=0; &#125; if (a==1) isprime[0]=0; for0(i,b-a+1) if (isprime[i])ans++; printf("Case %d: %d\n",k,ans ); &#125; return 0;&#125; title: POJ-1050 To the Maxmathjax: falsedate: 2019-03-21 23:07:02tags: data structure categories: poj题意求最大子矩阵和。 题解枚举列区间，将该区间的值压缩到一起，转化成求一维最大字段。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;vector&gt;#define ll long long#define inf 0x3f3f3f3f#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main() &#123; ios::sync_with_stdio(false); int n, a[101][101],b[101][101]; cin &gt;&gt; n; mem0(b); for0(i, n) &#123; for0(j, n)&#123; cin&gt;&gt;a[i][j]; b[i][j+1]=b[i][j]+a[i][j]; &#125; &#125; int ans=0; for0(i, n) forl(j, i+1, n)&#123; int tmp=0; for0(k, n)&#123; tmp+=b[k][j]-b[k][i]; if (tmp&lt;0) &#123; tmp=0; &#125;else if(tmp&gt;ans)&#123; ans=tmp; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; title: POJ-2559 Largest Rectangle in a Histogramdate: 2019-03-21 22:42:01tags: data structurecategories: pojmathjax: false 题意 求柱形图中的最大矩形面积。 题解法一: 求每个点左边连续比它大的最左边的下标，保存在 $l[]$ 数组里,求每个点右边连续比它大的最右边的下标，保存在 $r[]$ 数组里 法二: 维护一个单调栈, 如果 $h$ 大于栈顶元素，则入栈, 否则，将栈内元素出栈，直到满足上面的条件。出栈时，我们要将出栈元素对之后问题的影响全部考虑进行处理，才能保证做法的正确性。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;ctime&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int n,tmp; while (cin&gt;&gt;n&amp;&amp;n) &#123; ll ans=0; vector&lt;pair&lt;int, int&gt; &gt;sta;//点的权值 权值大于等于该点的数量 for0(i, n)&#123; cin&gt;&gt;tmp; int count=0; forn(i, sta.size()-1)&#123; if (sta[i].first&gt;tmp) &#123; count+=sta[i].second; ans=max(ans, (ll)sta[i].first*count); sta.pop_back(); &#125;else break; &#125; sta.push_back(pair&lt;int, int&gt;(tmp,count+1)); &#125; int count=0; forn(i, sta.size()-1)&#123; count+=sta[i].second; ans=max(ans, (ll)sta[i].first*count); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; title: POJ-3167 Cow Patternsmathjax: truedate: 2019-03-22 10:28:52tags: data structure stringcategories: poj 题意一个农场主有 N 头牛，每个牛都以它身上的斑点数作为标志，以斑点数作为标准对牛进行 rank 排序，定义牛的序列的相同性为第 i 头牛及其之前的牛的比他 rank 小的数量和与他 rank 相同的数量，比如：1 4 4 3 2 1 和 2 10 10 7 3 2 是一样的模式串要求数有多少个符合要求的模式串，并输出每个符合要求的子串的起始位置。 题解定义一个函数 $getval(ch,str,l,r)$，返回的值为 $ch$ 在 $str[l~r]$ 中的真实值，即将 $str[l~r]$ 中的值排序离散化后 $ch$ 的值。则题意即为：在a串中找出一段长为m的区间[l,r]，使对任意的1≤i≤m，getval(a[l+i-1],a,l,r)均等于getval(b[i],b,1,m)getval的值，其实是返回某个数(数跟字符其实是一样的)在某堆数中的排名。是什么决定了一个数x的排名？是小于x的数的个数，等于x的数的个数。如果这两个个数与另一个y的两个个数都相等，那么x跟y在各自字符串的各自区间内的getval值就相等了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))n#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(1.1e5)using namespace std;int Next[N],sump[N][30],now[30],sums[N][30],n,k;vector&lt;int&gt;ans;bool check(int l,int r,int sump[][30],int sums[][30],int *p,int*s)&#123; int lep=0,les=0; for1(i,p[l]-1)lep+=sump[l][i]; for1(i,s[r]-1)les+=sums[r][i]-sums[r-l][i]; if(lep==les&amp;&amp;sump[l][p[l]]==sums[r][s[r]]-sums[r-l][s[r]])return 1; else return 0;&#125;void kmp_pre(int *p, int p_len, int Next[]) &#123; // Next[i] 为满足 p[i-z...i-1]=p[0...z-1] 的最大 z 值(就是 p的自身匹配) int i = 0, j = Next[0] = -1; while (i &lt; p_len) &#123; while (j != -1 &amp;&amp; !check(j,i,sump,sump,p,p)) j = Next[j]; Next[++i] = ++j; &#125;&#125;void KMP(int *p, int *s) &#123; // p 是模式串，s 是主串 int i = 0, j = 0, p_len = k, s_len =n; for1(i,p_len)&#123; memcpy(sump[i],sump[i-1],30*sizeof(int)); sump[i][p[i-1]]++; &#125; for1(i,s_len)&#123; memcpy(sums[i],sums[i-1],sizeof(sums[i])); sums[i][s[i-1]]++; &#125; kmp_pre(p, p_len, Next); while (i &lt; s_len) &#123; while (-1 != j &amp;&amp; !check(j,i,sump,sums,p,s)) j = Next[j]; i++;j++; if (j &gt;= p_len) &#123; ans.push_back(i); j = Next[j]; &#125; &#125;&#125;int p[N],S[N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int q; scanf("%d%d%d",&amp;n,&amp;k,&amp;q); for0(i,n)ind(S[i]); for0(i,k)ind(p[i]); KMP(p,S); //puts(""); printf("%d\n",(int)ans.size()); for0(i,ans.size())printf("%d\n",ans[i]-k+1); return 0;&#125; title: 农场阳光mathjax: falsedate: 2019-04-23 14:30:14tags: geometry categories: 蓝桥杯题意求多个圆和一个矩形的面积并 题解使用自适应 Simpson 求解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;db g;int n,a,b;struct circle&#123; db x,y,r; circle()&#123;&#125; circle(int a,int b,int c,int d)&#123; x=a+c/tan(g); y=b; r=d; &#125;&#125;cir_set[N];struct seg&#123; db top,bottom; seg()&#123;&#125; seg(db a,db b)&#123; top=a; bottom=b; &#125;&#125;;bool cmp(seg x,seg y)&#123; return x.bottom&lt;y.bottom;&#125;db F(db x)&#123; vector&lt;seg&gt;v; for0(i,n)&#123; circle ci=cir_set[i]; if(fabs(x-ci.x)&lt;ci.r)&#123; db h=sqrt(ci.r*ci.r-(x-ci.x)*(x-ci.x)); v.pb(seg(ci.y+h,ci.y-h)); &#125; &#125; if(v.size()==0)return b; v.pb(seg(0,b)); sort(v.begin(),v.end(),cmp); db sta=0,ans=0; for0(i,v.size())&#123; seg se=v[i]; if(se.bottom&gt;sta)&#123; ans+=se.bottom-sta; &#125; sta=max(sta,se.top); if(sta&gt;=b)break; &#125; return ans;&#125;// 2db calc(db len,db fL,db fM,db fR)&#123; //求长度为len的[L,R]区间，中点为M的Simpson近似面积 return (fL+4*fM+fR)*len/6;&#125;db Simpson(db L,db R) &#123;//Simpson积分求区间[L,R]的面积并,F(L)=L,F(R)=R,F(M)=M,把[L,R]当成整体来拟合得到的面积是sqr db M=(L+R)/2,fL=F(L),fM=F(M),fR=F(R),sqr=calc(R-L,fL,fM,fR); db g1=calc(M-L,fL,F((L+M)/2),fM),g2=calc(R-M,fM,F((M+R)/2),fR); if(fabs(sqr-g1-g2)&lt;=eps) //把当前区间分成2半再拟合得到的答案差别很小，就不再递归下去了 return g1+g2; return Simpson(L,M)+Simpson(M,R);&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); scanf("%d%d%Lf%d",&amp;a,&amp;b,&amp;g,&amp;n); g=g*pi/180; for0(i,n)&#123; int x,y,z,r; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;r); cir_set[i]=circle(x,y,z,r); // cout&lt;&lt;cir_set[i].x&lt;&lt;' '&lt;&lt;cir_set[i].y&lt;&lt;' '&lt;&lt;cir_set[i].r&lt;&lt;endl; &#125; printf("%.2Lf\n",Simpson(0,a)); return 0;&#125; title: 包子凑数mathjax: truedate: 2019-03-23 23:09:26tags: mathcategories: 蓝桥杯 题意给 $n(1\le n\le 100)$ 个数$(1\le a_i\le 100)$，问由它们不能组合(加法)成的数(正整数)的个数，若有无穷个输出”INF”。 题解若它们的公共 gcd 不为1，输出 INF，构造一个小顶堆，每次新加的值为堆顶的值加$a_i$ ，弹出堆顶，可证最大不可表示的值不会超过1e4，所以当堆顶大于1e4的时候跳出循环。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;priority_queue&lt;int,vii,greater&lt;int&gt; &gt;que;bool vis[11000];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,a[110]; mem0(vis); in(n); fro0(i,n)in(a[i]); if(n==1)&#123; if(a[0]==1)puts("0"); else puts("INF"); &#125;else&#123; int gc=a[0]; for1(i,n-1)gc=gcd(gc,a[i]); if(gc==1)&#123; int ans=0; sort(a,a+n); fro0(i,n)&#123; vis[a[i]]=1; que.push(a[i]); &#125; while(1)&#123; int to=que.top(); que.pop(); if(to&gt;=1e4)break; fro0(i,n)&#123; int now=to+a[i]; if(now&lt;=1e4&amp;&amp;vis[now]==0)&#123; vis[now]=1; que.push(now); &#125; &#125; &#125; for1(i,1e4)if(!vis[i])ans++; printf("%d\n",ans); &#125;else puts("INF"); &#125; return 0;&#125; title: 国王的烦恼date: 2019-03-20 21:45:27tags: dsucategories: 蓝桥杯 题意n 个点 m 条边，每条边有一个权值表示该边消失的时间，求有新的点不联通的时刻的数量。 题解以时间从大到小排序，用并查集反向建图，注意同时刻只能计一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e4;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int uni[N];int find_r(int x)&#123; if(uni[x]==x)return x; else return uni[x]=find_r(uni[x]);&#125;bool merge(int a,int b)&#123; int fa=find_r(a),fb=find_r(b); if(fa==fb)return 0; uni[fa]=fb; return 1;&#125;struct edg&#123; int u,v,w; bool operator &lt; (const edg y)const&#123; return w&gt;y.w; &#125;&#125;edge[10*N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; scanf("%d%d",&amp;n,&amp;m); for1(i,n)uni[i]=i; for0(i,m)scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); sort(edge,edge+m); int ans=0,time=0; for0(i,m)&#123; // cout&lt;&lt;edge[i].u&lt;&lt;' '&lt;&lt;edge[i].v&lt;&lt;' '&lt;&lt;edge[i].w&lt;&lt;endl; if(merge(edge[i].u,edge[i].v))&#123; if(edge[i].w!=time)&#123; time=edge[i].w; ans++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125; title: 图形排版date: 2019-03-20 23:07:51tags: data structurecategories: 蓝桥杯 题意小明需要在一篇文档中加入 N 张图片，其中第 i 张图片的宽度是 Wi，高度是 Hi。假设纸张的宽度是 M，小明使用的文档编辑工具会用以下方式对图片进行自动排版： 该工具会按照图片顺序，在宽度 M 以内，将尽可能多的图片排在一行。该行的高度是行内最高的图片的高度。例如在 M=10 的纸张上依次打印 3x4, 2x2, 3x3 三张图片，则效果如下图所示，这一行高度为4。(分割线以上为列标尺，分割线以下为排版区域；数字组成的矩形为第x张图片占用的版面) 如果当前行剩余宽度大于0，并且小于下一张图片，则下一张图片会按比例缩放到宽度为当前行剩余宽度(高度向上取整)，然后放入当前行。例如再放入一张4x9的图片，由于剩余宽度是2，这张图片会被压缩到2x5，再被放入第一行的末尾。此时该行高度为5： 如果当前行剩余宽度为0，该工具会从下一行开始继续对剩余的图片进行排版，直到所有图片都处理完毕。此时所有行的总高度和就是这 N 张图片的排版高度。例如再放入11x1, 5x5, 3x4 的图片后，效果如下图所示，总高度为11： 现在由于排版高度过高，图片的先后顺序也不能改变，小明只好从 N 张图片中选择一张删除掉以降低总高度。他希望剩余N-1张图片按原顺序的排版高度最低，你能求出最低高度是多少么？ 题解预处理以第 i 张图为行首的最低高度，然后枚举删图。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;pii a[N],b[N];int suf[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m,n,w,h; scanf("%d%d",&amp;m,&amp;n); for0(i,n)&#123; scanf("%d%d",&amp;w,&amp;h); a[i]=pii(w,h); &#125; for0(i,n)&#123; w=m; h=0; int len=i; for(;len&lt;n&amp;&amp;w;len++)&#123; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; // cout&lt;&lt;h&lt;&lt;endl; b[i]=pii(len,h); &#125; // puts(""); // for0(i,n)cout&lt;&lt;b[i].first&lt;&lt;' '&lt;&lt;b[i].second&lt;&lt;endl; for(int i=n-1;i&gt;=0;i--)&#123; suf[i]=suf[b[i].first]+b[i].second; &#125; // for0(i,n)cout&lt;&lt;suf[i]&lt;&lt;endl; int ans=inf,flag=0,tot=0; while(flag&lt;n)&#123; for(int i=flag;i&lt;b[flag].first;i++)&#123; w=m; h=0; int len=flag; for(;len&lt;n&amp;&amp;w;len++)&#123; if(len==i)continue; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; ans=min(ans,tot+h+suf[len]); &#125; tot+=b[flag].second; flag=b[flag].first; // tot+= &#125; printf("%d\n",ans); return 0;&#125; title: 城市建设date: 2019-03-21 21:53:53tags: graph categories: 蓝桥杯题意n 个城市，m 条道路，每条道路有一个权值(可能为负)，每个点有一个权值，表示修建码头的费用(为-1时表示不可以修建码头)。 题解ans1不修建码头的最小生成树ans2额外添加一个0号城市，将可建立码头的城市与它相连，求出的最小生成树当不建码头也能联通时，答案为min(ans1,ans2)，否则答案为 ans2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 2e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct Edge&#123; int u,v,c; Edge()&#123;&#125; Edge(int a,int b,int _c)&#123; u=a,v=b,c=_c; &#125; bool operator &lt;(const Edge y)const&#123; return c&lt;y.c; &#125;&#125;edge[N];int uni[N];int find_r(int x)&#123; if(x==uni[x])return x; else return uni[x]=find_r(uni[x]);&#125;int merge(Edge x)&#123; int fa=find_r(x.u),fb=find_r(x.v); if(fa!=fb)&#123; uni[fa]=fb; return 1; &#125; if(x.c&lt;0)return -1; else return 0;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,c,w,Size=0; ll ans1=0,ans2=0; scanf("%d%d",&amp;n,&amp;m); for0(i,m)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); edge[Size++]=Edge(u,v,c); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); int cnt=0; for0(i,Size)&#123; switch(merge(edge[i]))&#123; case 1: ans1+=edge[i].c; cnt++; break; case -1: ans1+=edge[i].c; &#125; &#125; for1(i,n)&#123; ind(w); if(w&gt;0)edge[Size++]=Edge(0,i,w); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); for0(i,Size)&#123; if(merge(edge[i]))ans2+=edge[i].c; &#125; if(cnt==n-1)ans2=min(ans2,ans1); printf("%lld\n",ans2); return 0;&#125; title: 填字母游戏mathjax: truedate: 2019-04-21 19:16:03tags: brute forcecategories: 蓝桥杯 题意一个 $1*N$ 个格子, 上面已有一些 L 和 O, 两人博弈, 谁先拼出 LOL 谁获胜, 空格数&lt;14 题解状态标记搜索 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.6e6;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int ans[N];ll pow3[23];bool iskong[23];// int wei[23];int len;// int cnt;int fun(ll status)&#123; // cnt++; int ans_status=0; ll tmp_sta=status; int *wei=new int[23]; bool have0=0; for0(i,len)&#123; int flag=tmp_sta%3; wei[i]=flag; if(flag==0)have0=1; if(iskong[i])&#123; ans_status*=3; ans_status+=flag; &#125; tmp_sta/=3; &#125; if(ans[ans_status]&lt;inf)&#123; delete [] wei; return ans[ans_status]; &#125; for(int i=0;i+2&lt;len;i++)&#123; if(wei[i]==1&amp;&amp;wei[i+1]==2&amp;&amp;wei[i+2]==1)&#123; delete [] wei; return ans[ans_status]=-1; &#125; &#125; if(!have0)&#123; delete [] wei; return ans[ans_status]=0; &#125; // if(x.find("LOL") != -1)return -1; // if(x.find("*") == -1)return 0; int res = -1; delete [] wei; // delete tmp_sta; tmp_sta=status; for0(i,len)&#123; int flag=tmp_sta%3; if(flag==0)&#123; res = max(res,-fun(status+pow3[i])); res = max(res,-fun(status+2*pow3[i])); if(res==1)break; &#125; tmp_sta/=3; &#125; // for(int i = 0;x[i];i++) // if(x[i] == '*')&#123; // x[i] = 'L'; // res = max(res,-fun(x)); // if(res == 1)return x[i] = '*',1; // x[i] = 'O'; // res = max(res,-fun(x)); // x[i] = '*'; // &#125; return ans[ans_status]=res;&#125;int main()&#123; // clock_t wei=clock(); int t; in(t); char s[23]; pow3[0]=1; for1(i,22)&#123; pow3[i]=pow3[i-1]*3; &#125; while(t--)&#123; // cnt=0; meminf(ans); mem0(iskong); in(s); // cout&lt;&lt;s&lt;&lt;endl; ll tmp=0; len=strlen(s); assert(len&lt;23); // cout&lt;&lt;len&lt;&lt;endl; for0(i,len)&#123; tmp*=3; if(s[i]=='L')tmp+=1; else if(s[i]=='O')tmp+=2; else iskong[len-i-1]=1; &#125; outln(fun(tmp)); // outln(cnt); &#125; // printf("%lu\n",clock()-wei); return 0;&#125; title: 小朋友排队mathjax: falsedate: 2019-03-23 01:20:00tags: data structure binary indexed treecategories: 蓝桥杯 题意n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。 题解每个人的不高兴度为它的逆序对数(在它前面大于它的，在它后面小于它的)，使用树状数组从前从后分别跑一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int h,no,cnt; da()&#123;&#125; da(int a,int b)&#123; h=a; no=b; cnt=0; &#125; oper(da)&#123; if(h==y.h)return no&lt;y.no; else return h&lt;y.h; &#125;&#125;a[N];int b[N],n,h;;itn lowbit(int x)&#123; return x&amp;(-x);&#125;int add(int x)&#123; int tmp=0; for(int i=x;i;i-=lowbit(i))&#123; tmp+=b[i]; &#125; for(itn i=x;i&lt;=n;i+=lowbit(i))&#123; b[i]++; &#125; return tmp;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(n); fro0(i,n)&#123; in(h); a[i]=da(h,i+1); &#125; sort(a,a+n); ll ans=0; fro0(i,n)&#123; a[i].cnt+=i-add(a[i].no); &#125; mem0(b); forr(i,n-1,0)&#123; a[i].cnt+=add(a[i].no); ans+=(ll)a[i].cnt*(a[i].cnt+1)/2; &#125; printf("%lld\n",ans); return 0;&#125; title: 斐波那契date: 2019-03-20 23:20:36tags: mathcategories: 蓝桥杯mathjax: true 题意$f(x)$为斐波那契数列，求$\large\left(\sum\limits_{i=1}^nf(i)\right) mod f(m) mod p$ $0&lt;n,m,p&lt;1e18$ 题解 f(n+m)=f(n+1)f(m)+f(n)f(m-1) \\ f(n)\ mod\ f(m)=f(n-m)f(m-1)\ mod\ f(m)\\ f(n)\ mod \ f(m)=f(m-1)^{\frac n m}f(n\%m)\ mod\ f(m)\\ f(n)^2=(-1)^{n+1}+f(n-1)f(n+1)\\ f(m-1)^2\ mod\ f(m)=(-1)^m m 为偶数 $\frac n m$为偶数，$f(n) mod f(m)=f(n\%m)$ $\frac n m$为奇数，$f(n) mod f(m)=f(m-1)f(n\%m) mod f(m)$ m 为奇数 $\frac n m$为偶数，$\frac n {2m}$为偶数，$f(n) mod f(m)=f(n\%m)$ $\frac n m$为偶数，$\frac n {2m}$为奇数，$f(n) mod f(m)=f(m)-f(n\%m)$ $\frac n m$为奇数，$\frac n {2m}$为偶数，$f(n) mod f(m)=f(m-1)f(n\%m) mod f(m)$ $\frac n m$为奇数，$\frac n {2m}$为奇数，$f(n) mod f(m)=f(m)-f(m-1)f(n\%m) mod f(m)$ 简化$f(m-1)f(n\%m) mod f(m)$ 性质：若$n\ge1,r\ge2$，则$f(n)f(n+r-1)-f(n+1)f(n+r-2)=(-1)^{n+1}f(r-2)$ 令$k=n\%m,k=n+1,m-1=n+r-2$，则$f(n)f(k-1)-f(m-1)f(k)=(-1)^kf(m-k)$ 所以$f(m-1)f(k) mod f(m)=(-1)^{k+1}f(m-k) mod f(m)$ 当$k$为奇时，$f(m-1)f(n\%m) mod f(m)=f(m-k)$ 当$k$为偶时，$f(m-1)f(n\%m) mod f(m)=f(m)-f(m-k)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f; ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct matrix &#123; ll a[2][2]; matrix()&#123; mem0(a); &#125;&#125;;ll qMulti(ll x,ll y,ll mod)&#123; //O(1)快速乘 return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod; &#125;matrix mat_mul(matrix x, matrix y) &#123; matrix res; for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) res.a[i][j] = (res.a[i][j] + qMulti(x.a[i][k] , y.a[k][j],mod) ) % mod; return res;&#125;ll mat_pow(ll n) &#123; if (n &lt;= 2) return 1; n -= 2; matrix c, res; c.a[0][0] = c.a[0][1] = c.a[1][0] = 1; for (int i = 0; i &lt; 2; i++) res.a[i][i] = 1; while (n) &#123; if (n % 2) res = mat_mul(res, c); c = mat_mul(c, c); n /= 2; &#125; return (res.a[0][0] + res.a[0][1]) % mod;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll n,m,p; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; mod=p; n+=2; ll k=n/m; if(n%m==0)&#123; cout&lt;&lt;((mat_pow(m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; int Sign; if(m%2)Sign=-1; else Sign=1; if(k%2)&#123; k/=2; if(k%2==0)Sign=1; if(n%m%2==0)Sign=-Sign; if(Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; k/=2; if(k%2&amp;&amp;Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125; &#125; return 0;&#125; 引用https://blog.csdn.net/acdreamers/article/details/21822165---title: 杂题mathjax: truedate: 2019-03-22 11:07:35tags: mathcategories: 其他 1题意将整数n拆分为m个数的和，输出这m个数or的最小值。 题解要想使或值最小，那么m个二进制数中的最高位应尽量小，假如存在k使$(2^k-1)m &gt; n &gt; (2^{k-1}-1)*m$，所以m个二进制数中至少有一个数的最高位为k。因为是取各位取或，所以此时应让尽量多的数的第k位为1，$ans += 2^k$，从高位向低位递推，直到n变为0。 2题意 \Large\sum\limits_{i=1}^n\lfloor\frac n i\rfloor代码123456789101112//solution1int k=sqrt(n+0.1);for (int i = 1; i &lt;= k; i++) &#123; ans+=n/i; if (n/(i+1)&lt;i)break; else ans+=(n/i-n/(i+1))*i;&#125;//solution2for (int i = 1; i &lt;= k; i++) ans+=n/i;ans*=2;ans-=k*k; 3题意设一个排列，当i为奇数，a[i]&gt;a[i-1]，求满足条件的长度为n的数量 题解设答案是 $f(n)$考虑最⼤大的数的位置是 i，则变成一个长度为 i-1 的数列列和一个长度为 n-i 的数列列所以 $f(n)=\sum\frac {f(i)f(n-i-1)} n$所以 $f(x)’=f(x)^2+1$解得 $f(x)=tan(x)$ 4题解n+1个数由1-n 组成，只有一个重复的，找出来。 代码123456789101112131415161718192021int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int low = nums[0], fast = nums[nums[0]]; while (low != fast) &#123; low = nums[low]; fast = nums[nums[fast]]; &#125; fast = 0; while (low != fast) &#123; low = nums[low]; fast = nums[fast]; &#125; return low;&#125;int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[abs(nums[i]) - 1] &lt; 0) return abs(nums[i]); nums[abs(nums[i]) - 1] *= -1; &#125; return -1;&#125; 5 法一: 求每个点左边连续比它大的最左边的下标，保存在l[]数组里,求每个点右边连续比它大的最右边的下标，保存在r[]数组里 法二: 维护一个单调栈, 如果h大于栈顶元素，则入栈, 否则，将栈内元素出栈，直到满足上面的条件。出栈时，我们要将出栈元素对之后问题的影响全部考虑进行处理，才能保证做法的正确性。 6 只需n+m-1个就可以填满, 当插入点(x1,y1) 时有关系x1&lt;=&gt;y1 当插入点(x2,y1) 时有关系 x2&lt;=&gt;y1&lt;=&gt;x1 当插入点(x1,y2) 时有关系 y2&lt;=&gt;x1&lt;=&gt;y1&lt;=&gt;x2 用并查集来连接 7给你一个序列n个数组成，然后让你在里面找到m个子序列，让这m个子序列的和最大。 12345dp[i][j]表示的是第j个数字在第i个子序列时的当前最优值。dp[i][j] = maxx(dp[i][j-1] + num[j] ,maxx(dp[i-1][k]) + num[j]); k是从1到j-1.可以这么理解这个转移方程，对于当前的这个数字，如果把他放到第i个子序列中有两种情况，一个是他作为第i个子序列的第一个数字，另一个就是不作为第一个数字，作为第一个数字的时候是 max(dp[i-2][k] + num[j]) 1&lt;=k&lt;i 的意思是从之前的所有中找到i-1个子序列的最大值+当前的值，不做为第一个的时候那么他前面的那个数字一定是i序列的，同一个子序列，又不是作为第一个，那么前面的那个货就一定是同一个子序列的，那么当前的值是dp[i][j-1] + num[j],在两种决策中选择一个最有的就行了，还有就是maxx(dp[i-1][k]+num[j])的这个地方可以开一个数组记录下来，不能每次都跑，跑不起，再有就是这个题目没有给m的范围，所以开不了二维数组（目测不是很大，大的话会超时，但是肯定是先超内存在超时，所以为了保险，还是吧dp[][]压缩成一维的）那么状态转移就边成这样了dp[j]表示的是 j这个人在当前的这个子序列中的最优值，mk[j]表示的是在上一个子序列中1--j的dp的最大值，所以就变成 dp[j] = maxx(dp[j-1] + num[j] ,mk[j-1]+num[j]);还是 max(作为i个子序列的第一个元素，不是第一个元素取一个最大值)。在解释下代码的核心部分。 8给一个函数 12345678910int f(int x,int y)&#123; int c=0; while(y&gt;0)&#123; c++; t=x%y; x=y; y=t; &#125; return c*x*x;&#125; 给出n,m,p，求$\Large\sum\limits_{i=1}^n\sum\limits_{j=1}^m\lfloor\frac {i*j} {f(i,j)}\rfloor$ ans=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{i+j*k\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor\\=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*(k+p*c))} {c*x*x}\rfloor\\ =\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor+\frac {p*j*j} {x*x}9有n家银行围成一个圈，有个人在有些银行里欠了钱，在一些银行里有存钱，欠的钱总数等于存的钱总数。现在可以有操作，如果两个银行相邻，那么就能在一个银行转任意多的钱到另一个银行。问最少的操作次数，使得在所有银行的存款钱数都为0。 首先我们要发现第一个贪心。如果有一段子串，里面的数字之和等于0，那么在这段子串中移动数字，所需要的代价为子串长度len-1，那么问题就转换成了，我们在这个圈中能找到多少段子串，里面的数字之和等于0，而且段数越多越好，记为k，那么很明显，答案就是n-k，现在问题来了，如何来求满足题意的最大的k。首先，我们考虑用前缀和来存放，如果遇到两个位置，前缀和相等，那么中间那一段数字之和肯定等于0。接下来就是一个跳跃性的思考了，那么如果某个前缀和的值出现了k次，是不是就是我们上述的k呢？答案是正确的！假如有k个位置的前缀和相等，那么中间k-1段子串内数字之和一定都是0，由于总数是0，那么最前面和最后面连着的那一段也肯定是0，所以，我们记录所有的前缀和的值，然后排序。然后用取尺法记录一个数出现的最多次数，就做完了 10将整数n拆分为m个数的和，输出这m个数or的最小值。 要想使或值最小，那么m个二进制数中的最高位应尽量小，假如存在k使$(2^k-1)m &gt; n &gt; (2^{k-1}-1)*m$，所以m个二进制数中至少有一个数的最高位为k。因为是取各位取或，所以此时应让尽量多的数的第k位为1，$ans += 2^k$，从高位向低位递推，直到n变为0。 11求a~b间素数个数(1 ≤ a ≤ b &lt; 2^31, b - a ≤ 100000). 12345678memset(visab,0,sizeof(visab));for (int i = 0; i &lt; cnt &amp;&amp; prime[i] &lt;= b; i++) &#123; LL k = a / prime[i]; if (k * prime[i] &lt; a) k++; for (LL j = k * prime[i]; j &lt;= b; j += prime[i]) &#123; visab[j - a] = 1; &#125;&#125; 12求和 \Large\sum\limits_{i=1}^n\lfloor\frac n i\rfloor123456789101112//solution1int k=sqrt(n+0.1);for (int i = 1; i &lt;= k; i++) &#123; ans+=n/i; if (n/(i+1)&lt;i)break; else ans+=(n/i-n/(i+1))*i;&#125;//solution2for (int i = 1; i &lt;= k; i++) ans+=n/i;ans*=2;ans-=k*k; 13设一个排列，当i为奇数，a[i]&gt;a[i-1]，求满足条件的长度为n的数量 设答案是 f(n) 考虑最⼤大的数的位置是 i，则变成⼀一个⻓长度为 i-1 的数列列和一个⻓长度为 n-i 的数列列 所以 f(n)=sum(f(i)f(n-i-1))/n 所以 f(x)’=f(x)^2+1 解得 f(x)=tan(x) 14n+1个数由1-n 组成，只有一个重复的，找出来。 123456789101112131415161718192021int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int low = nums[0], fast = nums[nums[0]]; while (low != fast) &#123; low = nums[low]; fast = nums[nums[fast]]; &#125; fast = 0; while (low != fast) &#123; low = nums[low]; fast = nums[fast]; &#125; return low;&#125;int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[abs(nums[i]) - 1] &lt; 0) return abs(nums[i]); nums[abs(nums[i]) - 1] *= -1; &#125; return -1;&#125; title: 格子刷油漆date: 2019-03-20 22:35:25tags: dpcategories: 蓝桥杯mathjax: true 题意给一个$2*N$的矩阵，可以从任意一个格子刷起，但只能移动到和它相邻的格子（可以对角），求总的方案数，对$1e9+7$取模。 题解设a[n]为起点为某一角落长度为n终点任意的情况数，b[n]为起点为某一角落长度为n终点必须同列的情况数。 $b[i]=2^{i-1}$ 当起点在四个角落，以左上角为例 情况一，先向下移动，再向右移动某个位置，情况数相当于 做长度为i-1的终点任意的情况数*2 因为不需要在回到第一列，而且到第二列的时候可能是第一行或者第二行，即$a[i-1]*2$ 情况二，从起点出发最终回到第一列的第二行，那么情况数就是b[i]。 先进入第二列，然后返回第一列另一个位置，然后再回第二列，即$22a[i-2]$ 当起点在中间 情况一，向左运动后回到第i列然后向右运动 情况二，向右运动后回到第i列然后向左运动 \sum\limits_{i=2}^{n-1}2*(b[i+1]*a[n-i]+b[n-i+2]*a[i-1]) $a[1]=1,a[2]=6$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll a[N],b[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,ans=0; b[1]=1; forl(i,2,1e3)&#123; b[i]=b[i-1]*2%mod; &#125; a[1]=1;a[2]=6; forl(i,3,1e3)&#123; a[i]=(2ll*a[i-1]+b[i]+4ll*a[i-2])%mod; &#125; ind(n); if(n==1)&#123; puts("2"); return 0; &#125; ans=4ll*a[n]%mod; forl(i,2,n-1)&#123; ans=(ans+2ll*(b[i+1]*a[n-i]%mod+b[n-i+2]*a[i-1]%mod))%mod; &#125; printf("%d\n",ans); return 0;&#125; 引用https://blog.csdn.net/qq_35078631/article/details/54730870---title: 波动数列mathjax: truedate: 2019-03-22 23:59:14tags: dp categories: 蓝桥杯题意长度为 n 和为 s 而且后一项总是比前一项增加 a 或者减少 b 的整数数列可能有多少种。$1&lt;=n&lt;=1e3，-1e9&lt;=s&lt;=1e9，1&lt;=a, b&lt;=1e6$ 题解设数列首项为$a_1$，增量为$d_1,d_2,\cdots,d_{n-1}$，则$\large na_1+\sum\limits_{i=1}^{n-1}(n-i-1)d_i=s$因为$a_1$可以取任意值，所以$\large \sum\limits_{i=1}^{n-1}(n-i-1)d_i\equiv s (mod n)$$dp[i][j]$表示长度为$i$，$\large \sum\limits_{k=1}^{i-1}(n-k-1)d_k mod n=j$ 的方案数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e8+7;const int N = 1.1e3;const db eps = 1e-8;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;ll dp[N][N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,s,a,b,nxt; in(n,s,a,b); s=(s%n+n)%n,a%=n,b%=n; dp[1][0]=1; for1(i,n-1)&#123; for0(j,n)&#123; nxt=(j+a*(n-i)%n)%n; dp[i+1][nxt]=(dp[i+1][nxt]+dp[i][j])%mod; nxt=(j-b*(n-i)%n+n)%n; dp[i+1][nxt]=(dp[i+1][nxt]+dp[i][j])%mod; &#125; &#125; printf("%lld\n",dp[n][s]); return 0;&#125; title: 蓝桥杯-车轮轴迹mathjax: truedate: 2019-09-04 14:44:05tags: geometry categories: 蓝桥杯题意 求圆心轨迹的总长度。 题解圆有两种状态，一是在线段上，二是在端点上。平移或旋转时可能会被线段阻挡，也可能会被端点阻挡。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2]或[k2,k1] 内 ll inf =0x3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e5;/*-----------------------------------head----------------------------------------------*/struct Point&#123; db x,y; Point()&#123;&#125; Point(db _x,db _y) : x(_x),y(_y)&#123;&#125; Point operator + (const Point &amp;k1) const&#123;return Point(k1.x+x,k1.y+y);&#125; Point operator - (const Point &amp;k1) const&#123;return Point(x-k1.x,y-k1.y);&#125; Point operator * (const db k1) const&#123;return Point(x*k1,y*k1);&#125; Point operator / (const db k1) const&#123;return Point(x/k1,y/k1);&#125; db operator * (const Point b) const&#123;return x * b.x + y * b.y;&#125;//点积 db operator ^ (const Point b) const&#123;return x * b.y - y * b.x;&#125;//叉积,顺时针为负 bool operator == (const Point &amp;k1) const&#123;return db_cmp(x,k1.x)==0&amp;&amp;db_cmp(y,k1.y)==0;&#125; Point &amp; operator += (const Point &amp;k1) &#123;x+=k1.x;y+=k1.y;return *this;&#125; Point &amp; operator -= (const Point &amp;k1) &#123;x-=k1.x;y-=k1.y;return *this;&#125; Point &amp; operator *= (const db k1) &#123;*this=*this*k1;return *this;&#125; Point &amp; operator /= (const db k1) &#123;*this=*this/k1;return *this;&#125; Point rotate(db k1)&#123;return Point(x*cos(k1)-y*sin(k1),x*sin(k1)+y*cos(k1));&#125;// 逆时针旋转 Point rotate90()&#123;return Point(-y,x);&#125; db abs()&#123;return sqrt(x*x+y*y);&#125; db abs2()&#123;return x*x+y*y;&#125; Point unit()&#123;return *this/abs();&#125; db angle()&#123;return atan2(y,x);&#125; void out()&#123;printf("%.10f %.10f\n",x,y);&#125;&#125;;typedef Point Vector;int inmid(Point k1,Point k2,Point k3)&#123;return inmid(k1.x,k2.x,k3.x)&amp;&amp;inmid(k1.y,k2.y,k3.y);&#125;db angleOfTwoVector(Vector a, Vector b) &#123;return fabs(atan2(a ^ b, a * b));&#125;Point proj(Point q,Point k1,Point k2)&#123; // q 到直线 k1,k2 的投影 Point k=k2-k1; return k1+k*((q-k1)*k/k.abs2());&#125;Point reflect(Point q,Point k1,Point k2)&#123;// q 关于直线 k1,k2 的对称点 return proj(q,k1,k2)*2-q;&#125;Point getLL(Point k1,Point k2,Point k3,Point k4)&#123;//直线交点 db w1=(k1-k3)^(k4-k3),w2=(k4-k3)^(k2-k3); return (k1*w2+k2*w1)/(w1+w2);&#125;int intersect(db l1,db r1,db l2,db r2)&#123;//是否有交集 if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return db_cmp(r1,l2)!=-1&amp;&amp;db_cmp(r2,l1)!=-1;&#125;int checkSL(Point k1,Point k2,Point k3,Point k4)&#123;// 求线段 (S) k1,k2 和直线 (L) k3,k4 的交点 return sign((k3-k1)^(k4-k1))*sign((k3-k2)^(k4-k2))&lt;=0;&#125;int checkSS(Point k1,Point k2,Point k3,Point k4)&#123;//两线段是否相交 return intersect(k1.x,k2.x,k3.x,k4.x)&amp;&amp;intersect(k1.y,k2.y,k3.y,k4.y)&amp;&amp;checkSL(k1,k2,k3,k4)&amp;&amp;checkSL(k3,k4,k1,k2);&#125;db disPP(Point k1,Point k2)&#123;return (k2-k1).abs();&#125;db disPP2(Point k1,Point k2)&#123;return (k2-k1).abs2();&#125;db disPS(Point q,Point k1,Point k2)&#123; Point k3=proj(q,k1,k2); if (inmid(k1,k2,k3)) return disPP(q,k3); return min(disPP(q,k1),disPP(q,k2));&#125;db disPL(Point q,Point k1,Point k2)&#123; if(k1==k2)return disPP(q,k1); return fabs((q - k1) ^ (k2 - k1)) / (k2-k1).abs();&#125;db disSS(Point k1,Point k2,Point k3,Point k4)&#123; if (checkSS(k1,k2,k3,k4)) return 0; return min(min(disPS(k1,k3,k4),disPS(k2,k3,k4)),min(disPS(k3,k1,k2),disPS(k4,k1,k2)));&#125;db disSL(Point k1,Point k2,Point k3,Point k4)&#123; if (checkSL(k1,k2,k3,k4)) return 0; return min(disPL(k1,k3,k4),disPL(k2,k3,k4));&#125;int onS(Point q,Point k1,Point k2)&#123;return inmid(k1,k2,q)&amp;&amp;sign((k1-q)^(k2-k1))==0;&#125;struct Line &#123; Point s, t; Line()&#123;&#125; Line(Point _s,Point _t):s(_s),t(_t)&#123;&#125; Vector dir()&#123;return (t-s);&#125; Vector unitDir()&#123;return (t-s).unit();&#125; int place(Point k)&#123;return sign((t-s)^(t-k));&#125; db len()&#123;return (t-s).abs();&#125;&#125;;typedef Line Segment;Point proj(Point q,Line k)&#123;return proj(q,k.s,k.t);&#125;Point reflect(Point q,Line k)&#123;return reflect(q,k.s,k.t);&#125;Point getLL(Line k1,Line k2)&#123;return getLL(k1.s,k1.t,k2.s,k2.t);&#125;bool parallel(Line k1,Line k2)&#123;return sign(k1.dir()^k2.dir())==0;&#125;bool sameDir(Line k1,Line k2)&#123;return parallel(k1,k2)&amp;&amp;sign(k1.dir()*k2.dir())==1;&#125;int checkSS(Segment k1,Segment k2)&#123;return checkSS(k1.s,k1.t,k2.s,k2.t);&#125;int checkSL(Segment k1,Line k2)&#123;return checkSL(k1.s,k1.t,k2.s,k2.t);&#125;db disPS(Point a, Segment b) &#123;return disPS(a,b.s,b.t);&#125;db disPL(Point a, Line b) &#123;return disPL(a,b.s,b.t);&#125;db disSS(Segment k1,Segment k2)&#123;return disSS(k1.s,k1.t,k2.s,k2.t);&#125;db disSL(Segment k1,Line k2)&#123;return disSL(k1.s,k1.t,k2.s,k2.t);&#125;int onS(Point q,Segment k)&#123;return onS(q,k.s,k.t);&#125;Point a[N],center;Line b[N];db r;int main() &#123; int n; db ans=0; in(n); in(r); for0(i,n)in(a[i].x),in(a[i].y); center=Point(a[0].x,a[0].y+r); for1(i,n-1)b[i]=Segment(a[i-1],a[i]); int p=1; bool isOnLine=1; while(p&lt;=n-1)&#123; if(isOnLine)&#123; Vector dir=b[p].dir(); Vector ver=dir.rotate90().unit(); Line vli=Line(b[p].s+ver*r,b[p].t+ver*r); db k=disPP(center,vli.t); isOnLine=0; p++; for(int i=p;i&lt;n;i++)&#123; if((vli.dir()^b[i].dir())&gt;0&amp;&amp;disSS(vli,b[i])&lt;r)&#123; db tm=disPP(center,getLL(vli,b[i]))-dir.abs()*b[i].dir().abs()*r/abs(dir^b[i].dir()); Point t_center=center+vli.dir().unit()*tm; if(db_cmp (disPS(t_center,b[i]),r)==0&amp;&amp;tm&lt;k)&#123; k=tm; isOnLine=1; p=i; &#125; if(r-disPS(b[i].t,vli)&gt;-eps)&#123; db tmp=disPL(b[i].t,vli)*disPL(b[i].t,vli); db tm=sqrt(disPP2(center,b[i].t)-tmp)-sqrt(r*r-tmp); t_center=center+vli.dir().unit()*tm; if(tm&lt;k&amp;&amp;db_cmp (disPS(t_center,b[i]),r)==0)&#123; k=tm; isOnLine=0; p=i+1; &#125; &#125; &#125; &#125; center=center+dir.unit()*k; ans+=k; &#125;else&#123; Point poi=b[p-1].t; db k=angleOfTwoVector(b[p].dir().rotate90(),center-poi); isOnLine=1; for(int i=p+1;i&lt;n;i++)&#123; Line tm=b[i]; Vector ver =tm.dir().rotate90().unit()*r; tm.s=tm.s+ver;tm.t=tm.t+ver; if(r-disPS(poi,tm)&gt;-eps)&#123; db ttm=disPL(poi,tm)*disPL(poi,tm); db tmp=sqrt(disPP2(poi,tm.t)-ttm)-sqrt(r*r-ttm); Point t_center=tm.t-tm.dir().unit()*tmp; db tk=angleOfTwoVector(center-poi,t_center-poi); if(tk&lt;k&amp;&amp;db_cmp(disPS(t_center,b[i]),r)==0)&#123; k=tk; isOnLine=1; p=i; &#125; &#125; db tmp=disPP(poi,b[i].t); if(2*r-tmp&gt;-eps)&#123; tmp=sqrt(r*r-tmp*tmp/4); Point mid=(poi+b[i].t)/2; mid=mid+(b[i].t-poi).rotate90().unit()*tmp; db tk=angleOfTwoVector(center-poi,mid-poi); if(tk&lt;k&amp;&amp;db_cmp(disPS(mid,b[i]),r)==0)&#123; k=tk; isOnLine=0; p=i+1; &#125; &#125; &#125; ans+=k*r; center=(center-poi).rotate(2*pi-k)+poi; &#125; &#125; out(ans,2,1); return 0;&#125; title: 蚂蚁感冒mathjax: falsedate: 2019-03-22 17:20:23tags: similar categories: 蓝桥杯题意长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。 题解首先明白两只蚂蚁碰撞之后掉头和穿行过去是一样的，可以把穿行看做碰撞后掉头了，然后两个蚂蚁交换了，而是哪一只蚂蚁对结果不影响。那么，假如第一只感冒蚂蚁向右走，那么碰到所有想左走的都会被感染，而感染后的蚂蚁必定是向左走的，那么他会把左边向右走的都感染了。向左走的也是这样。所以 ans = 左边向右走的 + 右边向左走的 + 1（本身）。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int num; bool kind; da()&#123;&#125; da (int a,bool b)&#123; num=a; kind=b; &#125; bool operator &lt;(const da y)const&#123; return num&lt;y.num; &#125;&#125;a[55];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x; ind(n); for0(i,n)&#123; ind(x); if(x&lt;0)&#123; a[i]=da(-x,0); &#125;else a[i]=da(x,1); &#125; x=a[0].num; bool flag=a[0].kind,right=0; sort(a,a+n); int l=0,r=0; for0(i,n)&#123; if(a[i].num==x)&#123; right=1; continue; &#125; if(right&amp;&amp;a[i].kind==0)&#123; r++; &#125;else if(!right&amp;&amp;a[i].kind)&#123; l++; &#125; &#125; int ans=1; if(l&amp;&amp;r)ans+=l+r; else if(flag)&#123; ans+=r; &#125;else ans+=l; printf("%d\n",ans); return 0;&#125; 引用https://blog.csdn.net/y990041769/article/details/21941711---title: 计蒜客-LISmathjax: truedate: 2019-06-17 21:21:09tags: binary indexed tree dpcategories: 计蒜客 题意从长度为 $n(\le 5e5)$ 的数组中等概率的取出一个最长上升子序列, 求每个数被选中的概率 题解$bg[i]$ 是以 $a[i]$ 为起点的 $LIS$ 的长度, $g[i]$ 是以 $a[i]$ 为起点的 $LIS$ 的数量 $en[i]$ 是以 $a[i]$ 为终点的 $LIS$ 的长度, $h[i]$ 是以 $a[i]$ 为终点的 $LIS$ 的数量 $\text{len_a}[i]$ 是以 $i$ 为起点或终点的 $LIS$ 的长度, $\text{cnt_a}[i]$ 是以 $i$ 为起点或终点的 $LIS$ 的数量 $\text{len_h}[i],\text{cnt_h}[i] $ 是树状数组的辅助数组 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e5;const ll mod = 998244353;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int bg[N],g[N],en[N],h[N],a[N],b[N],len_h[N],len_a[N],cnt_h[N],cnt_a[N];//cnt[i]极大值树,len[i]int lowbit(int x)&#123; return x&amp;(-x);&#125;void Update(int x,int y,int z,int n)&#123; if(len_a[x]==y)&#123; cnt_a[x]=(cnt_a[x]+z)%mod; &#125;else&#123; len_a[x]=y;; cnt_a[x]=z; &#125; int lx; while(x&lt;=n)&#123; len_h[x]=len_a[x]; cnt_h[x]=cnt_a[x]; lx = lowbit(x); for (int i=1; i&lt;lx; i&lt;&lt;=1) if(len_h[x-i]&gt;len_h[x])&#123; len_h[x]=len_h[x-i]; cnt_h[x]=cnt_h[x-i]; &#125;else if(len_h[x-i]==len_h[x])cnt_h[x]=(cnt_h[x]+cnt_h[x-i])%mod; // mx[x] = max(mx[x], len[x-i]); x += lowbit(x); &#125;&#125;pii query(int l,int r)&#123;//返回 （以[l,r]结尾的最长LIS , 以[l,r]结尾的最长LIS的数量) int ans = 0; int tl=l,tr=r; while(r &gt;= l)&#123; ans = max(ans,len_a[r]); r--; for(;r-lowbit(r)&gt;= l ;r-=lowbit(r))ans = max(ans,len_h[r]); &#125; l=tl;r=tr; int tot=0; while(r &gt;= l)&#123; // ans = max(ans,len_a[r]); if(len_a[r]==ans)tot=(tot+cnt_a[r])%mod; r--; for(;r-lowbit(r)&gt;= l ;r-=lowbit(r))&#123; if(len_h[r]==ans)tot=(tot+cnt_h[r])%mod; // ans = max(ans,len_h[r]); &#125; &#125; return pii(ans,tot);&#125;int qpow(ll a,ll b)&#123; ll ans=1; a%=mod; while(b)&#123; if(b%2)ans=ans*a%mod; a=a*a%mod; b/=2; &#125; return ans;&#125;int main() &#123; int n; in(n); for0(i,n)&#123; in(a[i]); b[i]=a[i]; &#125; sort(b,b+n); for0(i,n)a[i]=lower_bound(b,b+n,a[i])-b+1; int L=0; pii tmp; for0(i,n)&#123; tmp=query(1,a[i]-1); en[i]=tmp.fi+1; L=max(L,en[i]); h[i]=tmp.se; if(en[i]==1)h[i]=1; Update(a[i],en[i],h[i],n); &#125; mem0(cnt_a);mem0(cnt_h);mem0(len_a);mem0(len_h); int tot=0; for(int i=n-1;i&gt;=0;i--)&#123; tmp=query(a[i]+1,n); bg[i]=tmp.fi+1; g[i]=tmp.se; if(bg[i]==1)g[i]=1; if(bg[i]==L)tot=(tot+g[i])%mod; Update(a[i],bg[i],g[i],n); &#125; tot=qpow(tot,mod-2); for0(i,n)&#123; if(bg[i]+en[i]==L+1)&#123; out(1ll*h[i]*g[i]%mod*tot%mod); &#125;else out(0); &#125; return 0;&#125; title: 计蒜客-MaxAnswermathjax: truedate: 2019-08-08 10:23:51tags: categories:题意求数组的一个子区间，使得 子区间之和 乘以 子区间最小值 最大，求最大值 题解权值可能为负，分别考虑正负，正数使用但单调栈，负数求出最小连续子段和乘以该子段的最小值 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e5;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;stack&lt;pll&gt;sta; int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; ll x; in(n); ll ans=0,minn=0,tot=0; for0(i,n)&#123; in(x); if(tot+x&gt;0)&#123; tot=minn=0; &#125;else&#123; minn=min(minn,x); tot+=x; ans=max(ans,minn*tot); &#125; if(x&lt;=0)&#123; ll tmp=0; whiel(sta.size())&#123; tmp+=sta.top().se; ans=max(ans,sta.top().fi*tmp); sta.pop(); &#125; &#125;else&#123; ll tmp=0; while(sta.size()&amp;&amp;x&lt;=sta.top().fi)&#123; tmp+=sta.top().se; ans=max(ans,sta.top().fi*tmp); sta.pop(); &#125; sta.push(pll(x,tmp+x)); &#125; &#125; ll tmp=0; whiel(sta.size())&#123; tmp+=sta.top().se; ans=max(ans,sta.top().fi*tmp); sta.pop(); &#125; outln(ans); return 0;&#125; title: 计蒜客-数组mathjax: truedate: 2019-06-12 13:17:58tags: data structure categories: 计蒜客题意给出长度为 $N$ 的数组 $A$, 定义 f(l, r)=\max \left(\max \left(A_{l}, A_{l+1} \ldots A_{x}\right) \cdot(r-x+1) \cdot[l \leq x \leq r]\right)求 \sum_{i=1}^{n} \sum_{j=i}^{n} f(i, j) \bmod 10^{9}+7题解从后往前枚举 $i$ , 用一个单调栈来存在固定 $i$ 的时候, $j\in[i,n]$ , 不同 $j$ 的 $x$ 的取值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int a,r,pre,i; //r 表示取 a 的 j 的区间的右端点 da(int _a,int _r,int _p,ll _i)&#123; a=_a; r=_r; pre=_p; i=_i; &#125; da()&#123;&#125;&#125;;stack&lt;da&gt;sta;ll fun(itn a,int l,int r)&#123; return (r-l+1ll)*(l+r)/2%mod*a%mod;&#125;int a[N];int main() &#123; itn n; ll ans=0; in(n); for1(i,n)&#123; in(a[i]); &#125; for(int i=n;i&gt;0;i--)&#123; ll r=n; whiel(sta.size())&#123; da tmp=sta.top(); if(tmp.a&lt;=a[i])&#123; sta.pop(); &#125;else&#123; ll p=(tmp.a*1ll*tmp.i-tmp.a+a[i]-a[i]*1ll*i)/(tmp.a-a[i]); if(p&gt;=tmp.r)&#123; sta.pop(); &#125;else&#123; r=p; break; &#125; &#125; &#125; // cout&lt;&lt;i&lt;&lt;' '&lt;&lt;r&lt;&lt;"\n"; assert(r&lt;=n); // assert(r&gt;=) int pre=0; if(sta.size())&#123; da tmp=sta.top(); // cout&lt;&lt;tmp.a&lt;&lt;' '&lt;&lt;tmp.i&lt;&lt;endl; pre=tmp.pre; // assert(r&gt;=tmp.i); pre=(pre+fun(tmp.a,r-tmp.i+2,tmp.r-tmp.i+1))%mod; &#125; // cout&lt;&lt;endl; sta.push(da(a[i],r,pre,i)); ans=(ans+pre+fun(a[i],1,r-i+1))%mod; &#125; outln(ans); return 0;&#125; title: 邮局mathjax: truedate: 2019-04-26 20:31:39tags: brute forcecategories: 蓝桥杯 题意$n(1\le n\le50)$ 个人, $m(1\le m \le 25)$ 个车站, 选 $k(1\le k\le 10)$ 个车站, 每个人去离他最近的车站, 输出路径和最短的方案. 题解搜索剪枝, 从后往前搜索, 若对于当前状态, 某一点无法对任意一个人松弛, 就标记这个点, 之后的搜索都不再访问. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;// int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int n,m,k;struct point&#123; int x,y,no;&#125;people[55],mail[33];db G[55][33];point result[11],tmp_res[11];db ans=1e18,sum,min_dis[55];bool Not[33];db get_dis(point a,point b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;void dfs(int depth,int index)&#123; if(depth==k)&#123; if(sum&lt;ans)&#123; ans=sum; for0(i,k)result[i]=tmp_res[i]; &#125; &#125;else&#123; db tmp[55],tsum=sum; bool flag2=0;//标记 [index,m-k+depth] 这些点里有没有能够至少松弛一个人的点 for0(i,n)tmp[i]=min_dis[i]; for(int i=m-k+depth;i&gt;=index;i--)&#123; //当前已经取了 depth 个, 为了保证能够取得 k 个,所以我们最多取到 m-k+depth 点, 从这一点开始往前搜索 if(Not[i])continue; bool flag=0;//标记 i 是否能够至少松弛一个人 if(depth==0)&#123; sum=0; for0(j,n)&#123; min_dis[j]=G[j][i]; sum+=min_dis[j]; &#125; flag=1; &#125;else&#123; // for0(j,n)min_dis[j]=tmp[j]; sum=tsum; for0(j,n)&#123; if(G[j][i]&lt;tmp[j])&#123; sum-=tmp[j]-G[j][i]; min_dis[j]=G[j][i]; flag=1; &#125;else min_dis[j]=tmp[j]; &#125; &#125; if(flag)&#123; tmp_res[depth]=mail[i]; dfs(depth+1,i+1); flag2=1; &#125;else&#123; Not[i]=1; &#125; &#125; if(!flag2)&#123;//若 [index,m-k+depth] 这些点里没有能够松弛的, 就取 m-k+depth tmp_res[depth]=mail[m-k+depth+1]; dfs(depth+1,m-k+depth+1); &#125;else&#123; for0(j,n)min_dis[j]=tmp[j]; sum=tsum; &#125; &#125;&#125;int main() &#123; in(n,m,k); for0(i,n)&#123; in(people[i].x,people[i].y); &#125; for0(i,m)&#123; in(mail[i].x,mail[i].y); mail[i].no=i+1; for0(j,n)&#123; G[j][i]=get_dis(people[j],mail[i]); &#125; &#125; dfs(0,0); for0(i,k)printf("%d ",result[i].no); puts(""); return 0;&#125; title: 高僧斗法date: 2019-03-20 22:01:44tags: gamecategories: 蓝桥杯 题意n 个物品放在阶梯，向上移动物品，不能越过挡在前面的物品，最后物品都挤在高段台阶，不能移动的输。 题解两两一组，当移动上面的，可以移动下面的相同距离，所以可以把每组之间的间距看作一堆石子，转化为 Nim 博弈。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vii v,vv;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int x; while(~ind(x))v.pb(x); int Xor=0; for(int i=0;i+1&lt;v.size();i+=2)&#123; vv.pb(v[i+1]-v[i]-1); Xor^=vv.back(); &#125; if(Xor)&#123; for0(i,v.size()-1)&#123; forl(j,v[i]+1,v[i+1]-1)&#123; if(i%2)&#123; if((Xor^vv[i/2])==vv[i/2]+j-v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125;else&#123; if((Xor^vv[i/2])==vv[i/2]-j+v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125; &#125; &#125; &#125;else puts("-1"); return 0;&#125; graph TD 1-->3 2-->3 3-->4 3-->5]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019ICPC-Nanchang]]></title>
    <url>%2F2019%2F09%2F20%2F2019ICPC-Nanchang%2F</url>
    <content type="text"><![CDATA[C. Hello 2019 (cf-705e)题意输入一个字符串，区间询问 $[s_l,s_r]$ 中，删去最少的字符，使得出现子序列 $”2019”$ ，而不出现 $”2018”$ 题解 $5$ 个状态： 0 - $””$ 1 - $”2”$ 2 - $”20”$ 3 - $”201”$ 4 - $”2019”$ 使用一个 $5\times5$ 的矩阵来表示每个点的状态转移所需要的代价，区间查询即这个区间的矩阵的乘积，这里的乘积有些不同，有点像 $floyd$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576char s[N],t[N];struct node&#123; int a[5][5]; node()&#123;meminf(a);&#125; node operator+(const node&amp; Y)const&#123; node res; for0(i,5) for0(j,5) for0(k,5)&#123; res.a[i][j]=min(res.a[i][j],a[i][k]+Y.a[k][j]); &#125; return res; &#125;&#125;Sum[N&lt;&lt;2];void PushUp(int rt)&#123;Sum[rt]=Sum[rt&lt;&lt;1]+Sum[rt&lt;&lt;1|1];&#125;//PushUp函数更新节点信息 ，这里是求和void Build(int l,int r,int rt)&#123; //Build函数建树，l,r表示当前节点区间，rt表示当前节点编号 if(l==r) &#123;//若到达叶节点 // scanf("%d",&amp;Sum[rt]); //Sum[rt]=A[l];//储存数组值 for0(i,5)Sum[rt].a[i][i]=0; if(t[l]=='2')&#123; Sum[rt].a[0][0]=1; Sum[rt].a[0][1]=0; &#125;else if(t[l]=='0')&#123; Sum[rt].a[1][1]=1; Sum[rt].a[1][2]=0; &#125;else if(t[l]=='1')&#123; Sum[rt].a[2][2]=1; Sum[rt].a[2][3]=0; &#125;else if(t[l]=='9')&#123; Sum[rt].a[3][3]=1; Sum[rt].a[3][4]=0; &#125;else if(t[l]=='8')&#123; Sum[rt].a[3][3]=1; Sum[rt].a[4][4]=1; &#125; return; &#125; int m=(l+r)&gt;&gt;1; Build(l,m,rt&lt;&lt;1); Build(m+1,r,rt&lt;&lt;1|1); PushUp(rt);//更新信息 &#125;node Query(int L,int R,int l,int r,int rt)&#123;//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号 if(L &lt;= l &amp;&amp; r &lt;= R)&#123;//在区间内，直接返回 return Sum[rt]; &#125; int m=(l+r)&gt;&gt;1; node ANS; if(L &lt;= m) ANS=ANS+ Query(L,R,l,m,rt&lt;&lt;1); if(R &gt; m) ANS=ANS+ Query(L,R,m+1,r,rt&lt;&lt;1|1); return ANS;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,q; in(n,q); in(s+1); for(int i = 1; i &lt;= n; i++)&#123; t[i] = s[n - i + 1]; &#125; Build(1,n,1); int l,r; while(q--)&#123; in(l,r); node tmp=Query(n-r+1,n-l+1,1,n,1); if(tmp.a[0][4]==inf)out(-1,1); else out(tmp.a[0][4],1); &#125; return 0;&#125; 题意 题解代码12]]></content>
      <categories>
        <category>icpc</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2014ICPC-Anshan]]></title>
    <url>%2F2019%2F09%2F20%2F2014ICPC-Anshan%2F</url>
    <content type="text"><![CDATA[H. NAND 题意给一个真值表，问最少使用多少个二输入与非门能够实现这个真值表的功能。 题解初始值 $15 - 00001111$ $51-00110011$ $85-01010101$ 用一个 $vector$ 表示当前具有的表达式，每次 $dfs$ 都选取两个做与非运算，加入队列再继续 $dfs$ ，有以下几个剪枝 标记 $vector$ 中的元素，避免重复加入 $dfs$ 的参数传入上一次的选取的两个值的下标，每次只取上一次右边的数 代码123456789101112131415161718192021222324252627282930int ans[256];vii v;bool vis[256];void dfs(int dep,int l,int r)&#123; if(dep==11)return; int len=v.size(); for(int i=l;i&lt;len;i++) for(int j=(i==l?r:0);j&lt;=i;j++)&#123;//只取小于i的数，避免重复 int tm=255^(v[i]&amp;v[j]); ans[tm]=min(ans[tm],dep); if(!vis[tm])&#123; vis[tm]=1; v.pu_b(tm); dfs(dep+1,i,j); v.pop_back(); vis[tm]=0; &#125; &#125;&#125;int main() &#123; v.pu_b(15);v.pu_b(51);v.pu_b(85); meminf(ans); ans[0]=vis[0]=ans[255]=vis[255]=1; for(int i:v)ans[i]=vis[i]=1; dfs(2,0,0); for0(i,256)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125; J. Square题意给你一个 $n*n(n\le8)$ 的棋盘，上面有一些格子必须是黑色。其它可以染黑或者染白。对于一个棋盘，定义它的优美度为它上面最大的连续白色子正方形的边长，对于每个 $0\le k\le n$，问有多少种染色方案使得棋盘的优美度为 $k$ ？ 题解将问题转化为求优美度小于 $k$ 的染色方案， $dp[i][sta]$ 表示第 $i$ 行状态为 $sta$ 的方案数，状态为一个 $k$ 进制数，第 $j$ 位表示区间 $j\sim j+k-1$ (每行下标从 $0$ 开始)往上延伸都为白色的最大高度，接下来枚举每行的染色方案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960ull ans[10];ull dp[10][1200];int val[10];int Pow[10][10];char s[10];int main() &#123; int t,n; for (int i = 1; i &lt;= 9; i++)&#123; Pow[i][0]=1; for (int j = 1; j &lt;= 9; j++)Pow[i][j]=Pow[i][j-1]*i; &#125; in(t); ans[0]=dp[0][0]=1; while(t--)&#123; in(n); int tot=0; for (int i = 1; i &lt;= n; i++)&#123; in(s); val[i]=0; for (int j = 0; j &lt; n; j++)&#123; val[i]*=2; if(s[j]=='o')val[i]++,tot++; &#125; &#125; for (int k = 2; k &lt;= n; k++)&#123; ull tmp=0; for (int i = 1; i &lt;= n; i++)&#123; for (int j = 0; j &lt; Pow[k][n-k+1]; j++)dp[i][j]=0; for(int s=val[i];;s=(s-1)&amp;val[i])&#123; for(int t=0;t&lt;Pow[k][n-k+1];t++)&#123; if(!dp[i-1][t])continue; bool is=1; ll mask=Pow[2][k]-1; int tt=t,ts=t; for(int j=0;j&lt;=n-k;j++,mask*=2)&#123; if((s&amp;mask)==mask)&#123; if(tt%k==k-1)is=0; else ts+=Pow[k][j]; &#125;else&#123; ts-=(tt%k)*Pow[k][j]; &#125; tt/=k; &#125; if(is)dp[i][ts]+=dp[i-1][t]; &#125; if(s==0)break; &#125; &#125; for (int i = 0; i &lt; Pow[k][n-k+1]; i++)tmp+=dp[n][i]; ans[k-1]=tmp; &#125; __int128 tm=1; tm&lt;&lt;=tot; ans[n]=tm-ans[n-1]; for(int i=n-1;i&gt;0;i--) ans[i]-=ans[i-1]; for (int i = 0; i &lt; n+1; i++)out((ll)(ans[i]%mod),1); &#125; return 0;&#125; K. Colorful Toy题意给 $N$ 个点，$M$ 条边，用 $C$ 种颜色给点染色，其中图形旋转后相同的染色方案只算一种，求有多少种不同的染色方案。 题解因为给的点都是整数点，图形只有在旋转 $90^\circ 180^\circ,270^\circ$ 时才可能与原图重合，旋转方案只有四种。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175struct Point&#123; db x,y; Point()&#123;&#125; Point(db _x,db _y) : x(_x),y(_y)&#123;&#125; Point operator + (const Point &amp;k1) const&#123;return Point(k1.x+x,k1.y+y);&#125; Point operator - (const Point &amp;k1) const&#123;return Point(x-k1.x,y-k1.y);&#125; Point operator * (const db k1) const&#123;return Point(x*k1,y*k1);&#125; Point operator / (const db k1) const&#123;return Point(x/k1,y/k1);&#125; db operator * (const Point b) const&#123;return x * b.x + y * b.y;&#125;//点积 db operator ^ (const Point b) const&#123;return x * b.y - y * b.x;&#125;//叉积,顺时针为负 bool operator == (const Point &amp;k1) const&#123;return db_cmp(x,k1.x)==0&amp;&amp;db_cmp(y,k1.y)==0;&#125; Point &amp; operator += (const Point &amp;k1) &#123;x+=k1.x;y+=k1.y;return *this;&#125; Point &amp; operator -= (const Point &amp;k1) &#123;x-=k1.x;y-=k1.y;return *this;&#125; Point &amp; operator *= (const db k1) &#123;*this=*this*k1;return *this;&#125; Point &amp; operator /= (const db k1) &#123;*this=*this/k1;return *this;&#125; Point rotate(db k1)&#123;return Point(x*cos(k1)-y*sin(k1),x*sin(k1)+y*cos(k1));&#125;// 逆时针旋转 Point rotate90()&#123;return Point(-y,x);&#125; db abs()&#123;return sqrt(x*x+y*y);&#125; db abs2()&#123;return x*x+y*y;&#125; Point unit()&#123;return *this/abs();&#125; db angle()&#123;return atan2(y,x);&#125; void out()&#123;printf("%.10f %.10f\n",x,y);&#125;&#125;;typedef Point Vector;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;map&lt;pii,int&gt;ma;bool Map[100][100];int ying [100];bool vis[100];int qu(db x)&#123; int tt=x; if(db_cmp(x,tt)==0)return tt; else if(db_cmp(x,tt-1)==0)return tt-1; else if(db_cmp(x,tt+1)==0)return tt+1; else return inf;&#125;bool check(pair&lt;db,db&gt;x)&#123; if(qu(x.fi)&lt;inf&amp;&amp;qu(x.se)&lt;inf)return 1; else return 0;&#125;int main() &#123; int t,n,m,c,u,v; in(t); while(t--)&#123; ma.clear(); in(n,m,c); db tx=0,ty=0; for1(i,n)&#123; in(u,v); ma[pii(u,v)]=i; tx+=u; ty+=v; &#125; assert(ma.size()==n); mem0(Map); for0(i,m)&#123; in(u,v); Map[u][v]=Map[v][u]=1; &#125; pii center; ll ans=qPow(c,n,mod); if(qu(tx/n*2)==inf||qu(ty/n*2)==inf)&#123; out(ans,1); continue; &#125;else center=pii(qu(tx/n*2),qu(ty/n*2)); int mu=1; bool is=1; mem0(vis); for(auto i:ma)&#123; pii p=i.fi; int id=i.se; pii op(center.fi-p.fi,center.se-p.se); if(ma.count(op))&#123; v=ma[op]; if(vis[v])&#123; is=0; break; &#125;else&#123; vis[v]=1; ying[id]=v; &#125; &#125;else &#123; is=0; break; &#125; &#125; if(is)&#123; for1(i,n) for1(j,n)&#123; if(Map[i][j])&#123; if(!Map[ying[i]][ying[j]])&#123; is=0; goto ss; &#125; &#125; &#125; &#125; ss: if(is)&#123; ans=(ans+qPow(c,(n+1)/2,mod))%mod; mu++; &#125;else &#123; out(ans,1); continue; &#125; Point cen(center.fi/2.0,center.se/2.0); // pair&lt;db,db&gt; cen=pair&lt;db,db&gt;(center.fi/2.0,center.se/2.0); // cout&lt;&lt;cen.x&lt;&lt; ' '&lt;&lt;cen.y&lt;&lt;endl&lt;&lt;endl; mem0(vis); for(auto i:ma)&#123; pii p=i.fi; int id=i.se; Vector dir(p.fi-cen.x,p.se-cen.y); // cout&lt;&lt;dir.x&lt;&lt;' '&lt;&lt;dir.y&lt;&lt;endl; dir=dir.rotate90(); // cout&lt;&lt;dir.x&lt;&lt;' '&lt;&lt;dir.y&lt;&lt;endl; dir=dir+cen; pair&lt;db,db&gt;tmp(dir.x,dir.y); // cout&lt;&lt;tmp.fi&lt;&lt; ' '&lt;&lt;tmp.se&lt;&lt;endl; // cout&lt;&lt;check(tmp)&lt;&lt;endl; if(check(tmp))&#123; pii op(qu(tmp.fi),qu(tmp.se)); // cout&lt;&lt;op.fi&lt;&lt;' '&lt;&lt;op.se&lt;&lt;endl; if(ma.count(op))&#123; v=ma[op]; if(vis[v])&#123; is=0; break; &#125;else&#123; vis[v]=1; ying[id]=v; &#125; &#125;else &#123; is=0; break; &#125; &#125;else&#123; is=0; break; &#125; &#125; if(is)&#123; for1(i,n) for1(j,n)&#123; if(Map[i][j])&#123; if(!Map[ying[i]][ying[j]])&#123; is=0; goto sp; &#125; &#125; &#125; &#125; sp: // cout&lt;&lt;is&lt;&lt;endl; if(is)&#123; mu+=2; ans=(ans+2*qPow(c,(n+3)/4,mod))%mod; // puts("fdsfs"); &#125; // out(ans,1); // out(mu,1); out(ans*qPow(mu,mod-2,mod)%mod,1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>icpc</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>brute force</tag>
        <tag>polya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ICPC-Shenyang]]></title>
    <url>%2F2019%2F09%2F19%2F2019ICPC-Shenyang%2F</url>
    <content type="text"><![CDATA[D. Fish eating fruit题意将树上任意两点之间的距离按取模 $3$ 分类，分别求出三种情况的路径和 题解 解法1: $dp1[u][j]$ 表示以 $u$ 为根节点的树，树上任意两点之间的距离取模 $3$ 为 $j$ 的路径和 $dp2[u][j]$ 表示以 $u$ 为根节点的树，树上的点到 $u$ 的距离取模 $3$ 为 $j$ 的路径和 $dp3[u][j]$ 表示以 $u$ 为根节点的树，树上的点到 $u$ 的距离取模 $3$ 为 $j$ 的节点数 解法2: 根据模 3 的余数设计 dp 方程 $dp[i][k]$ 统计距 i 模 3 为 k 的子节点的数目 $fp[i][k]$ 统计距 i 模 3 为 k 的非子节点的数目（父节点，兄弟节点，兄弟节点 的子节点） $ans[i][k]$ 统计距 i 模 3 为 k 的子节点到 i 的距离和 $fans[i][k]$ 统计距 i 模 3 为 k 的非子节点距离和 代码1234567891011121314151617181920212223242526272829303132333435363738ll dp1[N][3],dp2[N][3],dp3[N][3];vector&lt;pii&gt; node[N];int n;void dfs(int u,int fa)&#123; dp3[u][0]=1; for(auto i:node[u])&#123; int v=i.fi,w=i.se; if(v==fa)continue; dfs(v,u); for0(i,3)dp1[u][i]=(dp1[u][i]+dp1[v][i])%mod; for0(i,3) for0(j,3)&#123; int tm=(i+j+w)%3; dp1[u][tm]=(dp1[u][tm]+dp2[u][i]*dp3[v][j]%mod+dp2[v][j]*dp3[u][i]%mod+dp3[v][j]*dp3[u][i]%mod*w%mod)%mod; &#125; for0(i,3)dp2[u][(w+i)%3]=(dp2[u][(w+i)%3]+dp2[v][i]+w*dp3[v][i])%mod; for0(i,3)dp3[u][(w+i)%3]=(dp3[u][(w+i)%3]+dp3[v][i])%mod; &#125; return ;&#125;int main() &#123; int u,v,w; while(~in(n))&#123; for0(i,n)&#123; node[i].clear(); mem0(dp1[i]);mem0(dp2[i]);mem0(dp3[i]); &#125; for0(i,n-1)&#123; in(u,v,w); node[u].push_back(pii(v,w)); node[v].push_back(pii(u,w)); &#125; dfs(0,-1); for0(i,3)dp1[0][i]=dp1[0][i]*2%mod; out0(dp1[0],3); &#125; return 0;&#125; 题意 题解代码12]]></content>
      <categories>
        <category>icpc</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1215E]]></title>
    <url>%2F2019%2F09%2F18%2FCF-1215E%2F</url>
    <content type="text"><![CDATA[题意 $n(2\le n\le 4e5)$ 个物品，每个的颜色为 $a_i(1\le a_i\le 20)$ ，仅允许将相邻的物品两两交换，问使得相同颜色的物品聚集到一起的最小花费 题解预处理 $tran[i][j]$ 表示仅考虑颜色 $i,j$ 时，将所有颜色为 $i$ 的物品移到所有颜色为 $j$ 的物品前面的花费，然后再使用状压 $dp$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sz(a))#define mem_1(a) memset(a, -1, sz(a))#define mem0(a) memset(a, 0, sz(a))#define memcp(a,b) memcpy(a,b,sz(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define sz(a) (int)sizeof(a)typedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内 int inf = 0x3f3f3f3f;ll inf_ll = 0x3f3f3f3f3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e5;/*-----------------------------------head----------------------------------------------*/ll tran[30][30];vii node[30];ll dp[1&lt;&lt;20];int main() &#123; int n,x; in(n); for1(i,n)&#123; in(x); node[x-1].pu_b(i); &#125; meminf(dp); dp[0]=0; for0(i,20) for0(j,20)&#123; if(i==j)continue; int l=node[i].size(),r=node[j].size(); while(l&amp;&amp;r)&#123; if(node[i][l-1]&lt;node[j][r-1])&#123; r--; &#125;else&#123; tran[i][j]+=r; l--; &#125; &#125; &#125; for(int i=1;i&lt;(1&lt;&lt;20);i++)&#123; for0(j,20)&#123; if(i&amp;(1&lt;&lt;j))&#123; ll sum=0; for0(k,20)&#123; if(i&amp;(1&lt;&lt;k))sum+=tran[j][k]; &#125; dp[i]=min(dp[i],dp[i-(1&lt;&lt;j)]+sum); &#125; &#125; &#125; out(dp[(1&lt;&lt;20)-1],1); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ICPC-Shanghai]]></title>
    <url>%2F2019%2F09%2F16%2F2019ICPC-Shanghai%2F</url>
    <content type="text"><![CDATA[C. Triple题意给三个序列，分别从中选取一个数，输出能够构成一个三角形（线段也算）的方案数。 题解使用 $FFT$ 减去不符合条件的方案 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889typedef complex &lt;double&gt; cp;struct FFT&#123; int n, R[N]; cp a[N], b[N]; const double pi=acos(-1); void init(int bound)&#123; //bound是积多项式的最高次幂 int L(0); for(n=1;n&lt;=bound;n&lt;&lt;=1,L++); for(int i=0;i&lt;n;i++)R[i]=(R[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1)),a[i]=b[i]=0; &#125; void fft(cp* a, int opt)&#123; int i, j, k; cp wn, w, x, y; for(i=0;i&lt;n;i++)if(i&gt;R[i])swap(a[i],a[R[i]]); for(i=1;i&lt;n;i&lt;&lt;=1)&#123; wn=cp(cos(pi/i),opt*sin(pi/i)); for(j=0;j&lt;n;j+=i&lt;&lt;1) for(w=cp(1,0),k=0;k&lt;i;k++,w=w*wn)&#123; x=a[k+j], y=a[k+j+i]*w; a[k+j]=x+y, a[k+j+i]=x-y; &#125; &#125; if(opt==-1)for(i=0;i&lt;n;i++)a[i]/=n; &#125; void run()&#123; fft(a,1), fft(b,1); for(int i=0;i&lt;n;i++)a[i]*=b[i]; fft(a,-1); &#125;&#125;fft;ll ans;int cnta[N],cntb[N],cntc[N];void fun(int aa[],int bb[],int c[])&#123; for (int i = 0; i &lt;fft.n; i++)fft.a[i]=cp(aa[i]); for (int i = 0; i &lt;fft.n; i++)fft.b[i]=cp(bb[i]); fft.run(); ll pre=0; for(int i=0;i&lt;=1e5;i++)&#123; ans-=pre*c[i]; pre+=fft.a[i].real()+0.1; &#125;&#125;int tn;int main() &#123; int t,x; in(t); fft.init(2e5); for(int ca=1;ca&lt;=t;ca++)&#123; for (int i = 1; i &lt;= 1e5; i++)cnta[i]=cntb[i]=cntc[i]=0; in(tn); ans=1ll*tn*tn*tn; if(tn&lt;=1000)&#123; for (int i = 1; i &lt;= tn; i++)&#123; in(cnta[i]); &#125; for (int i = 1; i &lt;= tn; i++)&#123; in(cntb[i]); &#125; for (int i = 1; i &lt;= tn; i++)&#123; in(x); cntc[x]++; &#125; for (int i = 1; i &lt;= 1e5; i++)cntc[i]+=cntc[i-1]; ans=0; for (int i = 1; i &lt;= tn; i++) for (int j = 1; j &lt;= tn; j++)&#123; ans+=cntc[min(100000,cnta[i]+cntb[j])]-cntc[max(0,abs(cnta[i]-cntb[j])-1)]; &#125; &#125;else&#123; for (int i = 1; i &lt;= tn; i++)&#123; in(x); cnta[x]++; &#125; for (int i = 1; i &lt;= tn; i++)&#123; in(x); cntb[x]++; &#125; for (int i = 1; i &lt;= tn; i++)&#123; in(x); cntc[x]++; &#125; fun(cnta,cntb,cntc); fun(cnta,cntc,cntb); fun(cntb,cntc,cnta); &#125; printf("Case #%d: %lld\n",ca,ans); &#125; return 0;&#125; D. Counting Sequences I题意输入一个 $n$ ，问长度为 $n$ 的数列，满足 $a_1+a_2+\cdots+a_n=a_1\times a_2\times\cdots\times a_n$ 的方案数。 题解这样的序列满足 $1$ 的数量为 非 $1$ 部分的乘积减去非 $1$ 部分的和，我们只需要枚举非 $1$ 部分就可以了 设序列有 $k$ 种数，每种数有 $c_i$ 个，则方案数为 $\huge C_{n}^{c_1}\times C_{n-c_1}^{c_2}\times\cdots\times C_{n-c_1-\cdots-c_{i-1}}^{c_i}\times\cdots\times C_{c_k}^{c_k}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;ll fac[N],inv[N];ll C(ll a,ll b)&#123; if(b&gt;a)return 0; return fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;void init()&#123;//快速计算阶乘的逆元 fac[0]=fac[1]=1; for(int i=2;i&lt;N;i++)fac[i]=fac[i-1]*i%mod; inv[N-1] = qPow(fac[N-1], mod - 2, mod); for (int i = N - 2; i &gt;= 0; i--) inv[i] = (inv[i + 1] * (i + 1)) % mod;&#125;ll ans[3300];//总个数，当前的最小值，当前的最小值的个数，总乘积，总和，大于当前最小值的数的贡献void dfs(int dep,int now,int cnt,ll mul,ll tot,ll w)&#123; int num1=mul-tot; if(dep+num1&gt;3000)return; ans[dep+num1]=(ans[dep+num1]+w*C(dep,cnt)%mod*C(dep+num1,num1)%mod)%mod; dfs(dep+1,now,cnt+1,mul*now,tot+now,w);//再取一个当前最小值 for(int i=now-1;i&gt;=2;i--)&#123;//取一个更小的值 dfs(dep+1,i,1,mul*i,tot+i,w*C(dep,cnt)%mod); &#125;&#125;int main() &#123; //freopen("a.txt","w",stdout); init(); for(int i=2;i&lt;=3000;i++)&#123; dfs(1,i,1,i,i,1); &#125; int t,n; in(t); while(t--)&#123; in(n); out(ans[n],1); &#125; return 0;&#125; F. Rhyme scheme题意对 $n$ 个元素划分集合，每一种划分对应一个长度为 $n$ 的字符串，对这 $B_n$ 个字符串按字典序排序，问第 $k$ 个是什么。 如 $n=3$ 时，字符串为 $AAA,AAB,ABA,ABB,ABC$ 题解设 $dp[n][i][j]$ 表示对于 $n$ 个元素，前 $i$ 个元素被分为了 $j$ 个集合，剩余 $n-i$ 个元素划分集合的方案数。 dp[n][i][j]=j*dp[n][i+1][j]+dp[n][i+1][j+1]然后再在字典树上查找答案就可以了 代码123456789101112131415161718192021222324252627282930313233343536__int128 dp[30][30][30];int main() &#123; for1(i,26)&#123; for1(j,i)dp[i][i][j]=1; for(int j=i-1;j&gt;=0;j--)&#123; for1(k,j)dp[i][j][k]=k*dp[i][j+1][k]+dp[i][j+1][k+1]; &#125; out(dp[i][1][1]); puts(""); &#125; int n,t; char s[30]; in(t); for1(ca,t)&#123; in(n);in(s); __int128 k=0; for(int i=0,len=strlen(s);i&lt;len;i++)&#123; k*=10; k+=s[i]-'0'; &#125; printf("Case #%d: ",ca); int cnt=0; for1(i,n)&#123; for1(j,cnt+1)&#123; int tm=max(cnt,j); if(k&lt;=dp[n][i][tm])&#123; cnt=tm; putchar('A'+j-1); break; &#125;else k-=dp[n][i][tm]; &#125; &#125; puts(""); &#125; return 0;&#125; J. Stone game题意 $n(1\le n\le300)$ 堆石子，每堆石子有 $a_i(1\le a_i\le 500)$ 个，问有多少种取法使得取走的数量大于等于剩余的数量而且按这种取法丢弃掉任意一堆都将会小于等于剩余的石子数 题解对石子数从大到小排序， $dp[i]$ 表示总共取 $i$ 的方案数 代码12345678910111213141516171819202122232425ll dp[N];int a[400];int main() &#123; int t,n; in(t); while(t--)&#123; in(n); ll tot=0; for0(i,n)in(a[i]),tot+=a[i]; sort(a,a+n,greater&lt;int&gt;()); ll ans=0; mem0(dp); dp[0]=1; int maxx=0; for0(i,n)&#123; maxx+=a[i]; for(int j=maxx;j-a[i]&gt;=0;j--)&#123; dp[j]=(dp[j]+dp[j-a[i]])%mod; if(2*j&gt;=tot&amp;&amp;2*j&lt;=tot+a[i])ans=(ans+dp[j-a[i]])%mod;//注意加的是dp[j-a[i]]而不是dp[j]，因为dp[j-a[i]]才表示取了a[i]后总和为j的方案数 &#125; &#125; out(ans,1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>icpc</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>dfs</tag>
        <tag>fft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ICPC-Ningxia]]></title>
    <url>%2F2019%2F09%2F13%2F2018ICPC-Ningxia%2F</url>
    <content type="text"><![CDATA[E. 2-3-4 Tree题意裸的 $B+$ 树 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118const int k=4;struct Node&#123; int cnt; bool isLeaf; int a[3]; Node *child[k]; Node()&#123; isLeaf=1; cnt=0; mem0(child); &#125; void out()&#123; assert(cnt); out0(a,cnt); &#125;&#125;*root;void del(Node*rt)&#123; if(rt-&gt;isLeaf)delete rt; else&#123; for(int i=0;i&lt;=rt-&gt;cnt;i++)del(rt-&gt;child[i]); delete rt; &#125;&#125;pair&lt;Node*,int&gt; split(Node *rt)&#123; rt-&gt;cnt=1; Node *tmp=new Node; tmp-&gt;cnt=1; tmp-&gt;a[0]=rt-&gt;a[2]; tmp-&gt;isLeaf=rt-&gt;isLeaf; tmp-&gt;child[0]=rt-&gt;child[2]; tmp-&gt;child[1]=rt-&gt;child[3]; pair&lt;Node*,int&gt; tmm=pair&lt;Node*,int&gt;(tmp,rt-&gt;a[1]); if(rt==root)&#123; Node *p=new Node; p-&gt;cnt=1; p-&gt;a[0]=tmm.se; p-&gt;isLeaf=0; p-&gt;child[0]=rt; p-&gt;child[1]=tmp; root=p; &#125; return tmm;&#125;void add(Node *rt,int x)&#123; rt-&gt;a[rt-&gt;cnt++]=x; sort(rt-&gt;a,rt-&gt;a+rt-&gt;cnt);&#125;pair&lt;Node*,int&gt; insert(Node *rt,int x)&#123; int id; for(id=0;id&lt;rt-&gt;cnt;id++)&#123; if(x&lt;rt-&gt;a[id])&#123; break; &#125; &#125; if(rt-&gt;cnt==k-1)&#123; pair&lt;Node*,int&gt; ret = split(rt); if(rt-&gt;isLeaf)&#123; if(id&lt;2)add(rt,x); else add(ret.fi,x); return ret; &#125;else&#123; if(id&gt;1)rt=ret.fi; pair&lt;Node*,int&gt;tmp= insert(rt,x); if(tmp.se)&#123; if(id%2)&#123; rt-&gt;cnt++; rt-&gt;child[2]=tmp.fi; rt-&gt;a[1]=tmp.se; &#125;else &#123; rt-&gt;cnt++; rt-&gt;a[1]=rt-&gt;a[0]; rt-&gt;a[0]=tmp.se; rt-&gt;child[2]=rt-&gt;child[1]; rt-&gt;child[1]=tmp.fi; &#125; &#125; return ret; &#125; &#125;else&#123; if(rt-&gt;isLeaf)&#123; add(rt,x); &#125;else&#123; pair&lt;Node*,int&gt;tmp= insert(rt-&gt;child[id],x); if(tmp.se)&#123; for(int i=rt-&gt;cnt;i&gt;=id+1;i--)&#123; rt-&gt;a[i]=rt-&gt;a[i-1]; rt-&gt;child[i+1]=rt-&gt;child[i]; &#125; rt-&gt;cnt++; rt-&gt;a[id]=tmp.se; rt-&gt;child[id+1]=tmp.fi; &#125; &#125; return pair&lt;Node*,int&gt;(0,0); &#125;&#125;void dfs(Node *rt)&#123; rt-&gt;out(); if(!rt-&gt;isLeaf)&#123; for0(i,rt-&gt;cnt+1)dfs(rt-&gt;child[i]); &#125;&#125;int main() &#123; int t,n,x; in(t); for1(ca,t)&#123; root=new Node; in(n); for0(i,n)&#123; in(x); insert(root,x); &#125; printf("Case #%d:\n",ca); dfs(root); del(root); &#125; return 0;&#125; G. Factories题意给一棵树，选择 $k(1\le k\le 100)$ 个叶节点，使得两两之间的路径和最小。 题解 $dp[i][j]$ 表示在以 $i$ 为根的子树中选择 $j$ 个叶节点的最小花费，其中不仅包括 $j$ 个节点两两之间的路径，还包括 $j$ 个节点经过节点 $i$ 与另外 $k-j$ 相连的路径和。 转移方程为 $dp[u][i]=min(dp[u][i],dp[u][i-j]+dp[v][j]+j\times (k-j)\times dis[u][v])$ 状态转移的时 $i$ 应该从大到小枚举，避免先更新了较小值后面又使用。另外还需要记录一下每个节点的有效值的范围，不然会 $TLE$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct Node&#123; int v; ll w; Node(int _v,int _w)&#123;v=_v;w=_w;&#125;&#125;;vector&lt;Node&gt; node[N];ll dp[N][110];ll ans;int k;int cnt[N];//记录每个节点有效值的范围void dfs(int u,int fa)&#123; for(auto v:node[u])&#123; if(v.v==fa)continue; dfs(v.v,u); int tmp=cnt[u]; for(int i=k;i&gt;0;i--)&#123; for(int j=min(cnt[v.v],i);j&gt;0&amp;&amp;i-j&lt;=tmp;j--)&#123; cnt[u]=max(cnt[u],i); dp[u][i]=min(dp[u][i],dp[u][i-j]+dp[v.v][j]+v.w*j*(k-j)); &#125; &#125; &#125; ans=min(ans,dp[u][k]);&#125;int main() &#123; int t,n,u,v,w; in(t); for1(ca,t)&#123; in(n,k); ans=inf_ll; for1(i,n)&#123; node[i].clear(); meminf(dp[i]); dp[i][0]=0; cnt[i]=0; &#125; int root=1; for0(i,n-1)&#123; in(u,v,w); node[u].push_back(Node(v,w)); node[v].pu_b(Node(u,w)); if(node[u].size()&gt;1)root=u; if(node[v].size()&gt;1)root=v; &#125; for1(i,n)if(node[i].size()==1)dp[i][1]=0,cnt[i]++; dfs(root,0); assert(ans!=inf_ll); printf("Case #%d: %lld\n",ca,ans); &#125; return 0;&#125; 题意 题解代码12]]></content>
      <categories>
        <category>icpc</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯-车轮轴迹]]></title>
    <url>%2F2019%2F09%2F04%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E8%BD%A6%E8%BD%AE%E8%BD%B4%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[题意 求圆心轨迹的总长度。 题解圆有两种状态，一是在线段上，二是在端点上。平移或旋转时可能会被线段阻挡，也可能会被端点阻挡。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2]或[k2,k1] 内 ll inf =0x3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e5;/*-----------------------------------head----------------------------------------------*/struct Point&#123; db x,y; Point()&#123;&#125; Point(db _x,db _y) : x(_x),y(_y)&#123;&#125; Point operator + (const Point &amp;k1) const&#123;return Point(k1.x+x,k1.y+y);&#125; Point operator - (const Point &amp;k1) const&#123;return Point(x-k1.x,y-k1.y);&#125; Point operator * (const db k1) const&#123;return Point(x*k1,y*k1);&#125; Point operator / (const db k1) const&#123;return Point(x/k1,y/k1);&#125; db operator * (const Point b) const&#123;return x * b.x + y * b.y;&#125;//点积 db operator ^ (const Point b) const&#123;return x * b.y - y * b.x;&#125;//叉积,顺时针为负 bool operator == (const Point &amp;k1) const&#123;return db_cmp(x,k1.x)==0&amp;&amp;db_cmp(y,k1.y)==0;&#125; Point &amp; operator += (const Point &amp;k1) &#123;x+=k1.x;y+=k1.y;return *this;&#125; Point &amp; operator -= (const Point &amp;k1) &#123;x-=k1.x;y-=k1.y;return *this;&#125; Point &amp; operator *= (const db k1) &#123;*this=*this*k1;return *this;&#125; Point &amp; operator /= (const db k1) &#123;*this=*this/k1;return *this;&#125; Point rotate(db k1)&#123;return Point(x*cos(k1)-y*sin(k1),x*sin(k1)+y*cos(k1));&#125;// 逆时针旋转 Point rotate90()&#123;return Point(-y,x);&#125; db abs()&#123;return sqrt(x*x+y*y);&#125; db abs2()&#123;return x*x+y*y;&#125; Point unit()&#123;return *this/abs();&#125; db angle()&#123;return atan2(y,x);&#125; void out()&#123;printf("%.10f %.10f\n",x,y);&#125;&#125;;typedef Point Vector;int inmid(Point k1,Point k2,Point k3)&#123;return inmid(k1.x,k2.x,k3.x)&amp;&amp;inmid(k1.y,k2.y,k3.y);&#125;db angleOfTwoVector(Vector a, Vector b) &#123;return fabs(atan2(a ^ b, a * b));&#125;Point proj(Point q,Point k1,Point k2)&#123; // q 到直线 k1,k2 的投影 Point k=k2-k1; return k1+k*((q-k1)*k/k.abs2());&#125;Point reflect(Point q,Point k1,Point k2)&#123;// q 关于直线 k1,k2 的对称点 return proj(q,k1,k2)*2-q;&#125;Point getLL(Point k1,Point k2,Point k3,Point k4)&#123;//直线交点 db w1=(k1-k3)^(k4-k3),w2=(k4-k3)^(k2-k3); return (k1*w2+k2*w1)/(w1+w2);&#125;int intersect(db l1,db r1,db l2,db r2)&#123;//是否有交集 if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return db_cmp(r1,l2)!=-1&amp;&amp;db_cmp(r2,l1)!=-1;&#125;int checkSL(Point k1,Point k2,Point k3,Point k4)&#123;// 求线段 (S) k1,k2 和直线 (L) k3,k4 的交点 return sign((k3-k1)^(k4-k1))*sign((k3-k2)^(k4-k2))&lt;=0;&#125;int checkSS(Point k1,Point k2,Point k3,Point k4)&#123;//两线段是否相交 return intersect(k1.x,k2.x,k3.x,k4.x)&amp;&amp;intersect(k1.y,k2.y,k3.y,k4.y)&amp;&amp;checkSL(k1,k2,k3,k4)&amp;&amp;checkSL(k3,k4,k1,k2);&#125;db disPP(Point k1,Point k2)&#123;return (k2-k1).abs();&#125;db disPP2(Point k1,Point k2)&#123;return (k2-k1).abs2();&#125;db disPS(Point q,Point k1,Point k2)&#123; Point k3=proj(q,k1,k2); if (inmid(k1,k2,k3)) return disPP(q,k3); return min(disPP(q,k1),disPP(q,k2));&#125;db disPL(Point q,Point k1,Point k2)&#123; if(k1==k2)return disPP(q,k1); return fabs((q - k1) ^ (k2 - k1)) / (k2-k1).abs();&#125;db disSS(Point k1,Point k2,Point k3,Point k4)&#123; if (checkSS(k1,k2,k3,k4)) return 0; return min(min(disPS(k1,k3,k4),disPS(k2,k3,k4)),min(disPS(k3,k1,k2),disPS(k4,k1,k2)));&#125;db disSL(Point k1,Point k2,Point k3,Point k4)&#123; if (checkSL(k1,k2,k3,k4)) return 0; return min(disPL(k1,k3,k4),disPL(k2,k3,k4));&#125;int onS(Point q,Point k1,Point k2)&#123;return inmid(k1,k2,q)&amp;&amp;sign((k1-q)^(k2-k1))==0;&#125;struct Line &#123; Point s, t; Line()&#123;&#125; Line(Point _s,Point _t):s(_s),t(_t)&#123;&#125; Vector dir()&#123;return (t-s);&#125; Vector unitDir()&#123;return (t-s).unit();&#125; int place(Point k)&#123;return sign((t-s)^(t-k));&#125; db len()&#123;return (t-s).abs();&#125;&#125;;typedef Line Segment;Point proj(Point q,Line k)&#123;return proj(q,k.s,k.t);&#125;Point reflect(Point q,Line k)&#123;return reflect(q,k.s,k.t);&#125;Point getLL(Line k1,Line k2)&#123;return getLL(k1.s,k1.t,k2.s,k2.t);&#125;bool parallel(Line k1,Line k2)&#123;return sign(k1.dir()^k2.dir())==0;&#125;bool sameDir(Line k1,Line k2)&#123;return parallel(k1,k2)&amp;&amp;sign(k1.dir()*k2.dir())==1;&#125;int checkSS(Segment k1,Segment k2)&#123;return checkSS(k1.s,k1.t,k2.s,k2.t);&#125;int checkSL(Segment k1,Line k2)&#123;return checkSL(k1.s,k1.t,k2.s,k2.t);&#125;db disPS(Point a, Segment b) &#123;return disPS(a,b.s,b.t);&#125;db disPL(Point a, Line b) &#123;return disPL(a,b.s,b.t);&#125;db disSS(Segment k1,Segment k2)&#123;return disSS(k1.s,k1.t,k2.s,k2.t);&#125;db disSL(Segment k1,Line k2)&#123;return disSL(k1.s,k1.t,k2.s,k2.t);&#125;int onS(Point q,Segment k)&#123;return onS(q,k.s,k.t);&#125;Point a[N],center;Line b[N];db r;int main() &#123; int n; db ans=0; in(n); in(r); for0(i,n)in(a[i].x),in(a[i].y); center=Point(a[0].x,a[0].y+r); for1(i,n-1)b[i]=Segment(a[i-1],a[i]); int p=1; bool isOnLine=1; while(p&lt;=n-1)&#123; if(isOnLine)&#123; Vector dir=b[p].dir(); Vector ver=dir.rotate90().unit(); Line vli=Line(b[p].s+ver*r,b[p].t+ver*r); db k=disPP(center,vli.t); isOnLine=0; p++; for(int i=p;i&lt;n;i++)&#123; if((vli.dir()^b[i].dir())&gt;0&amp;&amp;disSS(vli,b[i])&lt;r)&#123; db tm=disPP(center,getLL(vli,b[i]))-dir.abs()*b[i].dir().abs()*r/abs(dir^b[i].dir()); Point t_center=center+vli.dir().unit()*tm; if(db_cmp (disPS(t_center,b[i]),r)==0&amp;&amp;tm&lt;k)&#123; k=tm; isOnLine=1; p=i; &#125; if(r-disPS(b[i].t,vli)&gt;-eps)&#123; db tmp=disPL(b[i].t,vli)*disPL(b[i].t,vli); db tm=sqrt(disPP2(center,b[i].t)-tmp)-sqrt(r*r-tmp); t_center=center+vli.dir().unit()*tm; if(tm&lt;k&amp;&amp;db_cmp (disPS(t_center,b[i]),r)==0)&#123; k=tm; isOnLine=0; p=i+1; &#125; &#125; &#125; &#125; center=center+dir.unit()*k; ans+=k; &#125;else&#123; Point poi=b[p-1].t; db k=angleOfTwoVector(b[p].dir().rotate90(),center-poi); isOnLine=1; for(int i=p+1;i&lt;n;i++)&#123; Line tm=b[i]; Vector ver =tm.dir().rotate90().unit()*r; tm.s=tm.s+ver;tm.t=tm.t+ver; if(r-disPS(poi,tm)&gt;-eps)&#123; db ttm=disPL(poi,tm)*disPL(poi,tm); db tmp=sqrt(disPP2(poi,tm.t)-ttm)-sqrt(r*r-ttm); Point t_center=tm.t-tm.dir().unit()*tmp; db tk=angleOfTwoVector(center-poi,t_center-poi); if(tk&lt;k&amp;&amp;db_cmp(disPS(t_center,b[i]),r)==0)&#123; k=tk; isOnLine=1; p=i; &#125; &#125; db tmp=disPP(poi,b[i].t); if(2*r-tmp&gt;-eps)&#123; tmp=sqrt(r*r-tmp*tmp/4); Point mid=(poi+b[i].t)/2; mid=mid+(b[i].t-poi).rotate90().unit()*tmp; db tk=angleOfTwoVector(center-poi,mid-poi); if(tk&lt;k&amp;&amp;db_cmp(disPS(mid,b[i]),r)==0)&#123; k=tk; isOnLine=0; p=i+1; &#125; &#125; &#125; ans+=k*r; center=(center-poi).rotate(2*pi-k)+poi; &#125; &#125; out(ans,2,1); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ-3992]]></title>
    <url>%2F2019%2F08%2F30%2FBZOJ-3992%2F</url>
    <content type="text"><![CDATA[题意集合 $S\subseteq \{x|x\in[0,m-1]\}$ ，由这些数组成一个长度为 $N$ 的数列，给定整数 $r(r\in[0,m-1])$，求满足数列中所有数的乘积 $\mod m$ 的值等于 $r$ 的不同的数列的有多少个。 题解将 $S$ 和 $x$ 由 $m$ 的原根来表示，这样就可以变乘为加，将集合 $S$ 表示为 $\large f(x)=a_0x^0+a_1x^1+\cdots+a_{m-2}x^{m-2}$ ， $a_i$ 表示 $g^i$ 是否属于 $S$ 将 $f(x)$ 看作一个整体，使用快速幂和 $NTT$ 求解 $f(x)^n$ ，答案就为 $x^r$ 的系数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119ll inf =0x3f3f3f3f;ll mod = 1004535809;const int M = 2.1e5;const int N = 4.1e4;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int factor[50];int num_factor = 0;void decomposition(ll n) &#123; num_factor = 0; int m=(int)sqrt(n+0.5); for(int i=2;i&lt;=m;i++)&#123; if(n%i==0)&#123; factor[num_factor]=i; while(n%i==0)n/=i; num_factor++; &#125; &#125; if (n &gt; 1) factor[num_factor++] =n;&#125;int root(int m)&#123;//求a在模m意义下的阶 int phi=m-1; decomposition(phi); int g=2; while(1)&#123; bool yes=1; for0(i,num_factor)&#123; if(qPow(g,phi/factor[i],m)==1)&#123; yes=0; break; &#125; &#125; if(yes)break; g++; &#125; return g;&#125;int Map[N];int n,r[N];ll g=3,inv_g,inv_n;void init(int a,int b)&#123; int L=0;n=1; while(n &lt; a + b) n &lt;&lt;= 1,L++; inv_g=qPow(3,mod-2,mod); inv_n = qPow(n,mod-2,mod); for(int i = 0; i &lt; n; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); &#125;inline void NTT(int *A, int type) &#123;//type=1 系数-&gt;点值 ; type=-1 点值-&gt;系数 for(int i = 0; i &lt; n; i++) if(i &lt; r[i]) swap(A[i], A[r[i]]); for(int mid = 1; mid &lt; n; mid &lt;&lt;= 1) &#123; ll Wn = qPow( type == 1 ? g : inv_g , (mod - 1) / (mid &lt;&lt; 1),mod); for(int j = 0; j &lt; n; j += (mid &lt;&lt; 1)) &#123; ll w = 1; for(int k = 0; k &lt; mid; k++, w = (w * Wn) % mod) &#123; int x = A[j + k], y = w * A[j + k + mid] % mod; A[j + k] = (x + y) % mod, A[j + k + mid] = (x - y + mod) % mod; &#125; &#125; &#125; if(type==-1) for0(i,n)A[i]=A[i]*inv_n%mod;&#125;int ans[N],a[N],b[N];int m;void mult(int a[],int b[])&#123; NTT(a,1); NTT(b,1); for(int i=0;i&lt;n;i++) a[i]=1ll*a[i]*b[i]%mod; NTT(a, -1); for(int i=m-1;i&lt;2*m-1;i++)&#123; a[i%(m-1)]=(a[i%(m-1)]+a[i])%mod; a[i]=0; &#125;&#125;int main() &#123; int N,x,s,y; in(N,m,x,s); int rt=root(m),tm=1; for(int i=0;i&lt;m-1;i++)&#123; Map[tm]=i; tm=tm*rt%m; &#125; Map[0]=m-1; x=Map[x]; bool have0=0; for0(i,s)&#123; in(y); a[Map[y]]=1; if(y==0)have0=1; &#125; if(x==m-1)&#123; if(have0)&#123; out((qPow(s,N,mod)-qPow(s-1,N,mod)+mod)%mod,1); &#125;else out(0,1); return 0; &#125; ans[0]=1;a[m-1]=0; init(m-1,m-1); while(N)&#123; if(N%2)&#123; memcpy(b,a,sizeof(int)*(2*m)); memcp(b,a); mult(ans,b); &#125; memcpy(b,a,sizeof(int)*(2*m)); mult(a,b); N/=2; &#125; out(ans[x],1); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>ntt</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1207]]></title>
    <url>%2F2019%2F08%2F29%2FCF-1207%2F</url>
    <content type="text"><![CDATA[G. Indie Album题意有 $n$ 个字符串,对于第 $i$ 个字符串通过以下两种方式中的一个给出。 $1 c$，该字符串只含一个字符 $c$ 。 $2 x c$ ,该字符串为第 $x(1\le x&lt;i)$ 个字符串末尾添加一个字符 $c$ 得到。 有 $m$ 次询问，每次询问给出一个字符串 $s$ 和位置编号 $x$,问在上述第 $x$ 个字符串中，字符串 $s$ 出现了几次。 题解对询问构建 $AC$自动机，因为文本串是树形结构，我们可以跑一个 $dfs$ 枚举所有文本串，每次都添加一个字符，当回溯回去的时候删除这个字符对答案的贡献。 因为每个匹配串在文本串中出现的次数为将文本串在 $AC$自动机上跑一遍并将走到的位置权值 $+1$，该字符串所对应的 $fail$ 节点的子树权值和。所以我们拎出 $fail$ 树，对其 $dfs$ 序构造树状数组。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;ll inf =0x3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 4.1e5;/*-----------------------------------head----------------------------------------------*/ const int MAX = 26;int tot;vii failTree[N];struct Node &#123; int id; Node *Next[MAX]; Node *Fail; //失配指针,类似next数组,最大的next是和自身比较,fail是和其它匹配串比较 Node() &#123; memset(Next, 0, sizeof(Next)); Fail = 0; id=tot++; &#125;&#125; * root,*pp;int Insert(char s[]) &#123; Node *p = root; int len=strlen(s); for(int i=0;i&lt; len;i++) &#123; int c = s[i] - 'a'; if (p-&gt;Next[c] == NULL) &#123; Node *newnode = new Node; p-&gt;Next[c] = newnode; p = newnode; &#125; else p = p-&gt;Next[c]; &#125; return p-&gt;id;&#125;void BuildFail() &#123; queue&lt;Node *&gt; que; root-&gt;Fail=root; for(int i=0;i&lt;26;i++)&#123; if(root-&gt;Next[i])&#123; root-&gt;Next[i]-&gt;Fail=root; que.push(root-&gt;Next[i]); &#125;else root-&gt;Next[i]=root; &#125; while (!que.empty()) &#123; Node *p = que.front(); que.pop(); failTree[p-&gt;Fail-&gt;id].pu_b(p-&gt;id); for(int i=0;i&lt;26;i++)&#123; if(p-&gt;Next[i])&#123; p-&gt;Next[i]-&gt;Fail=p-&gt;Fail-&gt;Next[i]; que.push(p-&gt;Next[i]); &#125;else p-&gt;Next[i]=p-&gt;Fail-&gt;Next[i]; &#125; &#125;&#125;int L[N],R[N],cnt;void Dfs(int rt)&#123; L[rt]=cnt++; for(int v:failTree[rt])&#123; Dfs(v); &#125; R[rt]=cnt-1;&#125;int sum[N];void add(int p,int x,int n)&#123; //a[p]+=x,数组为[1,n] while(p&amp;&amp;p&lt;=n)sum[p]+=x,p+=p&amp;-p;&#125;ll query(int p)&#123; ll ans = 0; while(p)ans+=sum[p],p-=p&amp;-p; return ans;&#125;struct NODE&#123; char c; vector&lt;pii&gt; v;&#125;a[N]; vii node[N];char s[N];int ans[N];void dfs(int rt)&#123; for(int v:node[rt])&#123; Node *tmp=pp; pp = pp-&gt;Next[c-'a']; add(L[pp-&gt;id],1,cnt-1); for(auto i:a[v].v)ans[i.se]=query(R[i.fi])-query(L[i.fi]-1); dfs(v); add(L[pp-&gt;id],-1,cnt-1); pp=tmp; &#125;&#125;int main() &#123; int n,m,tp,v; root = new Node; pp=root; in(n); for1(i,n)&#123; in(tp); if(tp==1)&#123; in(s); node[0].pu_b(i); &#125;else&#123; in(v);in(s); node[v].pu_b(i); &#125; a[i].c=s[0]; &#125; in(m); for1(i,m)&#123; in(v);in(s); a[v].v.pu_b(pii(Insert(s),i)); &#125; BuildFail(); Dfs(0); dfs(0); for1(i,m)out(ans[i],1); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>dfs</tag>
        <tag>binary indexed tree</tag>
        <tag>ac automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1152]]></title>
    <url>%2F2019%2F08%2F27%2FCF-1152%2F</url>
    <content type="text"><![CDATA[D. Neko and Aki’s Prank题意将长度为 $2n$ 的所有合法括号匹配放入字典树中，求这棵树的最大的边集，边集里的边两两不相连 题解对于括号匹配 $(((),()((,(()($ 来说，其子树是一样的， $dp[i][j]$ 表示深度为 $i$ 的左括号比右括号多 $j$ 的括号匹配的答案，我们直接贪心的取边，能取就取，使用一个 $vis[i][j]$ 来标记点是否取了，$dp[i][j]=dp[i+1][j+1]+dp[i+1][j-1]+(vis[i+1][j+1]==0||vis[i+1][j-1]==0)$，注意判断 $[i][j]$ 是否是合法的节点 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e3;/*-----------------------------------head----------------------------------------------*/int dp[N][N],n;bool vis[N][N];bool check(int i,int j)&#123; if(j&gt;=0&amp;&amp;j&lt;=n&amp;&amp;(i-j)%2==0&amp;&amp;i+j&lt;=2*n)retrun 1; else retrun 0;&#125;int main() &#123; in(n); for(int i=2*n-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;=min(n,i);j++)&#123; bool flag=0; if(check(i+1,j-1))&#123; if(vis[i+1][j-1]==0)vis[i+1][j-1]=1,flag=1; dp[i][j]=(dp[i][j]+dp[i+1][j-1])%mod; &#125; if(check(i+1,j+1))&#123; if(vis[i+1][j+1]==0&amp;&amp;flag==0)flag=1,vis[i+1][j+1]=1; dp[i][j]=(dp[i][j]+dp[i+1][j+1])%mod; &#125; if(flag)&#123; vis[i][j]=1,dp[i][j]=(dp[i][j]+1)%mod; &#125; &#125; &#125; out(dp[0][0],1); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1208]]></title>
    <url>%2F2019%2F08%2F27%2FCF-1208%2F</url>
    <content type="text"><![CDATA[C. Magic Grid题意给一个 $n(n\%4=0)$ ，将 $0\sim n^2-1$ 填入 $n\times n$ 的矩阵里，使得每行每列的异或和相同。 题解 \begin{matrix} 0 & 1 & 2&3 \\ 4 & 5 & 6 &7\\ 8 & 9&10 &11\\ 12 & 13&14 &15\\ \end{matrix}因为 $n$ 是 $4$ 的倍数，将这个 $4\times4$ 的矩阵看作一个整体来填充矩阵即可，以为这个矩阵每个元素加上 $16k$ 不会影响结果]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>constructive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019HDU多校-Day8]]></title>
    <url>%2F2019%2F08%2F20%2F2019HDU%E5%A4%9A%E6%A0%A1-Day8%2F</url>
    <content type="text"><![CDATA[F. Acesrc and Travel题意给一颗树，每个点有两个权值 $a_i,b_i$ ，两个人博弈，交替选择节点，A 获得 $a_i$ ，B 获得 $b_i$ ，每次只能选取与上一个人相邻的节点。 题解先以任意点为根节点，算出这种情况的结果，再利用换根的方法求出所有节，要注意处理好根节点和叶节点的情况 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374vii node[N];ll w[N];pll dp[N][2];ll ans;void dfs(int u,int fa)&#123; ll max_fi=-inf,max_se=-inf,min_fi=inf,min_se=inf; if(fa&amp;&amp;node[u].size()==1)&#123;//非根叶节点 dp[u][0]=pll(w[u],-inf); dp[u][1]=pll(w[u],inf); return; &#125; for(auto i:node[u])&#123; if(i!=fa)&#123; dfs(i,u); if(dp[i][0].fi+w[u]&lt;min_fi)&#123; min_se=min_fi; min_fi=dp[i][0].fi+w[u]; &#125;else min_se=min(min_se,dp[i][0].fi+w[u]); if(dp[i][1].fi+w[u]&gt;max_fi)&#123; max_se=max_fi; max_fi=dp[i][1].fi+w[u]; &#125;else max_se=max(max_se,dp[i][1].fi+w[u]); &#125; &#125; dp[u][0]=pll(max_fi,max_se); dp[u][1]=pll(min_fi,min_se);&#125;void dfs2(int u ,int fa ,ll max1,ll min0)&#123; if(u!=1)&#123; if(node[u].size()==1) ans=max(ans,min0+w[u]); else&#123; if(min0+w[u]&lt;dp[u][1].fi)ans=max(ans,min0+w[u]); else ans=max(ans,dp[u][1].fi); &#125; &#125; for(int v:node[u])&#123; if(v!=fa)&#123; ll tmin,tamx; if(dp[u][1].fi==dp[v][0].fi+w[u])tamx=min(min0+w[u],dp[u][1].se); else tamx=min(min0+w[u],dp[u][1].fi); if(dp[u][0].fi==dp[v][1].fi+w[u])tmin=max(max1+w[u],dp[u][0].se); else tmin=max(max1+w[u],dp[u][0].fi); // cout&lt;&lt;v&lt;&lt;' '&lt;&lt;tmin&lt;&lt; ' '&lt;&lt;tamx&lt;&lt;endl; dfs2(v,u,tamx,tmin); &#125; &#125;&#125;int main() &#123; int t,n,u,v,x; in(t); while(t--)&#123; in(n); for1(i,n)in(w[i]); for1(i,n)&#123; node[i].clear(); in(x); w[i]-=x; &#125; for0(i,n-1)&#123; in(u,v); node[u].pu_b(v); node[v].pu_b(u); &#125; dfs(1,0); ans=dp[1][1].fi; if(node[1].size()==1) dfs2(node[1][0],1,w[1],w[1]);// 特判根节点只连有一个点的情况 else dfs2(1,0,-inf,inf); out(ans,1); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CF-1203F]]></title>
    <url>%2F2019%2F08%2F15%2FCF-1203F%2F</url>
    <content type="text"><![CDATA[题意给两个序列 $a[],b$ ，你拥有的技能点为 $r(1\le r\le 3e4)$ ，只有当技能点 $\ge a_i$ 时，才可以做第 $i$ 份工作，技能点加上 $b_i$ 问他能否完成这 $n$ 份工作 如果不能，最多能完成几份 题解 显然，对于 $b_i\ge 0$ ，我们以 $a_i$ 排序；对于 $b_i&lt; 0$ ，我们以 $a_i+b_i$ 排序。因为对于 $x,y$ 两个工作，假设 $xa+xb&lt;ya+yb$ ，如果 $r+xb&lt;ya$ ，那么一定有 $r+yb&lt;ax$ 对于 $b_i\ge 0$ 容易求解；对于 $b_i&lt; 0$ ，使用 $dp$ 来求解，同样以 $a_i+b_i$ 排序，$dp[i][j]$ 表示前 $i$ 份工作剩余 $j$ 技能点的最大完成数。 代码12345678910111213141516171819202122232425262728293031323334353637int dp[N];vector&lt;pii&gt;q,w;bool cmp(pii x,pii y)&#123; retrun x.fi+x.se&gt;y.fi+y.se;&#125;int main() &#123; int n,r,a,b; in(n,r); for0(i,n)&#123; in(a,b); if(b&gt;=0)&#123; q.pu_b(pii(a,b)); &#125;else&#123; w.pu_b(pii(a,b)); &#125; &#125; sort(q.begin(),q.end()); sort(w.begin(),w.end(),cmp); int ans=0; for(auto i:q)&#123; if(r&gt;=i.fi)&#123; r+=i.se; ans++; &#125;else&#123; break; &#125; &#125; int maxx=0; for(auto i:w)&#123; for(int j=max(i.fi,-i.se);j&lt;=r;j++)&#123; dp[j+i.se]=max(dp[j]+1,dp[j+i.se]); maxx=max(dp[j+i.se],maxx); &#125; &#125; out(ans+maxx,1); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校-Day1]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-Day1%2F</url>
    <content type="text"><![CDATA[B. Integration题意已知 $\Large \int_{0}^{\infty} \frac{1}{1+x^{2}} \mathrm{d} x=\frac{\pi}{2}$ ，求 $\Large\frac{1}{\pi} \int_{0}^{\infty} \frac{1}{\prod_{i=1}^{n}\left(a_{i}^{2}+x^{2}\right)} \mathrm{d} x$ 题解由 $\large\frac 1 a\times \frac 1 b=(\frac 1 a-\frac 1 b)\times \frac 1 {(b-a)}$ ，获得启发，化乘为加，令 $\large c_i=\prod\limits_{j\ne i}\frac 1 {a_j^2-a_i^2}$ ，则 $\large\prod \frac 1 {(a_i^2+x^2)}=\sum \frac {c_i}{a_i^2+x^2}$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d ",*ptr);&#125;void outln(initializer_list&lt;int&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d\n",*ptr);&#125;void out(initializer_list&lt;ll&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld ",*ptr);&#125;void outln(initializer_list&lt;ll&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld\n",*ptr);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln? '\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln? '\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln? '\n':' ');&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e3;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int a[N];ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; while(~in(n))&#123; for1(i,n)in(a[i]); // if(n==1)&#123; // out(qPow(2ll*a[1],mod-2,mod),1); // continue; // &#125; ll ans=0; for1(i,n)&#123; ll tm=1; for1(j,n)&#123; if(j!=i)&#123; tm=tm*((1ll*a[j]*a[j]%mod-1ll*a[i]*a[i]%mod+mod)%mod)%mod; // tm=tm*qPow((1ll*a[j]*a[j]%mod-1ll*a[i]*a[i]%mod+mod)%mod,mod-2,mod)%mod; &#125; &#125; ans=(ans+qPow(2*a[i],mod-2,mod)*qPow(tm,mod-2,mod)%mod)%mod; &#125; out(ans,1); &#125; return 0;&#125; C. Euclidean Distance题意给一个点 $(\frac {a_1} m,\frac {a_2} m,\cdots,\frac {a_n} m)(-m\le a_i\le m)$ ，找到一个点 $P(p_1,p_2,\cdots,p_n)(p_i\ge 0,\sum p_i=1)$ 使得 $\sum (\frac {a_i}m-p_i)^2$ 最小 题解对 $a_i$ 排序，逐渐减小最大的 $a_i$ ，使得序列的最大值尽可能小 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970bool cmp(int x,int y)&#123; return x&gt;y;&#125;ll gcd(ll x,ll y)&#123; return y?gcd(y,x%y):x;&#125;struct fraction&#123; ll son, mom; fraction()&#123;&#125; fraction(ll a,ll b)&#123; if(a)&#123;ll gc=gcd(abs(a),abs(b));if(b&lt;0) son=-a/gc,mom=-b/gc;else son=a/gc,mom=b/gc;&#125; else son=0,mom=1; &#125; bool operator==(const fraction &amp;x)const&#123; return son==x.son&amp;&amp;mom==x.mom; &#125; bool operator!=(const fraction &amp;x)const&#123; return !(son==x.son&amp;&amp;mom==x.mom); &#125; bool operator&lt;(const fraction &amp;y)const&#123; return son * y.mom &lt; y.son * mom; &#125; bool operator&lt;=(const fraction &amp;y)const&#123; return son * y.mom &lt;= y.son * mom; &#125; fraction operator*(const fraction &amp;y)const&#123; return fraction(son*y.son,mom*y.mom); &#125; fraction operator+(const fraction &amp;y)const&#123; return fraction(son * y.mom + y.son * mom,mom*y.mom); &#125; fraction operator/(const fraction &amp;y)const&#123; return fraction(son*y.mom,mom*y.son); &#125; fraction operator-(const fraction &amp;y)const&#123; return fraction(son * y.mom - y.son * mom,mom*y.mom); &#125; void display()&#123; if(mom==1)printf("%lld\n",son); else printf("%lld/%lld\n",son,mom); &#125;&#125;;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,a[N]; while(~in(n))&#123; in(m); for0(i,n)in(a[i]); sort(a,a+n,cmp); int remain=m; int i=1; for(;i&lt;n;i++)&#123; if(i*(a[i-1]-a[i])&lt;=remain)&#123; remain-=i*(a[i-1]-a[i]); &#125;else break; &#125; fraction ans=fraction(i*a[i-1]*a[i-1]-2*remain*a[i-1],1)+fraction(remain*remain,i); for(;i&lt;n;i++)&#123; ans=ans+fraction(a[i]*a[i],1); &#125; ans=ans/fraction(m*m,1); ans.display(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校-Day4]]></title>
    <url>%2F2019%2F08%2F09%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-Day4%2F</url>
    <content type="text"><![CDATA[I. String题意定义两个字符串不等为 $a\ne b \&amp;\&amp; a\ne rev(b) $ 给一个字符串，问由它的子串构成的 任意两个元素都不等 的最大集合有多大 题解显然答案为 $a,rev(a)$ 中本质不同的子串的数量除 2，注意若子串为回文串则只被计了一次，所以还需要加上一个 $a$ 中本质不同回文串的数量再除 2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117int t1[N],t2[N],c[N],srank[N],height[N],sa[N];bool cmp(int *r,int a,int b,int l)&#123; return r[a] == r[b] &amp;&amp; r[a+l] == r[b+l];&#125;void DA(int str[],int n,int m)&#123;//m为字符串中的最大值+1 n++; int i, j, p, *x = t1, *y = t2; //第一轮基数排序，如果s 的最大值很大，可改为快速排序 for(i = 0;i &lt; m;i++)c[i] = 0; for(i = 0;i &lt; n;i++)c[x[i] = str[i]]++; for(i = 1;i &lt; m;i++)c[i] += c[i-1]; for(i = n-1;i &gt;= 0;i--)sa[--c[x[i]]] = i; for(j = 1;j &lt;= n; j &lt;&lt;= 1)&#123; p = 0; //直接利用sa 数组排序第二关键字 for(i = n-j; i &lt; n; i++)y[p++] = i;//后面的j 个数第二关键字为空的最小 for(i = 0; i &lt; n; i++)if(sa[i] &gt;= j)y[p++] = sa[i] - j;//这样数组y保存的就是按照第二关键字排序的结果 //基数排序第一关键字 for(i = 0; i &lt; m; i++)c[i] = 0; for(i = 0; i &lt; n; i++)c[x[y[i]]]++; for(i = 1; i &lt; m;i++)c[i] += c[i-1]; for(i = n-1; i &gt;= 0;i--)sa[--c[x[y[i]]]] = y[i];//根据sa 和x 数组计算新的x 数组 swap(x,y); p = 1; x[sa[0]] = 0; for(i = 1;i &lt; n;i++)x[sa[i]] = cmp(y,sa[i-1],sa[i],j)?p-1:p++; if(p &gt;= n)break; m = p;//下次基数排序的最大值 &#125; int k = 0; n--; for(i = 0;i &lt;= n;i++)srank[sa[i]] = i; for(i = 0;i &lt; n;i++)&#123; if(k)k--; j = sa[srank[i]-1]; while(str[i+k] == str[j+k])k++; height[srank[i]] = k; &#125;&#125;const int C = 26;struct Palindromic_Tree &#123; int next[N][C] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[N] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[N] ;//cnt[i]表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的） int num[N] ;//num[i]表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数。 int len[N] ;//len[i]表示节点i表示的回文串的长度 int S[N] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int newnode ( int l ) &#123;//新建节点 for ( int i = 0 ; i &lt; C ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125; PAM;int r[N];char s[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(s); ll n=strlen(s); s[n]='`'; PAM.init(); for0(i,n) &#123; s[2*n-i]=s[i]; PAM.add(s[i]); &#125; ll m=2*n+1; for0(i,m)r[i]=s[i]-'`'+1; r[m]=0; DA(r,m,30); ll ans=PAM.p-2+m*(m+1)/2-(n+1)*(n+1); for(int i=2;i&lt;=m;i++)ans-=height[i]; outln(ans/2); return 0;&#125;]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6635]]></title>
    <url>%2F2019%2F08%2F08%2FHDU-6635%2F</url>
    <content type="text"><![CDATA[题意给两个排列 $a , b$ ，$a$ 一开始全都封闭，从左到右遍历 $b$ ，每次释放一个 $\Large a_{b_i}$ ，问每个时刻，释放后的序列 $a$ 的 $LIS$ 题解考虑时间倒流， 看作一个完整的排列按照一定顺序依次删除每个数， 然后每次需要计算 $LIS$ 的长度。 首先在 $O(n log n) $ 的时间内求出 $LIS$，并找到任意一个 $LIS$。当删除 x 时，如果 x 不在之前找 到的那个 LIS 中，那么显然 LIS 的长度是不会变化的，否则暴力重新计算出新的 LIS 即可。因为数据随机，因此 LIS 的期望长度是 $O( \sqrt n)$，删除的 x 位于 LIS 中的概率是 $\frac 1 {\sqrt n}$ ，也就是说期望时间复杂度为$O(n \sqrt n log n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e4;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],pre[N],b[N],ans[N],cnt,n,pp[N],pr[N];bool vis[N],cho[N];void redo()&#123; cnt=0; mem0(cho); int last=0; for1(i,n)&#123; if(!vis[i])&#123; int posi=upper_bound(pre+1,pre+1+cnt,a[i])-pre; // printf("sa%d %d\n",i,a[i]); if(posi==cnt+1)&#123; pre[++cnt]=a[i]; pr[cnt]=i; pp[i]=pr[cnt-1]; last=i; // printf("sa%d\n",i); // sta[cnt].push(i); &#125;else &#123; pre[posi]=a[i]; pr[posi]=i; pp[i]=pr[posi-1]; // no[i]=posi; // sta[posi].push(i); &#125; &#125; &#125; while(last)&#123; cho[last]=1; // out(last); last=pp[last]; &#125; // puts("");&#125;void del(int x)&#123; vis[x]=1; if(cho[x])redo();&#125;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; in(t); whiel(t--)&#123; in(n); mem0(vis); for1(i,n)in(a[i]); for1(i,n)in(b[i]); redo(); for(int i=n;i&gt;0;i--)&#123; ans[i]=cnt; del(b[i]); &#125; for1(i,n)&#123; if(i==n)outln(ans[i]); else out(ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客-MaxAnswer]]></title>
    <url>%2F2019%2F08%2F08%2F%E8%AE%A1%E8%92%9C%E5%AE%A2-MaxAnswer%2F</url>
    <content type="text"><![CDATA[题意求数组的一个子区间，使得 子区间之和 乘以 子区间最小值 最大，求最大值 题解权值可能为负，分别考虑正负，正数使用但单调栈，负数求出最小连续子段和乘以该子段的最小值 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e5;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;stack&lt;pll&gt;sta; int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; ll x; in(n); ll ans=0,minn=0,tot=0; for0(i,n)&#123; in(x); if(tot+x&gt;0)&#123; tot=minn=0; &#125;else&#123; minn=min(minn,x); tot+=x; ans=max(ans,minn*tot); &#125; if(x&lt;=0)&#123; ll tmp=0; whiel(sta.size())&#123; tmp+=sta.top().se; ans=max(ans,sta.top().fi*tmp); sta.pop(); &#125; &#125;else&#123; ll tmp=0; while(sta.size()&amp;&amp;x&lt;=sta.top().fi)&#123; tmp+=sta.top().se; ans=max(ans,sta.top().fi*tmp); sta.pop(); &#125; sta.push(pll(x,tmp+x)); &#125; &#125; ll tmp=0; whiel(sta.size())&#123; tmp+=sta.top().se; ans=max(ans,sta.top().fi*tmp); sta.pop(); &#125; outln(ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019-牛客多校-Day5]]></title>
    <url>%2F2019%2F08%2F08%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-Day5%2F</url>
    <content type="text"><![CDATA[C. generator 2题意给出 $n, x_{0}, a, b, p \quad\left(1 \leq n \leq 10^{18}, 0 \leq x_{p}, a, b&lt;p \leq 10^{9}+9,\text{p is a prime number}\right)$ ，$q$次询问，问在序列 $x_0,x_1,\cdots,x_{n-1}$ 中最小的 $i$ ，使得 $x_i=v$ 题解需要手写Hash，对于 GSBS 中的 $c_im-r_i$ ，因为有多组，且 $a,p$ 都不变，我们可以预处理 $\large a^{im}$ ，每组样例的时间复杂度为 $\frac p m+qm $ ，所以 $m=\sqrt{\frac p q}$ 时，总的时间复杂度最小 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;struct Hash &#123; static const int MOD = 2e6+7; static const int N = 2e6; ll head[MOD + 10], nx[N], top; ll hs[N], id[N]; void init() &#123; memset(head, -1, sizeof head); top = 0; &#125; void insert(ll x, ll y) &#123;//x-key y-val ll k = x % MOD; hs[top] = x; id[top] = y; nx[top] = head[k]; head[k] = top++; &#125; ll find(ll x) &#123; ll k = x % MOD; for (int i = head[k]; i != -1; i = nx[i]) &#123; if (hs[i] == x) &#123; return id[i]; &#125; &#125; return -1; &#125;&#125;hs;ll m,n;ll BSGS(ll a, ll b, ll p) &#123; // a^x == b (mod p) if(b==1)return 0; ll ans=p-1; for (ll i = 0; i &lt; m; ++i) &#123; if(hs.find(b)&gt;=0)&#123; ans=min(ans,hs.find(b)-i); &#125; b = b * a % p; &#125; if(ans==p-1||ans&gt;=n) return -1; else return ans;&#125;int main() &#123; int t,x,a,b,q; ll p; ll v; in(t); whiel(t--)&#123; in(n); in(x,a,b); in(p); in(q); if(a==1)&#123; while(q--)&#123; in(v); ll an=(v-x+p)%p*qPow(b,p-2,p)%p; if(an&lt;n)outln(an); else outln(-1); &#125; &#125;else if(a==0)&#123; while(q--)&#123; in(v); if(v==x)outln(0); else if(v==b&amp;&amp;n&gt;1)outln(1); else outln(-1); &#125; &#125;else&#123; m = ceil(sqrt(1.0*p/q)); ll tt = qPow(a,m,p), vv= 1; hs.init(); for ( ll i = 1; ; ++i) &#123; vv = vv * tt % p; if(hs.find(vv)==-1) hs.insert(vv,i*m); if(i*m&gt;=p)break; &#125; while(q--)&#123; in(v); ll c=b*qPow(a-1,p-2,p)%p; v=(v+c)%p*qPow(x+c,p-2,p)%p; outln(BSGS(a,v,p)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6592]]></title>
    <url>%2F2019%2F08%2F07%2FHDU-6592%2F</url>
    <content type="text"><![CDATA[题意给一个序列 $a[]$ ，找出最长的单峰序列，输出该序列的下标，输出字典序最大和最小的情况 题解易证，当取第一个峰的时候字典序最小，当取最后一个峰的时候字典序最大。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3.1e5;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],f[N],g[N],pre[N],ans[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; while(~in(n))&#123; for1(i,n)in(a[i]); int len=0; for1(i,n)&#123; int posi=upper_bound(pre+1,pre+1+len,a[i])-pre; // out(posi); if(posi==len+1)&#123; if(a[i]&gt;pre[len])&#123; pre[++len]=a[i]; f[i]=len; &#125;else f[i]=len; &#125;else&#123; if(a[i]&gt;pre[posi-1])&#123; pre[posi]=a[i]; f[i]=posi; &#125;else&#123; f[i]=posi-1; &#125; &#125; &#125; // puts(""/); len=0; for1(i,n)&#123; int j=n-i+1; int posi=upper_bound(pre+1,pre+1+len,a[j])-pre; if(posi==len+1)&#123; if(a[j]&gt;pre[len])&#123; pre[++len]=a[j]; g[j]=len; &#125;else g[j]=len; &#125;else&#123; if(a[j]&gt;pre[posi-1])&#123; pre[posi]=a[j]; g[j]=posi; &#125;else&#123; g[j]=posi-1; &#125; &#125; &#125; int maxx=0,Fi=0,La=0; for1(i,n)maxx=max(maxx,f[i]+g[i]-1); for1(i,n)&#123; if(f[i]+g[i]-1==maxx)&#123; if(!Fi)Fi=i; La=i; &#125; &#125; int tail=f[Fi]; ans[tail]=Fi; for(int i=Fi-1;i&gt;0;i--)&#123; if(f[i]+1&gt;=tail&amp;&amp;f[i]&lt;f[Fi])&#123; if(a[ans[f[i]+1]]&gt;a[i])&#123; tail=f[i]; ans[f[i]]=i; &#125; &#125; &#125; // assert(tail==1); tail=f[Fi]; // cout&lt;&lt;tail&lt;&lt;endl; for(int i=Fi+1;i&lt;=n;i++)&#123; if(a[i]&lt;a[ans[tail]]&amp;&amp;g[i]+1==g[ans[tail]])&#123; ans[++tail]=i; &#125; &#125; for1(i,maxx)&#123; printf("%d%c",ans[i]," \n"[i==maxx]); &#125; tail=maxx-g[La]+1; ans[tail]=La; for(int i=La+1;i&lt;=n;i++)&#123; if(g[i]+tail&gt;=maxx&amp;&amp;g[i]&lt;g[La])&#123; if(a[ans[maxx-g[i]]]&gt;a[i])&#123; tail=maxx-g[i]+1; ans[tail]=i; &#125; &#125; &#125; // assert(tail==maxx); tail=maxx-g[La]+1; for(int i=La-1;i&gt;0;i--)&#123; if(a[i]&lt;a[ans[tail]]&amp;&amp;f[i]+1==f[ans[tail]])&#123; ans[--tail]=i; &#125; &#125; for1(i,maxx)&#123; printf("%d%c",ans[i]," \n"[i==maxx]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1195E]]></title>
    <url>%2F2019%2F07%2F29%2FCF-1195E%2F</url>
    <content type="text"><![CDATA[题意给一个 $nm(1 \leq n, m \leq 3000)$ 的矩阵，求每一个 $ab$ 的子矩阵中最小值之和 题解先求出每一行长度为 $b$ 的序列的最小值，再求每一列长度为 $a$ 的序列的最小值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3.1e3;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125; int minn[N][N],h[N][N],q[N];// q[i]表示从 i 开始长度为 len 的序列中的最小值的下标ll ans;void fun(int x,int n,int a)&#123; int l=1,r=0; for1(i,n)&#123; whiel(i-q[l]+1&gt;a&amp;&amp;l&lt;=r)l++; while(h[x][q[r]]&gt;h[x][i]&amp;&amp;l&lt;=r)r--; q[++r]=i; // cout&lt;&lt;i&lt;&lt;' '&lt;&lt;l&lt;&lt;' '&lt;&lt;q[l]&lt;&lt;endl; minn[x][i]=h[x][q[l]]; &#125;&#125;void fun2(int x,int n,int a)&#123; int l=1,r=0; for(int i=1;i&lt;=n;i++)&#123; whiel(i-q[l]+1&gt;a&amp;&amp;l&lt;=r)l++; while(minn[q[r]][x]&gt;minn[i][x]&amp;&amp;l&lt;=r)r--; q[++r]=i; if(i&gt;=a) ans+=minn[q[l]][x]; // minn[x][i]=h[x][q[l]]; &#125;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,a,b,g,x,y,z; in(n,m,a,b); in(g,x,y,z); for0(i,n*m)&#123; h[i/m+1][i%m+1]=g; g=(1ll*g*x+y)%z; &#125; // for1(i,n)&#123; // for1(j,m)&#123; // out(h[i][j]); // &#125; // puts(""); // &#125; for1(i,n)&#123; fun(i,m,b); &#125; // for1(i,m)out(minn[1][i]); // puts(""); for(int i=b;i&lt;=m;i++)&#123; fun2(i,n,a); &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1189E]]></title>
    <url>%2F2019%2F07%2F06%2FCF-1189E%2F</url>
    <content type="text"><![CDATA[E. Count Pairs题意You are given a prime number $p, n$ integers $a_{1}, a_{2}, \ldots, a_{n}(all a_i are different),$ and an integer $k$ Find the number of pairs of indexes $(i, j)(1 \leq i&lt;j \leq n)$ for which $\left(a_{i}+a_{j}\right)\left(a_{i}^{2}+a_{j}^{2}\right) \equiv k \bmod p$ 题解 (a_i-a_j)(a_i+a_j)(a_i^2+a_j^2)\equiv (a_i-a_j)k\ \bmod p\\ a_i^4-ka_i\equiv a_j^4-ka_j\bmod p代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125; unordered_map&lt;int,int&gt;m; int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,p,k; ll a; in(n,p,k); for0(i,n)&#123; in(a); a=((a*a%p*a%p*a%p-a*k%p)%p+p)%p; m[a]++; &#125; ll ans=0; for(auto i:m)&#123; ans+=1l*i.se*(i.se-1)/2; &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1183F]]></title>
    <url>%2F2019%2F06%2F30%2FCF-1183F%2F</url>
    <content type="text"><![CDATA[题意给 $n$ 个数，选至多 $3$ 个，且两两不为倍数关系，问最大值是多少 题解排序，若最大值不取 $a_n$，那只有一种可能 $\frac 1 2 a_n ,\frac 1 3 a_n,\frac 1 5 a_n $，因为如果最大值包含不为 a_n 的因子，那么显然取 a_n 更优。易证，若取 $a_n$ ，一定会取 不为 $a_n$ 因子的最大值， 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125; int a[N];unordered_set&lt;int&gt;s;int main() &#123; int q,n; in(q); while(q--)&#123; in(n); for0(i,n)&#123; in(a[i]); s.insert(a[i]); &#125; sort(a,a+n); n=unique(a,a+n)-a; int maxx=a[n-1]; int tmp=maxx; if(maxx%2==0&amp;&amp;maxx%3==0&amp;&amp;maxx%5==0&amp;&amp;s.count(maxx/2)&amp;&amp;s.count(maxx/3)&amp;&amp;s.count(maxx/5))&#123; maxx=maxx/30*31; &#125; for(int i=n-2;i&gt;=0;i--)&#123; if(tmp%a[i])&#123; for(int j=i-1;j&gt;=0;j--)&#123; if(tmp%a[j]&amp;&amp;a[i]%a[j])&#123; tmp+=a[j]; break; &#125; &#125; tmp+=a[i]; break; &#125; &#125; outln(max(maxx,tmp)); s.clear(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1183G]]></title>
    <url>%2F2019%2F06%2F28%2FCF-1183G%2F</url>
    <content type="text"><![CDATA[G. Candy Box (hard version)题意$q(1\le q\le 2e5)$ 次询问，每次询问$n(1\le n\le 2e5)$ 个物体，每个物体的种类为 $a_i(1\le a_i\le n)$，喜欢与否为 $f_i(0\le f_i\le1)$，要尽量取多的物体，要求每种物体的数量不同，在保证数量最多的情况下，要让喜欢的最少 题解按种类数排序，总数记为 $x_i$ ，$f=0$ 的数量为 $y_i$，从 $n-&gt;1$ 扫描，对于当前 $i$，将满足条件的 $y_i$ 加入优先队列 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;pii a[N];priority_queue&lt;int&gt;Q;int main() &#123; itn q,n,x,y; in(q); whiel(q--)&#123; in(n); for0(i,n)&#123; in(x,y); a[x].fi++; a[x].se+=y; &#125; sort(a+1,a+n+1); ll an1=0,an2=0; int id=n; for(itn i=n;i;i--)&#123; while(id&amp;&amp;a[id].fi&gt;=i)&#123; Q.push(a[id--].se); &#125; if(Q.size())&#123; an1+=i; an2+=min(i,Q.top()); Q.pop(); &#125; &#125; for1(i,n)a[i]=pii(0,0); whiel(Q.size())Q.pop(); out(an1); outln(an2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6223]]></title>
    <url>%2F2019%2F06%2F18%2FHDU-6223%2F</url>
    <content type="text"><![CDATA[题意长度为 $n(1\le n \le 2e6)$ 的数组 $(0\le a_i\le 9)$, 下标为 $[0,n-1]$ , 你要取 $n$ 个数构成一个长度为 $n$ 的数组 $b$ , 假设第一次选 $a[i]$ , 则 $b[1]=a[i], b[2]=a[(i^2+1)\%n],\cdots$ 输出字典序最小的 $b$ 题解显然取的下标序列存在循环节, 由打表可知, 循环节的长度不会超过 $21$, 所以我们只用枚举前 $21*20$ (循环节的最大$lcm$)位就可以找到保证 $b$ 字典序最小的起始点, 好像数据太水了,只用枚举前 21​ 位就可以了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.6e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;char s[N],ans[N];int main() &#123; int t,n; in(t); for1(ca,t)&#123; in(n); in(s); printf("Case #%d: ",ca); ll loo; for0(i,n)ans[i]='0'; for0(i,n)&#123; bool yes=0; ll ti=i; for0(j,22)&#123; if(s[ti]&lt;ans[j])&#123; if(yes)ans[j]=s[ti]; else break; &#125;else if(s[ti]&gt;ans[j])&#123; yes=1; ans[j]=s[ti]; &#125; ti=(ti*ti+1)%n; &#125; if(yes)loo=i; &#125; for0(i,n)&#123; putchar(s[loo]); loo=(loo*loo+1)%n; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客-LIS]]></title>
    <url>%2F2019%2F06%2F17%2F%E8%AE%A1%E8%92%9C%E5%AE%A2-LIS%2F</url>
    <content type="text"><![CDATA[题意从长度为 $n(\le 5e5)$ 的数组中等概率的取出一个最长上升子序列, 求每个数被选中的概率 题解$bg[i]$ 是以 $a[i]$ 为起点的 $LIS$ 的长度, $g[i]$ 是以 $a[i]$ 为起点的 $LIS$ 的数量 $en[i]$ 是以 $a[i]$ 为终点的 $LIS$ 的长度, $h[i]$ 是以 $a[i]$ 为终点的 $LIS$ 的数量 $\text{len_a}[i]$ 是以 $i$ 为起点或终点的 $LIS$ 的长度, $\text{cnt_a}[i]$ 是以 $i$ 为起点或终点的 $LIS$ 的数量 $\text{len_h}[i],\text{cnt_h}[i] $ 是树状数组的辅助数组 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e5;const ll mod = 998244353;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int bg[N],g[N],en[N],h[N],a[N],b[N],len_h[N],len_a[N],cnt_h[N],cnt_a[N];//cnt[i]极大值树,len[i]int lowbit(int x)&#123; return x&amp;(-x);&#125;void Update(int x,int y,int z,int n)&#123; if(len_a[x]==y)&#123; cnt_a[x]=(cnt_a[x]+z)%mod; &#125;else&#123; len_a[x]=y;; cnt_a[x]=z; &#125; int lx; while(x&lt;=n)&#123; len_h[x]=len_a[x]; cnt_h[x]=cnt_a[x]; lx = lowbit(x); for (int i=1; i&lt;lx; i&lt;&lt;=1) if(len_h[x-i]&gt;len_h[x])&#123; len_h[x]=len_h[x-i]; cnt_h[x]=cnt_h[x-i]; &#125;else if(len_h[x-i]==len_h[x])cnt_h[x]=(cnt_h[x]+cnt_h[x-i])%mod; // mx[x] = max(mx[x], len[x-i]); x += lowbit(x); &#125;&#125;pii query(int l,int r)&#123;//返回 （以[l,r]结尾的最长LIS , 以[l,r]结尾的最长LIS的数量) int ans = 0; int tl=l,tr=r; while(r &gt;= l)&#123; ans = max(ans,len_a[r]); r--; for(;r-lowbit(r)&gt;= l ;r-=lowbit(r))ans = max(ans,len_h[r]); &#125; l=tl;r=tr; int tot=0; while(r &gt;= l)&#123; // ans = max(ans,len_a[r]); if(len_a[r]==ans)tot=(tot+cnt_a[r])%mod; r--; for(;r-lowbit(r)&gt;= l ;r-=lowbit(r))&#123; if(len_h[r]==ans)tot=(tot+cnt_h[r])%mod; // ans = max(ans,len_h[r]); &#125; &#125; return pii(ans,tot);&#125;int qpow(ll a,ll b)&#123; ll ans=1; a%=mod; while(b)&#123; if(b%2)ans=ans*a%mod; a=a*a%mod; b/=2; &#125; return ans;&#125;int main() &#123; int n; in(n); for0(i,n)&#123; in(a[i]); b[i]=a[i]; &#125; sort(b,b+n); for0(i,n)a[i]=lower_bound(b,b+n,a[i])-b+1; int L=0; pii tmp; for0(i,n)&#123; tmp=query(1,a[i]-1); en[i]=tmp.fi+1; L=max(L,en[i]); h[i]=tmp.se; if(en[i]==1)h[i]=1; Update(a[i],en[i],h[i],n); &#125; mem0(cnt_a);mem0(cnt_h);mem0(len_a);mem0(len_h); int tot=0; for(int i=n-1;i&gt;=0;i--)&#123; tmp=query(a[i]+1,n); bg[i]=tmp.fi+1; g[i]=tmp.se; if(bg[i]==1)g[i]=1; if(bg[i]==L)tot=(tot+g[i])%mod; Update(a[i],bg[i],g[i],n); &#125; tot=qpow(tot,mod-2); for0(i,n)&#123; if(bg[i]+en[i]==L+1)&#123; out(1ll*h[i]*g[i]%mod*tot%mod); &#125;else out(0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计蒜客</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>binary indexed tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6189]]></title>
    <url>%2F2019%2F06%2F12%2FHDU-6189%2F</url>
    <content type="text"><![CDATA[题意给出 $n(\le 30), a(1\le a\le 1e9)$ , 求在 $[1,2^n]$ 范围内有多少个 $b$ 能够满足 $a^{b} \equiv b^{a}(\bmod 2^n)$ 题解 https://blog.csdn.net/hyesuixin/article/details/77855821 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; int n,a; whiel(~in(n,a))&#123; int ta=a,k=0,maxn=1&lt;&lt;n; whiel(ta%2==0)&#123; k++; ta/=2; &#125; if(k&amp;&amp;n)&#123; itn kk=n/a; if(n%a)kk++; int ans=0; int low=n/k; if(n%k==0)low--; for1(i,low)&#123; if(qPow(a,i,maxn)==qPow(i,a,maxn))ans++; &#125; kk=1&lt;&lt;kk; ans+=(1&lt;&lt;n)/kk-low/kk; outln(ans); &#125;else &#123; puts("1"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1176D]]></title>
    <url>%2F2019%2F06%2F12%2FCF-1176D%2F</url>
    <content type="text"><![CDATA[题意 题解排序, 从大到小处理, 若当前最大的为素数, 那它一定是 $b$, 若当前最大数为合数, 那它一定是 $a$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3e6;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int Div[N];int prime[N],num_prime=0;void get_prime()&#123; for(int i=2;i&lt;N;i++)&#123; if(!Div[i]) &#123; prime[num_prime++]=i; Div[i]=-num_prime; &#125; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;N;j++)&#123; int k = i*prime[j]; Div[k] = i; if(i % prime[j] == 0) break; &#125; &#125;&#125;itn n,a[400005],cnt[N];int main() &#123; get_prime(); in(n); for0(i,2*n)&#123; in(a[i]); cnt[a[i]]++; &#125; sort(a,a+2*n); for(int i=2*n-1;i&gt;=0;i--)&#123; if(cnt[a[i]])&#123; if(Div[a[i]]&gt;0)&#123; out(a[i]); cnt[a[i]]--; cnt[Div[a[i]]]--; &#125;else&#123; int tmp=-Div[a[i]]; out(tmp); cnt[tmp]--; cnt[a[i]]--; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>greedy</tag>
        <tag>number theory</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客-数组]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%AE%A1%E8%92%9C%E5%AE%A2-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题意给出长度为 $N$ 的数组 $A$, 定义 f(l, r)=\max \left(\max \left(A_{l}, A_{l+1} \ldots A_{x}\right) \cdot(r-x+1) \cdot[l \leq x \leq r]\right)求 \sum_{i=1}^{n} \sum_{j=i}^{n} f(i, j) \bmod 10^{9}+7 题解从后往前枚举 $i$ , 用一个单调栈来存在固定 $i$ 的时候, $j\in[i,n]$ , 不同 $j$ 的 $x$ 的取值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int a,r,pre,i; //r 表示取 a 的 j 的区间的右端点 da(int _a,int _r,int _p,ll _i)&#123; a=_a; r=_r; pre=_p; i=_i; &#125; da()&#123;&#125;&#125;;stack&lt;da&gt;sta;ll fun(itn a,int l,int r)&#123; return (r-l+1ll)*(l+r)/2%mod*a%mod;&#125;int a[N];int main() &#123; itn n; ll ans=0; in(n); for1(i,n)&#123; in(a[i]); &#125; for(int i=n;i&gt;0;i--)&#123; ll r=n; whiel(sta.size())&#123; da tmp=sta.top(); if(tmp.a&lt;=a[i])&#123; sta.pop(); &#125;else&#123; ll p=(tmp.a*1ll*tmp.i-tmp.a+a[i]-a[i]*1ll*i)/(tmp.a-a[i]); if(p&gt;=tmp.r)&#123; sta.pop(); &#125;else&#123; r=p; break; &#125; &#125; &#125; // cout&lt;&lt;i&lt;&lt;' '&lt;&lt;r&lt;&lt;"\n"; assert(r&lt;=n); // assert(r&gt;=) int pre=0; if(sta.size())&#123; da tmp=sta.top(); // cout&lt;&lt;tmp.a&lt;&lt;' '&lt;&lt;tmp.i&lt;&lt;endl; pre=tmp.pre; // assert(r&gt;=tmp.i); pre=(pre+fun(tmp.a,r-tmp.i+2,tmp.r-tmp.i+1))%mod; &#125; // cout&lt;&lt;endl; sta.push(da(a[i],r,pre,i)); ans=(ans+pre+fun(a[i],1,r-i+1))%mod; &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>计蒜客</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1175D]]></title>
    <url>%2F2019%2F06%2F07%2FCF-1175D%2F</url>
    <content type="text"><![CDATA[Array Splitting题意将一个长度为 $n$ 的序列 $a_i$ 顺序不变的分为非空的 $k$ 部分, 设 $f(i)$ 表示 $a_i$ 在第 $f(i)$ 部分 求 $\sum\limits_{i=1}^na_i*f(i)$ 题解在 $[1,n]$ 中选 $k$ 个点 $b_i$ (其中一个为 1)将序列分为 $k$ 份, 答案为 $\sum\limits_{i=1}^ksuf[i]$ , $suf[i]$ 表示从 $i$ 开始的后缀和 所以直接对后缀排序, 取最大的 $k$ 个 代码1234567891011121314151617181920int a[N];ll suf[N];bool cmp(ll x,ll y)&#123; return x&gt;y;&#125;int main() &#123; int n,k; in(n,k); for0(i,n)in(a[i]); for(itn i=n-1;i&gt;=0;i--)&#123; suf[i]=suf[i+1]+a[i]; &#125; sort(suf+1,suf+n,cmp); ll ans=0; for0(i,k)&#123; ans+=suf[i]; &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1174E]]></title>
    <url>%2F2019%2F06%2F06%2FCF-1174E%2F</url>
    <content type="text"><![CDATA[Ehab and the Expected GCD Problem题意定义 $f(p)$ 表示 一个排列 $p$ 的 $g_1,g_2 \cdots g_n$ 的种类数, $g_i$ 表示该排列前 $i $ 个数的 $gcd$ $f_{max}(n)$ 表示 $n$ 的排列的最大 $f$ 值 给 $n$ 求 $f(p)=f_{max}(n)$ 的方案数 题解显然 要让 $f$ 最大, 排列的第一个数为 $2^k$ 或 $2^{k-1}3$ , 设 $dp[i][x][t]$ 表示前 $i$ 个数的 $gcd$ 为 $\large 2^{x} 3^y$ 的方案数 dp[i][x][y]=dp[i-1][x][y]*max(f[x][y]-i+1,0)+\\dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])+dp[i-1][x][y+1]*(f[x][y]-f[x][y+1]$f[x][y]$ 表示 $\Large \lfloor \frac n {2^x*3^y}\rfloor$ , 答案为 $dp[n][0][0]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int dp[N][21][3];int n;int f[21][3];int pp[N];int main() &#123; in(n); ll pre=1; for1(i,N)&#123; pre=pre*i%mod; pp[i]=pre; &#125; for0(i,21) for0(j,3)&#123; f[i][j]=n/((1&lt;&lt;i)*pow(3,j)); &#125; if(n&lt;4)&#123; if(n==2)puts("1"); else if(n==3)puts("4"); return 0; &#125; int k=0,tn=n; while(tn)&#123; tn/=2; k++; &#125; k--; dp[1][k][0]=1; if((1&lt;&lt;(k-1))*3&lt;=n)dp[1][k-1][1]=1; itn i,cnt; for(i=2;i&lt;=n;i++)&#123; itn x,y; cnt=0; for0(j,k)&#123; x=j; y=0; dp[i][x][y]=(1ll*dp[i-1][x][y]*max(f[x][y]-i+1,0)%mod+1ll*dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])%mod+1ll*dp[i-1][x][y+1]*(f[x][y]-f[x][y+1])%mod)%mod; if(dp[i][x][y])cnt++; y=1; dp[i][x][y]=(1ll*dp[i-1][x][y]*max(f[x][y]-i+1,0)%mod+1ll*dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])%mod+1ll*dp[i-1][x][y+1]*(f[x][y]-f[x][y+1])%mod)%mod; if(dp[i][x][y])cnt++; &#125; if(dp[i][0][0]&amp;&amp;cnt==1)break; &#125; // outln(i); outln(1ll*dp[i][0][0]*pp[n-i]%mod); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6284]]></title>
    <url>%2F2019%2F06%2F04%2FHDU-6284%2F</url>
    <content type="text"><![CDATA[Longest Increasing Subsequence题意有一个长度为 $n$ 的数组 $a(0\le a_i\le n)$ ,$f(x)$ 表示把 $0$ 变成 $x$ , 序列的 $LIS(严格递增)$ , 求$\sum\limits_{i=1}^ni\times f(i)$ 题解设 $bg[i], en[i]$ 分别表⽰以点 $i$ 开始、结束的 $LIS$ ⻓度，$L$ 是原来的 $LIS$ ⻓度。对于每个 $i$，找出它下⼀个 $0$ 后⾯的 $a[j]$ 满⾜ $en[i]+bg[j] = L$，那么当 $x$ 在 $[a[i] + 1, a[j] − 1]$ 的区间内时，答案是 $L + 1$. 从后往前扫, 用一个数组 $\text{max_r[i]}$ 记录扫过的最后一个 $0$ 右边区域的 $bg=i$ 的最大值 以 $0$ 为分隔, 用一个 $vector$ 存当前分块的 $ \text{max_r}$ 值, 当遇到下一个 $0$ 的时候更新 $\text{max_r}$ , 注意当 $bg=L$ 时要特殊考虑 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const int inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],bg[N],en[N],dp[N],fu[N],max_r[N];vector&lt;pii&gt; peding;int l_bound(int l,int r,int x)&#123; r--; whiel(l&lt;=r)&#123; int mid=(l+r)/2; if(dp[mid]&gt;x)l=mid+1; else r=mid-1; &#125; return l;&#125;int main() &#123; itn n; whiel(~in(n))&#123; int L=0; for1(i,n)in(a[i]); for1(i,n)max_r[i]=fu[i]=0; for1(i,n)&#123; if(a[i])&#123; if(L)&#123; if(a[i]&gt;dp[L-1])&#123; dp[L++]=a[i]; en[i]=L; &#125;else&#123; int p=lower_bound(dp,dp+L,a[i])-dp; dp[p]=min(dp[p],a[i]); en[i]=p+1; &#125; &#125;else&#123; dp[L++]=a[i]; en[i]=L; &#125; &#125; &#125; L=max(L,1); ll ans=(1ll+n)*n/2*L; L=0; for(itn i=n;i&gt;0;i--)&#123; if(a[i])&#123; if(L)&#123; if(a[i]&lt;dp[L-1])&#123; dp[L++]=a[i]; bg[i]=L; &#125;else&#123; int p=l_bound(0,L,a[i]); dp[p]=max(dp[p],a[i]); bg[i]=p+1; &#125; &#125;else&#123; dp[L++]=a[i]; bg[i]=L; &#125; &#125; &#125; max_r[0]=0; peding.clear(); for(itn i=n;i&gt;0;i--)&#123; if(a[i])&#123; if(max_r[L-en[i]]&gt;a[i])&#123; fu[a[i]+1]++; fu[max_r[L-en[i]]]--; &#125; peding.pu_b(pii(bg[i],a[i])); &#125;else&#123; max_r[0]=n+1; whiel(peding.size())&#123; pii kk=peding.back(); peding.po_b(); if(kk.fi==L)&#123; fu[1]++; fu[kk.se]--; &#125;else&#123; max_r[kk.fi]=max(max_r[kk.fi],kk.se); &#125; &#125; &#125; &#125; for1(i,n)&#123; fu[i]+=fu[i-1]; if(fu[i])ans+=i; &#125; outln(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1174D]]></title>
    <url>%2F2019%2F06%2F04%2FCF-1174D%2F</url>
    <content type="text"><![CDATA[Ehab and the Expected XOR Problem题意给 $n(1\le n\le 18),x(1\le x&lt;2^{18})$ , 构造一个数组 $a(1\le a_i&lt;2^n)$ , 使得这个数组的任意子段的异或和不为 0 或 $x$ 题解要使得这个数组的任意子段的异或和不为 0, 只需要保证数组的前缀和都不同就可以了. 假设 $A\text^B=x$ , 可以将 $[0,2^n-1]$ 分为两部分, 没部分里面的数两两异或都不为 $x$ 代码12345678910111213141516171819202122232425262728bool vis[N];vii v;int main() &#123; int n,x; in(n,x); int p=(1&lt;&lt;n); if(x&gt;=p)&#123; outln(p-1); for1(i,p-1)&#123; out(i^(i-1)); &#125; &#125;else&#123; p-=2; outln(p/2); v.pu_b(0); vis[x]=1; for1(i,p+1)&#123; if(vis[i]==0)&#123; v.pu_b(i); vis[i]=vis[i^x]=1; &#125; &#125; for1(i,(int)v.size()-1)&#123; out(v[i]^v[i-1]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>implementation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1148E]]></title>
    <url>%2F2019%2F06%2F04%2FCF-1148E%2F</url>
    <content type="text"><![CDATA[Earth Wind and Fire题意给两个长度为 $n$ 个数组 $a,b$, 如果 $a_i\le a_j$ 可以取一个 $d(0\le 2*d\le a_j-a_i)$ , 然后 $a_i+d,a_j-d$ , 问如何操作可以让 $a$ 变为 $b$ 题解对 $a,b$ 排序, 将 $a_i$ 变为 $b_i$, 用一个 $stack$ 维护 $a$ 中待加值的元素 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758pii a[N];int b[N];bool cmp(pii x,pii y)&#123; return x.fi&lt;y.fi;&#125;struct da&#123; int i,j,d; da(int q,int w,int e)&#123; i=q;j=w;d=e; &#125;&#125;;vector&lt;da&gt;v;stack&lt;int&gt;les;int main() &#123; int n; in(n); for1(i,n)&#123; in(a[i].fi); a[i].se=i; &#125; for1(i,n)in(b[i]); sort(a+1,a+1+n,cmp); sort(b+1,b+n+1); bool yes=1; for1(i,n)&#123; if(a[i].fi&gt;b[i])&#123; a[i].fi-=b[i]; while(a[i].fi&amp;&amp;les.size())&#123; int no=les.top(); les.pop(); int minn=min(a[no].fi,a[i].fi); if(a[no].fi&gt;a[i].fi)les.push(no); a[i].fi-=minn; a[no].fi-=minn; v.pu_b(da(a[no].se,a[i].se,minn)); &#125; if(a[i].fi)&#123; yes=0; break; &#125; &#125;else if(a[i].fi&lt;b[i])&#123; a[i].fi=b[i]-a[i].fi; les.push(i); &#125; &#125; if(les.size()==0&amp;&amp;yes)&#123; puts("YES"); assert(v.size()&lt;=5*n); outln((int)v.size()); for(auto i:v)&#123; printf("%d %d %d\n",i.i,i.j,i.d); &#125; &#125;else &#123; puts("NO"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6285]]></title>
    <url>%2F2019%2F06%2F03%2FHDU-6285%2F</url>
    <content type="text"><![CDATA[题意在一个 $n$ 个点的完全图中，第 $i$ 个点的权值为 $2^i$，选择一些边，需要选择一些点使得所有边至少有一个端点被覆盖，同时权值之和最小。在上述情况下，给出选择的点的权值和，问有多少种选择边的方案符合这种选点。 题解对于每一个选定的点, 总有一条边连着它和权值比它大的未被选的点, 设数量为 $cnt1$, 权值比它小的点可取可不取, 设数量为 $cnt2$, 则该点的贡献为 (2^{cnt1}-1)\times2^{cnt2}代码12345678910111213141516171819202122232425262728293031323334353637string s;ll f[N];ll fun(int a,int b)&#123; ll qq=(f[a]-1+mod)%mod; return qq*f[b]%mod;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,a,b; f[0]=1; for1(i,100005)&#123; f[i]=f[i-1]*2%mod; &#125; while(cin&gt;&gt;n&gt;&gt;s)&#123; a=b=0; ll ans=1; for(int i=0;i&lt;s.size();i++)&#123; if(s[i]=='1')a++; &#125; n-=s.size(); for(int i=s.size()-1,j=0;i&gt;=0;i--,j++)&#123; if(s[i]=='1')&#123; b++; ans=fun(n+i-a+b,j)*ans%mod; // cout&lt;&lt;n+i-a+b&lt;&lt;' '&lt;&lt;j&lt;&lt;endl; &#125; &#125; outln(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>combination</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018河北省省赛]]></title>
    <url>%2F2019%2F05%2F01%2F2018%E6%B2%B3%E5%8C%97%E7%9C%81%E7%9C%81%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[E. K Multiple Longest Commom Subsequence题意两个数组 $1\le k,n,m\le 1e3$, 问最长 $k$ 倍公共子序列是多少, $k$ 倍子序列指的是, 将子序列等分, 每份为 $k$ 个数, 且这 $k$ 个数相同. 如 $1,1,2,2$ 是一个 $2$ 倍子序列 题解$\text{pre_a[i]}$ 表示从 $i$ 开始往前数, 第 $k$ 个 $a[i]$ 的下标 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445int pre_a[N],pre_b[N];int t,k,n,m,x,a[N],b[N],cnt[N],dp[N][N];queue&lt;int&gt;que[N];int main() &#123; in(t); while(t--)&#123; in(k,n,m); mem0(pre_a); mem0(pre_b); for1(i,1000)while(que[i].size())que[i].pop(); for1(i,n)&#123; in(x); a[i]=x; que[x].push(i); if(que[x].size()==k)&#123; int qw=que[x].front(); que[x].pop(); pre_a[i]=qw; &#125; &#125; for1(i,1000)while(que[i].size())que[i].pop(); for1(i,m)&#123; in(x); b[i]=x; que[x].push(i); if(que[x].size()==k)&#123; int qw=que[x].front(); que[x].pop(); pre_b[i]=qw; &#125; &#125; mem0(dp); for1(i,n) for1(j,m)&#123; dp[i][j]=max(dp[i][j],max(dp[i-1][j],dp[i][j-1])); if(a[i]==b[j])&#123; if(pre_a[i]&amp;&amp;pre_b[j]) dp[i][j]=max(dp[i][j],dp[ pre_a[i]-1 ][ pre_b[j]-1 ]+1); &#125; &#125; outln(dp[n][m]*k); &#125; return 0;&#125; F. Defending Plan Support题意给一棵树, 每个点有权值 $\omega(i)$, 每条边有权值 $d(i,j)$, 找一个点 $x$ 使 $F(x)=\sum \omega(i)\times d(x,i)$ 最小 题解以 $1$ 为根节点画出这棵树, 设 $j$ 的父节点为 $i$, $tot=\sum\omega(i)$, $sum[i]$ 表示以 $i$ 为根节点的子树的权值和 F(j)=F(i)+d(i,j)\times(tot-2*sum[j])代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546ll dp[N],ans,tot;int sum[N],n,w[N],x,y,z;bool vis[N];vector&lt;pii&gt;v[N];int dfs(int rt,ll len)&#123; ans+=len*w[rt]; int tmp=w[rt]; for(auto i:v[rt])&#123; if(vis[i.fi]==0)&#123; vis[i.fi]=1; tmp+=dfs(i.fi,len+i.se); &#125; &#125; return sum[rt]=tmp;&#125;void dfs2(int rt)&#123; for(auto i:v[rt])&#123; if(vis[i.fi]==0)&#123; vis[i.fi]=1; dp[i.fi]=dp[rt]+i.se*tot-2ll*i.se*sum[i.fi]; ans=min(ans,dp[i.fi]); dfs2(i.fi); &#125; &#125;&#125;int main() &#123; in(n); for0(i,n-1)&#123; in(x,y,z); // tot+=z; v[x].pb(pii(y,z)); v[y].pb(pii(x,z)); &#125; for1(i,n)&#123; in(w[i]); tot+=w[i]; &#125; vis[1]=1; dfs(1,0); mem0(vis); vis[1]=1; dp[1]=ans; dfs2(1); outln(ans); return 0;&#125; K. Bitmap题意给一个 $n\times n(1 \leq n \leq 2000)$, 一个 $m\times m(1 \leq m \leq 1000,m\le n)$ 的矩阵, 值的范围为 $[0,255]$, 问 $A$ 中有几个 $B$, 只要每个元素相差一个定值就视为相同 题解hash, 枚举 $A$ 中 $B$ 的左上角 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int M=1.1e3;ull Pow[2][M],Hash[2][N][N],seed[2]=&#123;131,233&#125;,hash_b,hash2[M][M],offset;int a[N][N],b[M][M],n,m;void init()&#123; Pow[0][0]=Pow[1][0]=1; ull tmp[2]; tmp[0]=tmp[1]=0; for0(i,2) for1(j,m)&#123; Pow[i][j]=Pow[i][j-1]*seed[i]; tmp[i]+=Pow[i][j-1]; &#125; offset=tmp[0]*tmp[1]; for1(i,n) for1(j,n)&#123; Hash[0][i][j]=Hash[0][i][j-1]*seed[0]+a[i][j]; Hash[1][i][j]=Hash[1][i-1][j]*seed[1]+Hash[0][i][j]; &#125; for1(i,m)&#123; for1(j,m)hash2[i][j]=hash2[i][j-1]*seed[0]+b[i][j]; hash_b=hash_b*seed[1]+hash2[i][m]; &#125; hash_b-=b[1][1]*offset;&#125;ull get2(int x1,int y1,int x2,int y2)&#123; return Hash[1][x2][y2]-Hash[1][x1-1][y1]*Pow[1][m]; &#125;ull get(int x1,int y1,int x2,int y2)&#123; return get2(x1,y2,x2,y2)-get2(x1,y1-1,x2,y1-1)*Pow[0][m]-a[x1][y1]*offset;&#125;int main() &#123; in(n,m); for1(i,n) for1(j,n)in(a[i][j]); for1(i,m) for1(j,m)in(b[i][j]); init(); int ans=0; for(int i=1;i+m-1&lt;=n;i++) for(int j=1;j+m-1&lt;=n;j++)&#123; if(get(i,j,i+m-1,j+m-1)==hash_b)ans++; &#125; outln(ans); return 0;&#125; I. Beautiful Array题意长度为 $y$, 乘积为 $x$ 的序列的个数 如 $x=2,y=2$, $[1,2],[2,1],[-1,-2],[-2,-1]$ 题解分解 $x$, x=p_1^{a_1}*p_2^{a_2}\cdots p_m^{a_m}对方案数来说, 不同素因子是独立的, 对于 $p_i$, 其贡献相当于将 $a_i$ 个相同的球放进不同的盒子, 且允许有空, 为 \large C_{a_i+y-1}^{y-1}再考虑负数, 负号只能为偶数个, 其贡献为 \large C_y^0+C_y^2+C_y^4+\cdots=2^{y-1}代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;bool notPrime[N+1];int prime[N+1],num_prime=0;void get_prime()&#123; notPrime[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!notPrime[i]) prime[num_prime++]=i; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;=N;j++)&#123; int k = i*prime[j]; notPrime[k] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125;const int M =2.1e6;ll fac[M],inv[M];ll C(ll a,ll b)&#123; if(b&gt;a)return 0; return fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;void init()&#123;//快速计算阶乘的逆元 fac[0]=fac[1]=1; for(int i=2;i&lt;M;i++)fac[i]=fac[i-1]*i%mod; inv[M-1] = qPow(fac[M-1], mod - 2, mod); for (int i = M - 2; i &gt;= 0; i--) inv[i] = (inv[i + 1] * (i + 1)) % mod;&#125;int main() &#123; int t,x,y; in(t); get_prime(); init(); while(t--)&#123; in(x,y); if(y==0)&#123; puts("0"); continue; &#125;else if(x==0)&#123; puts("1"); continue; &#125; ll ans=1; for(int i=0;i&lt;num_prime&amp;&amp;x!=1;i++)&#123; if(x%prime[i]==0)&#123; int cnt=0; while(x%prime[i]==0)&#123; x/=prime[i]; cnt++; &#125; ans=ans*C(cnt+y-1,y-1)%mod; &#125; &#125; if(x!=1)ans=ans*y%mod; ans=ans*qPow(2,y-1,mod)%mod; outln(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccpc</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>dp</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邮局]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%82%AE%E5%B1%80%2F</url>
    <content type="text"><![CDATA[题意$n(1\le n\le50)$ 个人, $m(1\le m \le 25)$ 个车站, 选 $k(1\le k\le 10)$ 个车站, 每个人去离他最近的车站, 输出路径和最短的方案. 题解搜索剪枝, 从后往前搜索, 若对于当前状态, 某一点无法对任意一个人松弛, 就标记这个点, 之后的搜索都不再访问. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;// int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int n,m,k;struct point&#123; int x,y,no;&#125;people[55],mail[33];db G[55][33];point result[11],tmp_res[11];db ans=1e18,sum,min_dis[55];bool Not[33];db get_dis(point a,point b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;void dfs(int depth,int index)&#123; if(depth==k)&#123; if(sum&lt;ans)&#123; ans=sum; for0(i,k)result[i]=tmp_res[i]; &#125; &#125;else&#123; db tmp[55],tsum=sum; bool flag2=0;//标记 [index,m-k+depth] 这些点里有没有能够至少松弛一个人的点 for0(i,n)tmp[i]=min_dis[i]; for(int i=m-k+depth;i&gt;=index;i--)&#123; //当前已经取了 depth 个, 为了保证能够取得 k 个,所以我们最多取到 m-k+depth 点, 从这一点开始往前搜索 if(Not[i])continue; bool flag=0;//标记 i 是否能够至少松弛一个人 if(depth==0)&#123; sum=0; for0(j,n)&#123; min_dis[j]=G[j][i]; sum+=min_dis[j]; &#125; flag=1; &#125;else&#123; // for0(j,n)min_dis[j]=tmp[j]; sum=tsum; for0(j,n)&#123; if(G[j][i]&lt;tmp[j])&#123; sum-=tmp[j]-G[j][i]; min_dis[j]=G[j][i]; flag=1; &#125;else min_dis[j]=tmp[j]; &#125; &#125; if(flag)&#123; tmp_res[depth]=mail[i]; dfs(depth+1,i+1); flag2=1; &#125;else&#123; Not[i]=1; &#125; &#125; if(!flag2)&#123;//若 [index,m-k+depth] 这些点里没有能够松弛的, 就取 m-k+depth tmp_res[depth]=mail[m-k+depth+1]; dfs(depth+1,m-k+depth+1); &#125;else&#123; for0(j,n)min_dis[j]=tmp[j]; sum=tsum; &#125; &#125;&#125;int main() &#123; in(n,m,k); for0(i,n)&#123; in(people[i].x,people[i].y); &#125; for0(i,m)&#123; in(mail[i].x,mail[i].y); mail[i].no=i+1; for0(j,n)&#123; G[j][i]=get_dis(people[j],mail[i]); &#125; &#125; dfs(0,0); for0(i,k)printf("%d ",result[i].no); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[农场阳光]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%86%9C%E5%9C%BA%E9%98%B3%E5%85%89%2F</url>
    <content type="text"><![CDATA[题意求多个圆和一个矩形的面积并 题解使用自适应 Simpson 求解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;db g;int n,a,b;struct circle&#123; db x,y,r; circle()&#123;&#125; circle(int a,int b,int c,int d)&#123; x=a+c/tan(g); y=b; r=d; &#125;&#125;cir_set[N];struct seg&#123; db top,bottom; seg()&#123;&#125; seg(db a,db b)&#123; top=a; bottom=b; &#125;&#125;;bool cmp(seg x,seg y)&#123; return x.bottom&lt;y.bottom;&#125;db F(db x)&#123; vector&lt;seg&gt;v; for0(i,n)&#123; circle ci=cir_set[i]; if(fabs(x-ci.x)&lt;ci.r)&#123; db h=sqrt(ci.r*ci.r-(x-ci.x)*(x-ci.x)); v.pb(seg(ci.y+h,ci.y-h)); &#125; &#125; if(v.size()==0)return b; v.pb(seg(0,b)); sort(v.begin(),v.end(),cmp); db sta=0,ans=0; for0(i,v.size())&#123; seg se=v[i]; if(se.bottom&gt;sta)&#123; ans+=se.bottom-sta; &#125; sta=max(sta,se.top); if(sta&gt;=b)break; &#125; return ans;&#125;// 2db calc(db len,db fL,db fM,db fR)&#123; //求长度为len的[L,R]区间，中点为M的Simpson近似面积 return (fL+4*fM+fR)*len/6;&#125;db Simpson(db L,db R) &#123;//Simpson积分求区间[L,R]的面积并,F(L)=L,F(R)=R,F(M)=M,把[L,R]当成整体来拟合得到的面积是sqr db M=(L+R)/2,fL=F(L),fM=F(M),fR=F(R),sqr=calc(R-L,fL,fM,fR); db g1=calc(M-L,fL,F((L+M)/2),fM),g2=calc(R-M,fM,F((M+R)/2),fR); if(fabs(sqr-g1-g2)&lt;=eps) //把当前区间分成2半再拟合得到的答案差别很小，就不再递归下去了 return g1+g2; return Simpson(L,M)+Simpson(M,R);&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); scanf("%d%d%Lf%d",&amp;a,&amp;b,&amp;g,&amp;n); g=g*pi/180; for0(i,n)&#123; int x,y,z,r; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;r); cir_set[i]=circle(x,y,z,r); // cout&lt;&lt;cir_set[i].x&lt;&lt;' '&lt;&lt;cir_set[i].y&lt;&lt;' '&lt;&lt;cir_set[i].r&lt;&lt;endl; &#125; printf("%.2Lf\n",Simpson(0,a)); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1151]]></title>
    <url>%2F2019%2F04%2F22%2FCF-1151%2F</url>
    <content type="text"><![CDATA[E. Number of Components题意一条链, 每个点的权值为 $a_i(1\le a_i\le n)$ , $f(l,r)$ 表示仅保留权值在 $[l,r]$ 之间的点的联通分量 求 \sum\limits_{l=1}^{n} \sum\limits_{r=l}^{n} f(l, r) 题解统计每个点的贡献, 只有当取 $a_i$ 不取 $a_{i+1}$ 时, $a_i$ 才有贡献 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x; ll pre; in(n); ll ans=0; in(pre); ans+=pre*(n+1-pre); for0(i,n-1)&#123; in(x); if(x&gt;pre)&#123; ans+=(x-pre)*(n+1-x); pre=x; &#125;else if(x&lt;pre)&#123; ans+=(pre-x)*x; pre=x; &#125; &#125; outln(ans); return 0;&#125; F. Sonya and Informatics题意数组 $a$ 有 $n$ 个数, 这些数由 $0,1$ 构成, 等概率交换任意两个数的位置, 问最后得到一个不下降的数列的概率, 答案对 $1e9+7$ 取模 题解设 $x$ 表示 $0$ 的个数, $dp[i][j]$ 表示操作 $i$ 次后前 $x$ 个数中 $0$ 的个数为 $j$ 的概率, 答案为 $dp[k][x]$ 可以发现状态转移方程与 $i$ 无关, 可以用矩阵快速幂做 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[110];ll matrix[110][110];ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int n,k,x=0,xx=0;void fun(ll c[110][110],ll b[110][110])&#123; ll tmp[110][110]; mem0(tmp); for0(i,x+1) for0(j,x+1) for0(k,x+1)tmp[i][j]=(tmp[i][j]+c[i][k]*b[k][j])%mod; memcp(c,tmp);&#125;ll Com(ll a)&#123; if(a&lt;2)return 0; return a*(a-1)/2;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // cout&lt;&lt;qPow(3,mod-2,mod)&lt;&lt;endl; in(n,k); ll C=n*(n-1)/2,inv_C=qPow(C,mod-2,mod); inv_C=qPow(inv_C,k,mod); for1(i,n)&#123; in(a[i]); if(!a[i])x++; &#125; ll A=Com(x),B=Com(n-x); for1(i,x)if(!a[i])xx++; int minn=max(0,2*x-n); // cout&lt;&lt;x&lt;&lt;' '&lt;&lt;xx&lt;&lt;' '&lt;&lt;minn&lt;&lt;endl; forl(i,minn,x)&#123; int p1=0,p2=0; if(i-1&gt;=minn)&#123; matrix[i-1][i]=p1=(x-i+1)*(x-i+1); &#125; if(i+1&lt;=x)&#123; matrix[i+1][i]=p2=(i+1)*(n-2*x+i+1); &#125; matrix[i][i]=A+B+i*(x-i)+(n-2*x+i)*(x-i); &#125; ll an[110][110]; for0(i,x+1)an[i][i]=1; while(k)&#123; if(k&amp;1)fun(an,matrix); fun(matrix,matrix); k&gt;&gt;=1; &#125; outln(an[xx][x]*inv_C%mod); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[填字母游戏]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%A1%AB%E5%AD%97%E6%AF%8D%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题意一个 $1*N$ 个格子, 上面已有一些 L 和 O, 两人博弈, 谁先拼出 LOL 谁获胜, 空格数&lt;14 题解状态标记搜索 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.6e6;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int ans[N];ll pow3[23];bool iskong[23];// int wei[23];int len;// int cnt;int fun(ll status)&#123; // cnt++; int ans_status=0; ll tmp_sta=status; int *wei=new int[23]; bool have0=0; for0(i,len)&#123; int flag=tmp_sta%3; wei[i]=flag; if(flag==0)have0=1; if(iskong[i])&#123; ans_status*=3; ans_status+=flag; &#125; tmp_sta/=3; &#125; if(ans[ans_status]&lt;inf)&#123; delete [] wei; return ans[ans_status]; &#125; for(int i=0;i+2&lt;len;i++)&#123; if(wei[i]==1&amp;&amp;wei[i+1]==2&amp;&amp;wei[i+2]==1)&#123; delete [] wei; return ans[ans_status]=-1; &#125; &#125; if(!have0)&#123; delete [] wei; return ans[ans_status]=0; &#125; // if(x.find("LOL") != -1)return -1; // if(x.find("*") == -1)return 0; int res = -1; delete [] wei; // delete tmp_sta; tmp_sta=status; for0(i,len)&#123; int flag=tmp_sta%3; if(flag==0)&#123; res = max(res,-fun(status+pow3[i])); res = max(res,-fun(status+2*pow3[i])); if(res==1)break; &#125; tmp_sta/=3; &#125; // for(int i = 0;x[i];i++) // if(x[i] == '*')&#123; // x[i] = 'L'; // res = max(res,-fun(x)); // if(res == 1)return x[i] = '*',1; // x[i] = 'O'; // res = max(res,-fun(x)); // x[i] = '*'; // &#125; return ans[ans_status]=res;&#125;int main()&#123; // clock_t wei=clock(); int t; in(t); char s[23]; pow3[0]=1; for1(i,22)&#123; pow3[i]=pow3[i-1]*3; &#125; while(t--)&#123; // cnt=0; meminf(ans); mem0(iskong); in(s); // cout&lt;&lt;s&lt;&lt;endl; ll tmp=0; len=strlen(s); assert(len&lt;23); // cout&lt;&lt;len&lt;&lt;endl; for0(i,len)&#123; tmp*=3; if(s[i]=='L')tmp+=1; else if(s[i]=='O')tmp+=2; else iskong[len-i-1]=1; &#125; outln(fun(tmp)); // outln(cnt); &#125; // printf("%lu\n",clock()-wei); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1154]]></title>
    <url>%2F2019%2F04%2F19%2FCF-1154%2F</url>
    <content type="text"><![CDATA[E. Two Teams题意一个 $1\sim n$ 的排列, 从大到小删数, 当删一个数时将其左右的 $k$ 个数也删了, 若某个数是第奇数次删的输出 1, 否则输出 2 题解维护两个数组 $l[i],r[i] $ 分别表示第 $i$ 个数左边, 右边的数所在的地方 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int l[N],r[N],Map[N],ans[N],a[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,k; in(n,k); for1(i,n)&#123; in(a[i]); Map[a[i]]=i; l[i]=i-1; r[i]=i+1; &#125; int flag=-1; for(int i=n;i&gt;=1;i--)&#123; if(Map[i])&#123; int poi=Map[i],ml=poi,mr=poi; for(int i=poi,j=0;i&lt;=n&amp;&amp;j&lt;=k;j++,mr=i=r[i])&#123; ans[i]=flag; Map[a[i]]=0; &#125; ml=poi=l[poi]; for(int i=poi,j=0;i&lt;=n&amp;&amp;j&lt;k;j++,ml=i=l[i])&#123; ans[i]=flag; Map[a[i]]=0; &#125; r[ml]=mr; l[mr]=ml; if(flag==-1)flag=-2; else flag=-1; &#125; &#125; for1(i,n)out(-ans[i]); puts(""); return 0;&#125; F. Shovels Shop题意$n$ 个物品, 其价格分别为 $a_i$ , 有 $m$ 种折扣, 买 $x_i$ 件物品, 便宜的 $y_i$ 件免费, 买 $k(\le 2000)$ 件的最小花费 题解$dp[i]$ 表示买 $i$ 件物品的最小花费 $dp[i]=min(dp[i-1]+a[i],dp[i-j]+pre[i]-pre[ i-cost[j] ])$ $cost[i]$ 表示买 $i$ 件物品最小需要支付的物品数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],dp[2003],cost[2003],pre[2003];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,k,x,y; meminf(cost); in(n,m,k); for1(i,n)in(a[i]); for0(i,m)&#123; in(x,y); if(x&lt;2001) cost[x]=min(cost[x],x-y); &#125; sort(a+1,a+n+1); for1(i,k)pre[i]=pre[i-1]+a[i]; for1(i,k)&#123; dp[i]=dp[i-1]+a[i]; for1(j,i) if(cost[j]&lt;inf) dp[i]=min(dp[i],dp[i-j]+pre[i]-pre[i-cost[j]]); &#125; outln(dp[k]); return 0;&#125; G. Minimum Possible LCM题意给 $n(2\le n \le 1e6)$ 个数, 求最大的 $lcm(a_i,a_j) (1\le a_i\le 1e7)$ 题解枚举 $gcd(a_i,a_j)$ , 找到最小的 $a_i, a_j$ 时间复杂度 $O(\frac {10^7}1+\frac {10^7}2+\frac {10^7}3+\cdots+\frac {10^7}{10^7})\approx O(10^7log(10^7))$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e7;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N][3];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x,maxx=0; in(n); for1(i,n)&#123; in(x); maxx=max(maxx,x); if(a[x][0]==0)&#123; a[x][1]=i; a[x][0]=1; &#125;else if(a[x][0]==1)&#123; a[x][2]=i; a[x][0]=2; &#125; &#125; ll minn=1e18; pii ans; for1(g,maxx)&#123; ll x1=0; for(int j=g;j&lt;=maxx;j+=g)&#123; if(x1)&#123; if(a[j][0])&#123; if(x1*j/g&lt;minn)&#123; ans=pii(a[x1][1],a[j][1]); minn=x1*j/g; &#125; break; &#125; &#125;else&#123; if(a[j][0]==1)&#123; x1=j; &#125;else if(a[j][0]==2)&#123; x1=j; if(x1*x1/g&lt;minn)&#123; ans=pii(a[x1][1],a[j][2]); minn=x1*j/g; &#125; break; &#125; &#125; &#125; &#125; if(ans.fi&gt;ans.se)swap(ans.fi,ans.se); printf("%d %d\n",ans.fi,ans.se); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-ACM-ICPC-Asia-Shenyang]]></title>
    <url>%2F2019%2F04%2F14%2F2017ICPC-Shenyang%2F</url>
    <content type="text"><![CDATA[A. BBP Formula题意 \pi=\sum_{k=0}^{\infty}\frac 1 {16^k}\left( \frac 4 {8k+1}-\frac 2 {8k+4}-\frac 1 {8k+5}-\frac 1 {8k+6}\right)求 $\pi$ 十六进制表达的小数点后第 $n$ 位. 题解求十进制小数的十六进制形式, 去掉整数部分, 小数部分乘 16 得到的数的整数部分就是小数点后第一位的十六进制值, 以此类推. 16^n\sum_{k=0}^{\infty}\frac 1 {16^k} \frac 4 {8k+1} =\sum_{k=0}^{n}\frac {4*16^{n-k}\%(8k+1)} {8k+1}+\sum_{k=n+1}^{\infty}\frac 4 {16^{k-n}(8k+1)}代码123456789101112131415161718192021222324252627282930313233343536373839404142int n;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;db fun(int a,int b)&#123; db ans=0; for0(i,n+1)&#123; ll w=a*qPow(16,n-i,8*i+b)%(8*i+b); ans+=(db)w/(8*i+b); &#125; ll ppow=1; for1(i,15)&#123; ppow*=16; // cout&lt;&lt;ppow&lt;&lt;endl; ans+=(db)a/ppow/(8*(i+n)+b); &#125; return ans;&#125;int main() &#123; int t; in(t); for1(ca,t)&#123; in(n); n--; db ans=fun(4,1)-fun(2,4)-fun(1,5)-fun(1,6); // cout&lt;&lt;ans&lt;&lt;endl; while(ans&lt;0)ans++; while(ans&gt;1)ans--; // cout&lt;&lt;ans&lt;&lt;endl; int k=ans*16; // cout&lt;&lt;k&lt;&lt;endl; if(k&gt;=10)printf("Case #%d: %d %c\n",ca,n+1,k-10+'A'); else printf("Case #%d: %d %d\n",ca,n+1,k); &#125; return 0;&#125; F. Heron and His Triangle题意设三角形的三条边为 $t-1,t,t+1$ ，给一个 $n(1\le n\le 1e30)$ ，求大于 $n$ 且三角形面积为整数的最小 $t$ 题解由海伦公式得 S=\sqrt {p(p-a)(p-b)(p-c)}\ ,p=\frac {a+b+c}2\\ S=\frac t 2\sqrt {3\left(\left(\frac t 2\right)^2-1\right)}\\ assume\qquad x=\frac t 2\\ x^2-3y^2=1\\ x_n=4x_{n-1}-x_{n-2}代码123456789101112131415161718192021222324252627282930import java.io.*;import java.util.*;import java.math.*; public class Main&#123; public static void main(String[] args) throws IOException&#123; Scanner sc =new Scanner(System.in); int t; t = sc.nextInt(); BigInteger n,maxn=new BigInteger("1000000000000000000000000000000"); Vector&lt;BigInteger&gt;v = new Vector&lt;&gt;(); v.add(BigInteger.valueOf(4)); v.add(BigInteger.valueOf(14)); while(v.lastElement().compareTo(maxn)==-1) &#123; int qq = v.size(); v.add(v.elementAt(qq-1).multiply(BigInteger.valueOf(4)).subtract(v.elementAt(qq-2))); &#125; while(t--!=0) &#123; n=sc.nextBigInteger(); for(Iterator&lt;BigInteger&gt; iter = v.iterator();iter.hasNext();) &#123; BigInteger tmp=iter.next(); if(tmp.compareTo(n)&gt;=0) &#123; System.out.println(tmp); break; &#125; &#125; &#125; sc.close(); &#125;&#125;]]></content>
      <categories>
        <category>icpc</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1144]]></title>
    <url>%2F2019%2F04%2F01%2FCF-1144%2F</url>
    <content type="text"><![CDATA[F. Graph Without Long Directed Paths题意一个严格递增的数列, 一个严格递减的数列, 将它们保持原相对顺序不变合并在一起. 给出合并后的数列. 题解1 (greedy)维护一个递增数列 A, 一个递减的数列 B, 当只能插入一个数列的时候插入对应数列, 当两个都不能插入时输出”NO”, 当两个都能插入时, 若下一个数大于当前数, 插入 A, 否则插入 B. 题解2 (dp)$dp[ i ][ 0 ]$表示处理完前 $i$ 个， 第 $i$ 个是递增序列序列里的元素，递减序列的最大值。 $dp[ i ][ 1 ]$表示处理完前 $i$ 个， 第 $i$ 个是递减序列序列里的元素，递增序列的最小值。 https://www.cnblogs.com/CJLHY/p/10634175.html 代码123456789101112131415161718192021222324252627282930313233343536373839int a[N],flag[N];vii Inc,Dec;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; in(n); for0(i,n)in(a[i]); Inc.pb(-1); Dec.pb(3e5); for0(i,n)&#123; if(Inc.back()&gt;=a[i]&amp;&amp;Dec.back()&lt;=a[i])&#123; puts("NO"); return 0; &#125; if(Inc.back()&gt;=a[i])&#123; flag[i]=1; Dec.pb(a[i]); continue; &#125; if(Dec.back()&lt;=a[i])&#123; Inc.pb(a[i]); continue; &#125; if(a[i+1]&gt;a[i])&#123; Inc.pb(a[i]); &#125;else &#123; flag[i]=1; Dec.pb(a[i]); &#125; &#125; puts("YES"); for0(i,n)printf("%d ",flag[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>data structure</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1139]]></title>
    <url>%2F2019%2F03%2F30%2FCF-1139%2F</url>
    <content type="text"><![CDATA[D. Steps to One题意每次从$1\sim m$从等概率的选择一个数, 直到所有选择的数的 gcd 为 1, 问操作的次数的期望是多少? 题解1设$f[n]$表示当前 gcd 为 n 还需要的步数的期望 f[n]=1+\frac {\sum\limits_{i=1}^mf[gcd(i,n)]} m\\ \sum\limits_{i=1}^mf[gcd(i,n)]=\sum\limits_{d|n}f[d]\sum\limits_{i=1}^me[gcd(i,n)==d]\\ \sum\limits_{i=1}^me[gcd(i,n)==d]=\sum\limits_{i=1}^{\lfloor \frac m d\rfloor}\epsilon[gcd(i,\frac n d)] \\=\sum\limits_{i=1}^{\lfloor \frac m d\rfloor}\sum\limits_{t|gcd(i,\frac n d)}\mu(t)=\sum\limits_{t|\frac n d}\mu(t)\lfloor \frac m {dt}\rfloor\\ 接下来把右边f[n]的项提出来\\ (m-\lfloor\frac m n\rfloor)f[n]=m+\sum\limits_{d|n,d\ne n}f[d]\sum\limits_{t|\frac n d}\mu(t)\lfloor \frac m {dt}\rfloor\\ ans=1+\frac {\sum\limits_{i=1}^mf[i]} m题解2设$E[n|i]$表示 gcd 为 n 的倍数的期望步数 k=\lfloor\frac m n\rfloor\\ E[n|i]=\sum\limits_{j=1}^{\infty}j*\frac {k^j} {m^j}=\frac {\frac k m} {1-\frac k m}=\frac k {m-k}\\ ans=1+E[i>1]=1+\sum_{j=2}^m-\mu(j)E[j|i]代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//解1int f[N];int main() &#123; int m; cin&gt;&gt;m; for1(i,m)&#123; for(int j=1;j*j&lt;=i;j++)&#123; if(i%j==0)&#123; if(i/j==j)&#123; fac[i].pb(j); &#125;else&#123; fac[i].pb(j); fac[i].pb(i/j); &#125; &#125; &#125; &#125; get_prime(); f[1]=0; ll tot=0; forl(n,2,m)&#123; ll t_tmp=m; for0(j,fac[n].size())&#123; ll d=fac[n][j]; if(d==n)continue; ll cnt=0; for0(k,fac[n/d].size())&#123; int t=fac[n/d][k]; cnt=(cnt+(ll)mu[t]*(m/d/t)%mod)%mod; &#125; t_tmp=(t_tmp+f[d]*cnt%mod)%mod; &#125; f[n]=t_tmp*qPow(m-m/n,mod-2,mod)%mod; tot=(tot+f[n])%mod; // cout&lt;&lt;f[n]&lt;&lt;endl; &#125; printf("%lld\n",(tot*qPow(m,mod-2,mod)%mod+1)%mod); return 0;&#125;//解2bool notPrime[N+1];int prime[N+1],num_prime=0,mu[N+1];void get_prime()&#123; notPrime[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!notPrime[i]) &#123; prime[num_prime++]=i; mu[i]=1; &#125; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;=N;j++)&#123; int k = i*prime[j]; notPrime[k] = 1; if(i % prime[j] == 0)break; else mu[k]=mod-mu[i]; &#125; &#125;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=ans*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return ans;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m; in(m); get_prime(); ll ans=1; forl(i,2,m)&#123; ll k=m/i; ans=(ans+mu[i]*k%mod*qpow(m-k,mod-2)%mod)%mod; &#125; printf("%lld\n",ans); return 0;&#125; 引用 https://www.cnblogs.com/zyt1253679098/p/10584706.htmlhttps://blog.csdn.net/neuq_zsmj/article/details/88830388]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>dp</tag>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-883]]></title>
    <url>%2F2019%2F03%2F27%2FCF-883%2F</url>
    <content type="text"><![CDATA[I. Photo Processing题意将 n 个数分堆，要保证每堆不少于 k 个数，每堆的值为这堆数中的最大值减去最小值，取这些值中的最大值，要是这个最大值最小。 题解二分答案，$dp$ 判断是否可行。$dp[i]$ 表示将 $1\sim i$ 划分成满足条件的区间，能划分最远的地方。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],n,k,dp[N];bool check(int x)&#123; int last=0; forl(i,k,n)&#123; int j=dp[i-k]; if(a[i]-a[j+1]&lt;=x)last=i; dp[i]=last; &#125; return dp[n]==n;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(n,k); for1(i,n)in(a[i]); sort(a+1,a+1+n); int l=0,r=1e9,mid; while(l&lt;=r)&#123; mid=(l+r)/2; if(check(mid))r=mid-1; else l=mid+1; &#125; printf("%d\n",l); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包子凑数]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题意给 $n(1\le n\le 100)$ 个数$(1\le a_i\le 100)$，问由它们不能组合(加法)成的数(正整数)的个数，若有无穷个输出”INF”。 题解若它们的公共 gcd 不为1，输出 INF，构造一个小顶堆，每次新加的值为堆顶的值加$a_i$ ，弹出堆顶，可证最大不可表示的值不会超过1e4，所以当堆顶大于1e4的时候跳出循环。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;priority_queue&lt;int,vii,greater&lt;int&gt; &gt;que;bool vis[11000];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,a[110]; mem0(vis); in(n); fro0(i,n)in(a[i]); if(n==1)&#123; if(a[0]==1)puts("0"); else puts("INF"); &#125;else&#123; int gc=a[0]; for1(i,n-1)gc=gcd(gc,a[i]); if(gc==1)&#123; int ans=0; sort(a,a+n); fro0(i,n)&#123; vis[a[i]]=1; que.push(a[i]); &#125; while(1)&#123; int to=que.top(); que.pop(); if(to&gt;=1e4)break; fro0(i,n)&#123; int now=to+a[i]; if(now&lt;=1e4&amp;&amp;vis[now]==0)&#123; vis[now]=1; que.push(now); &#125; &#125; &#125; for1(i,1e4)if(!vis[i])ans++; printf("%d\n",ans); &#125;else puts("INF"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小朋友排队]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%8E%92%E9%98%9F%2F</url>
    <content type="text"><![CDATA[题意n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。 题解每个人的不高兴度为它的逆序对数(在它前面大于它的，在它后面小于它的)，使用树状数组从前从后分别跑一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int h,no,cnt; da()&#123;&#125; da(int a,int b)&#123; h=a; no=b; cnt=0; &#125; oper(da)&#123; if(h==y.h)return no&lt;y.no; else return h&lt;y.h; &#125;&#125;a[N];int b[N],n,h;;itn lowbit(int x)&#123; return x&amp;(-x);&#125;int add(int x)&#123; int tmp=0; for(int i=x;i;i-=lowbit(i))&#123; tmp+=b[i]; &#125; for(itn i=x;i&lt;=n;i+=lowbit(i))&#123; b[i]++; &#125; return tmp;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(n); fro0(i,n)&#123; in(h); a[i]=da(h,i+1); &#125; sort(a,a+n); ll ans=0; fro0(i,n)&#123; a[i].cnt+=i-add(a[i].no); &#125; mem0(b); forr(i,n-1,0)&#123; a[i].cnt+=add(a[i].no); ans+=(ll)a[i].cnt*(a[i].cnt+1)/2; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>binary indexed tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[波动数列]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%B3%A2%E5%8A%A8%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题意长度为 n 和为 s 而且后一项总是比前一项增加 a 或者减少 b 的整数数列可能有多少种。$1&lt;=n&lt;=1e3，-1e9&lt;=s&lt;=1e9，1&lt;=a, b&lt;=1e6$ 题解设数列首项为$a_1$，增量为$d_1,d_2,\cdots,d_{n-1}$，则$\large na_1+\sum\limits_{i=1}^{n-1}(n-i-1)d_i=s$因为$a_1$可以取任意值，所以$\large \sum\limits_{i=1}^{n-1}(n-i-1)d_i\equiv s (mod n)$$dp[i][j]$表示长度为$i$，$\large \sum\limits_{k=1}^{i-1}(n-k-1)d_k mod n=j$ 的方案数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e8+7;const int N = 1.1e3;const db eps = 1e-8;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;ll dp[N][N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,s,a,b,nxt; in(n,s,a,b); s=(s%n+n)%n,a%=n,b%=n; dp[1][0]=1; for1(i,n-1)&#123; for0(j,n)&#123; nxt=(j+a*(n-i)%n)%n; dp[i+1][nxt]=(dp[i+1][nxt]+dp[i][j])%mod; nxt=(j-b*(n-i)%n+n)%n; dp[i+1][nxt]=(dp[i+1][nxt]+dp[i][j])%mod; &#125; &#125; printf("%lld\n",dp[n][s]); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁感冒]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%9A%82%E8%9A%81%E6%84%9F%E5%86%92%2F</url>
    <content type="text"><![CDATA[题意长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。 题解首先明白两只蚂蚁碰撞之后掉头和穿行过去是一样的，可以把穿行看做碰撞后掉头了，然后两个蚂蚁交换了，而是哪一只蚂蚁对结果不影响。那么，假如第一只感冒蚂蚁向右走，那么碰到所有想左走的都会被感染，而感染后的蚂蚁必定是向左走的，那么他会把左边向右走的都感染了。向左走的也是这样。所以 ans = 左边向右走的 + 右边向左走的 + 1（本身）。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int num; bool kind; da()&#123;&#125; da (int a,bool b)&#123; num=a; kind=b; &#125; bool operator &lt;(const da y)const&#123; return num&lt;y.num; &#125;&#125;a[55];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x; ind(n); for0(i,n)&#123; ind(x); if(x&lt;0)&#123; a[i]=da(-x,0); &#125;else a[i]=da(x,1); &#125; x=a[0].num; bool flag=a[0].kind,right=0; sort(a,a+n); int l=0,r=0; for0(i,n)&#123; if(a[i].num==x)&#123; right=1; continue; &#125; if(right&amp;&amp;a[i].kind==0)&#123; r++; &#125;else if(!right&amp;&amp;a[i].kind)&#123; l++; &#125; &#125; int ans=1; if(l&amp;&amp;r)ans+=l+r; else if(flag)&#123; ans+=r; &#125;else ans+=l; printf("%d\n",ans); return 0;&#125; 引用https://blog.csdn.net/y990041769/article/details/21941711]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>similar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-11]]></title>
    <url>%2F2019%2F03%2F22%2FCF-11%2F</url>
    <content type="text"><![CDATA[D. A Simple Task题意求出一个n个点m个边的图，求简单环有多少（没有重复点和边）。（n&lt;20） 题解用S能记录状态（有多少个点在路径中），那么如何找环能确保不重不漏啦，对于一个环，找出他的特异性记录，一个环，如果以最小点为环的“起始点”，则每个环都被记录啦两次。用dp[s][i]表示路径s的当前点为i的次数，枚举下一点，如果形成环就加上答案，否则记录下一边。由于题目求的是超过三个点的简单环，而之前所求两个点也会被记录。减掉就可以啦。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(25)using namespace std;ll dp[1&lt;&lt;19][N];int n,m;bool a[N][N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); scanf("%d%d",&amp;n,&amp;m); int u,v; ll ans=0; for0(i,m)&#123; scanf("%d%d",&amp;u,&amp;v); u--;v--; a[u][v]=a[v][u]=1; &#125; for0(i,n)dp[1&lt;&lt;i][i]=1; for(int i=1;i&lt;1&lt;&lt;n;i++)&#123; int st; for0(k,n) if(i&amp;(1&lt;&lt;k))&#123; st=k; break; &#125; for(int k=st+1;k&lt;n;k++)&#123; if(dp[i][k]==0)continue; if(a[k][st]&amp;&amp;__builtin_popcount(i)&gt;2)ans+=dp[i][k]; &#125; for(int j=st;j&lt;n;j++)&#123; if(dp[i][j]==0)continue; for(int k=st+1;k&lt;n;k++) if(a[j][k]&amp;&amp;!(i&amp;(1&lt;&lt;k)))dp[i+(1&lt;&lt;k)][k]+=dp[i][j]; &#125; &#125; printf("%lld\n",ans/2); return 0;&#125; 引用 https://blog.csdn.net/m0_37953323/article/details/77169608]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4651]]></title>
    <url>%2F2019%2F03%2F22%2FHDU-4651%2F</url>
    <content type="text"><![CDATA[题意整数拆分，$(1\le n\le 10^5)$ 题解使用五边形定理 P(n)=\sum\limits_{k=1}^n(-1)^{k+1}\left [P\left( n-\frac 1 2k(3k-1)\right)+P\left( n-\frac 1 2k(3k+1)\right )\right ]其中n-\frac 1 2k(3k-1)>=0 , n-\frac 1 2k(3k+1)>=0 ，注意两个条件要分开判断，有大于0的就加上相应的f，不是两个同时成立或者不成立 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(1.1e5)using namespace std;int p[N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); p[0]=1; for1(i,100005)&#123; ll fl=1,an=0,flag=1; while(1)&#123; ll tmp=fl*(3*fl-1)/2; if(i-tmp&lt;0)break; an=(an+flag*p[i-tmp]+mod)%mod; tmp=fl*(3*fl+1)/2; if(i-tmp&lt;0)break; an=(an+flag*p[i-tmp]+mod)%mod; fl++; flag*=-1; &#125; p[i]=an; // printf("%d\n",tmp); &#125; int t,n; ind(t); while(t--)&#123; ind(n); printf("%d\n",p[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂题]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%9D%82%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1题意将整数n拆分为m个数的和，输出这m个数or的最小值。 题解要想使或值最小，那么m个二进制数中的最高位应尽量小，假如存在k使$(2^k-1)m &gt; n &gt; (2^{k-1}-1)*m$，所以m个二进制数中至少有一个数的最高位为k。因为是取各位取或，所以此时应让尽量多的数的第k位为1，$ans += 2^k$，从高位向低位递推，直到n变为0。 2题意 \Large\sum\limits_{i=1}^n\lfloor\frac n i\rfloor代码123456789101112//solution1int k=sqrt(n+0.1);for (int i = 1; i &lt;= k; i++) &#123; ans+=n/i; if (n/(i+1)&lt;i)break; else ans+=(n/i-n/(i+1))*i;&#125;//solution2for (int i = 1; i &lt;= k; i++) ans+=n/i;ans*=2;ans-=k*k; 3题意设一个排列，当i为奇数，a[i]&gt;a[i-1]，求满足条件的长度为n的数量 题解设答案是 $f(n)$考虑最⼤大的数的位置是 i，则变成一个长度为 i-1 的数列列和一个长度为 n-i 的数列列所以 $f(n)=\sum\frac {f(i)f(n-i-1)} n$所以 $f(x)’=f(x)^2+1$解得 $f(x)=tan(x)$ 4题解n+1个数由1-n 组成，只有一个重复的，找出来。 代码123456789101112131415161718192021int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int low = nums[0], fast = nums[nums[0]]; while (low != fast) &#123; low = nums[low]; fast = nums[nums[fast]]; &#125; fast = 0; while (low != fast) &#123; low = nums[low]; fast = nums[fast]; &#125; return low;&#125;int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[abs(nums[i]) - 1] &lt; 0) return abs(nums[i]); nums[abs(nums[i]) - 1] *= -1; &#125; return -1;&#125; 5 法一: 求每个点左边连续比它大的最左边的下标，保存在l[]数组里,求每个点右边连续比它大的最右边的下标，保存在r[]数组里 法二: 维护一个单调栈, 如果h大于栈顶元素，则入栈, 否则，将栈内元素出栈，直到满足上面的条件。出栈时，我们要将出栈元素对之后问题的影响全部考虑进行处理，才能保证做法的正确性。 6 只需n+m-1个就可以填满, 当插入点(x1,y1) 时有关系x1&lt;=&gt;y1 当插入点(x2,y1) 时有关系 x2&lt;=&gt;y1&lt;=&gt;x1 当插入点(x1,y2) 时有关系 y2&lt;=&gt;x1&lt;=&gt;y1&lt;=&gt;x2 用并查集来连接 7给你一个序列n个数组成，然后让你在里面找到m个子序列，让这m个子序列的和最大。 12345dp[i][j]表示的是第j个数字在第i个子序列时的当前最优值。dp[i][j] = maxx(dp[i][j-1] + num[j] ,maxx(dp[i-1][k]) + num[j]); k是从1到j-1.可以这么理解这个转移方程，对于当前的这个数字，如果把他放到第i个子序列中有两种情况，一个是他作为第i个子序列的第一个数字，另一个就是不作为第一个数字，作为第一个数字的时候是 max(dp[i-2][k] + num[j]) 1&lt;=k&lt;i 的意思是从之前的所有中找到i-1个子序列的最大值+当前的值，不做为第一个的时候那么他前面的那个数字一定是i序列的，同一个子序列，又不是作为第一个，那么前面的那个货就一定是同一个子序列的，那么当前的值是dp[i][j-1] + num[j],在两种决策中选择一个最有的就行了，还有就是maxx(dp[i-1][k]+num[j])的这个地方可以开一个数组记录下来，不能每次都跑，跑不起，再有就是这个题目没有给m的范围，所以开不了二维数组（目测不是很大，大的话会超时，但是肯定是先超内存在超时，所以为了保险，还是吧dp[][]压缩成一维的）那么状态转移就边成这样了dp[j]表示的是 j这个人在当前的这个子序列中的最优值，mk[j]表示的是在上一个子序列中1--j的dp的最大值，所以就变成 dp[j] = maxx(dp[j-1] + num[j] ,mk[j-1]+num[j]);还是 max(作为i个子序列的第一个元素，不是第一个元素取一个最大值)。在解释下代码的核心部分。 8给一个函数 12345678910int f(int x,int y)&#123; int c=0; while(y&gt;0)&#123; c++; t=x%y; x=y; y=t; &#125; return c*x*x;&#125; 给出n,m,p，求$\Large\sum\limits_{i=1}^n\sum\limits_{j=1}^m\lfloor\frac {i*j} {f(i,j)}\rfloor$ ans=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{i+j*k\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor\\=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*(k+p*c))} {c*x*x}\rfloor\\ =\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor+\frac {p*j*j} {x*x}9有n家银行围成一个圈，有个人在有些银行里欠了钱，在一些银行里有存钱，欠的钱总数等于存的钱总数。现在可以有操作，如果两个银行相邻，那么就能在一个银行转任意多的钱到另一个银行。问最少的操作次数，使得在所有银行的存款钱数都为0。 首先我们要发现第一个贪心。如果有一段子串，里面的数字之和等于0，那么在这段子串中移动数字，所需要的代价为子串长度len-1，那么问题就转换成了，我们在这个圈中能找到多少段子串，里面的数字之和等于0，而且段数越多越好，记为k，那么很明显，答案就是n-k，现在问题来了，如何来求满足题意的最大的k。首先，我们考虑用前缀和来存放，如果遇到两个位置，前缀和相等，那么中间那一段数字之和肯定等于0。接下来就是一个跳跃性的思考了，那么如果某个前缀和的值出现了k次，是不是就是我们上述的k呢？答案是正确的！假如有k个位置的前缀和相等，那么中间k-1段子串内数字之和一定都是0，由于总数是0，那么最前面和最后面连着的那一段也肯定是0，所以，我们记录所有的前缀和的值，然后排序。然后用取尺法记录一个数出现的最多次数，就做完了 10将整数n拆分为m个数的和，输出这m个数or的最小值。 要想使或值最小，那么m个二进制数中的最高位应尽量小，假如存在k使$(2^k-1)m &gt; n &gt; (2^{k-1}-1)*m$，所以m个二进制数中至少有一个数的最高位为k。因为是取各位取或，所以此时应让尽量多的数的第k位为1，$ans += 2^k$，从高位向低位递推，直到n变为0。 11求a~b间素数个数(1 ≤ a ≤ b &lt; 2^31, b - a ≤ 100000). 12345678memset(visab,0,sizeof(visab));for (int i = 0; i &lt; cnt &amp;&amp; prime[i] &lt;= b; i++) &#123; LL k = a / prime[i]; if (k * prime[i] &lt; a) k++; for (LL j = k * prime[i]; j &lt;= b; j += prime[i]) &#123; visab[j - a] = 1; &#125;&#125; 12求和 \Large\sum\limits_{i=1}^n\lfloor\frac n i\rfloor123456789101112//solution1int k=sqrt(n+0.1);for (int i = 1; i &lt;= k; i++) &#123; ans+=n/i; if (n/(i+1)&lt;i)break; else ans+=(n/i-n/(i+1))*i;&#125;//solution2for (int i = 1; i &lt;= k; i++) ans+=n/i;ans*=2;ans-=k*k; 13设一个排列，当i为奇数，a[i]&gt;a[i-1]，求满足条件的长度为n的数量 设答案是 f(n) 考虑最⼤大的数的位置是 i，则变成⼀一个⻓长度为 i-1 的数列列和一个⻓长度为 n-i 的数列列 所以 f(n)=sum(f(i)f(n-i-1))/n 所以 f(x)’=f(x)^2+1 解得 f(x)=tan(x) 14n+1个数由1-n 组成，只有一个重复的，找出来。 123456789101112131415161718192021int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int low = nums[0], fast = nums[nums[0]]; while (low != fast) &#123; low = nums[low]; fast = nums[nums[fast]]; &#125; fast = 0; while (low != fast) &#123; low = nums[low]; fast = nums[fast]; &#125; return low;&#125;int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[abs(nums[i]) - 1] &lt; 0) return abs(nums[i]); nums[abs(nums[i]) - 1] *= -1; &#125; return -1;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4055 Number String]]></title>
    <url>%2F2019%2F03%2F22%2FHDU-4055%2F</url>
    <content type="text"><![CDATA[题意给你一个字符串s，s[i] = ‘D’表示排列中a[i] &gt; a[i+1]，s[i] = ‘I’表示排列中a[i] &lt; a[i+1]。 比如排列 {3, 1, 2, 7, 4, 6, 5} 表示为字符串 DIIDID。 题解很巧妙的DP做法，$dp[i][j]$表示前i个满足字符串条件的结尾为j的 i 的排列，注意是i的排列，前面并没有数大于i。那又是如何往下递推呢？ 如果s[i - 1]是’ I ‘，那么$dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + .. + dp[i-1][1]$如果s[i - 1]是‘D’，那么$dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + … + dp[i-1][i]$，因为要令当前位为j，如果前面出现过j，就令前面的所有大于等于j的数+1，就能构造出新的排列了。 比如{1, 3, 5, 2, 4}，要在第六位插入3,令 &gt;= 3的数都+1，于是就构造出新的 排列{1, 4, 6, 2, 5, 3}。然后代码的话处理出前缀和$sum[i][j]$，就不用$dp[i][j]$了。 代码123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;typedef __int64 ll; const int maxn = 1000 + 5;const int mod = 1000000007; ll sum[maxn][maxn];char s[maxn]; int main() &#123; while(scanf("%s", s) != -1) &#123; int len = strlen(s); sum[0][1] = 1; for(int i = 1;i &lt;= len; i++) &#123; for(int j = 1;j &lt;= i+1; j++) &#123; sum[i][j] = sum[i][j-1]; if(s[i-1] != 'D') sum[i][j] += sum[i-1][j-1]; if(s[i-1] != 'I') sum[i][j] += sum[i-1][i] - sum[i-1][j-1] + mod; sum[i][j] %= mod; &#125; &#125; printf("%I64d\n", sum[len][len+1]); &#125; return 0;&#125; 引用https://blog.csdn.net/jayye1994/article/details/12361481]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LightOJ-1197 Help Hanzo]]></title>
    <url>%2F2019%2F03%2F22%2FLightOJ-1197%2F</url>
    <content type="text"><![CDATA[题意求a~b间素数个数(1 ≤ a ≤ b &lt; 2^31, b - a ≤ 100000). 题解b-a这个区间比较小，所以可以用区间素数筛选的办法解决这个题目。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem1(a) memset(a, 1 , sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;const int N=100005;bool a[N+1];vector&lt;int&gt; prime;void getPrime()&#123; memset(a,true,sizeof(a)); for(int i=2;i&lt;=N;i++)&#123; if(a[i]) prime.push_back(i); for(int j=0;j&lt;(int)prime.size()&amp;&amp;i*prime[j]&lt;=N;j++)&#123; a[i*prime[j]]=false; if(!(i%prime[j])) break; &#125; &#125;&#125;int main()&#123; //ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); //freopen("in.txt", "r", stdin); ll t,a,b; bool isprime[100005]; getPrime(); //cout&lt;&lt;prime.size(); cin&gt;&gt;t; for1(k,t)&#123; int ans=0; cin&gt;&gt;a&gt;&gt;b; mem1(isprime); for(int i=0;prime[i]*prime[i]&lt;=b&amp;&amp;i&lt;(int)prime.size();i++)&#123; ll l=a/prime[i]; if (l*prime[i]&lt;a) l++; if (l&lt;2) l=2; for (; l*prime[i]&lt;=b; l++) isprime[l*prime[i]-a]=0; &#125; if (a==1) isprime[0]=0; for0(i,b-a+1) if (isprime[i])ans++; printf("Case %d: %d\n",k,ans ); &#125; return 0;&#125;]]></content>
      <categories>
        <category>lightoj</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3167 Cow Patterns]]></title>
    <url>%2F2019%2F03%2F22%2FPOJ-3167%2F</url>
    <content type="text"><![CDATA[题意一个农场主有 N 头牛，每个牛都以它身上的斑点数作为标志，以斑点数作为标准对牛进行 rank 排序，定义牛的序列的相同性为第 i 头牛及其之前的牛的比他 rank 小的数量和与他 rank 相同的数量，比如：1 4 4 3 2 1 和 2 10 10 7 3 2 是一样的模式串要求数有多少个符合要求的模式串，并输出每个符合要求的子串的起始位置。 题解定义一个函数 $getval(ch,str,l,r)$，返回的值为 $ch$ 在 $str[l~r]$ 中的真实值，即将 $str[l~r]$ 中的值排序离散化后 $ch$ 的值。则题意即为：在a串中找出一段长为m的区间[l,r]，使对任意的1≤i≤m，getval(a[l+i-1],a,l,r)均等于getval(b[i],b,1,m)getval的值，其实是返回某个数(数跟字符其实是一样的)在某堆数中的排名。是什么决定了一个数x的排名？是小于x的数的个数，等于x的数的个数。如果这两个个数与另一个y的两个个数都相等，那么x跟y在各自字符串的各自区间内的getval值就相等了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))n#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(1.1e5)using namespace std;int Next[N],sump[N][30],now[30],sums[N][30],n,k;vector&lt;int&gt;ans;bool check(int l,int r,int sump[][30],int sums[][30],int *p,int*s)&#123; int lep=0,les=0; for1(i,p[l]-1)lep+=sump[l][i]; for1(i,s[r]-1)les+=sums[r][i]-sums[r-l][i]; if(lep==les&amp;&amp;sump[l][p[l]]==sums[r][s[r]]-sums[r-l][s[r]])return 1; else return 0;&#125;void kmp_pre(int *p, int p_len, int Next[]) &#123; // Next[i] 为满足 p[i-z...i-1]=p[0...z-1] 的最大 z 值(就是 p的自身匹配) int i = 0, j = Next[0] = -1; while (i &lt; p_len) &#123; while (j != -1 &amp;&amp; !check(j,i,sump,sump,p,p)) j = Next[j]; Next[++i] = ++j; &#125;&#125;void KMP(int *p, int *s) &#123; // p 是模式串，s 是主串 int i = 0, j = 0, p_len = k, s_len =n; for1(i,p_len)&#123; memcpy(sump[i],sump[i-1],30*sizeof(int)); sump[i][p[i-1]]++; &#125; for1(i,s_len)&#123; memcpy(sums[i],sums[i-1],sizeof(sums[i])); sums[i][s[i-1]]++; &#125; kmp_pre(p, p_len, Next); while (i &lt; s_len) &#123; while (-1 != j &amp;&amp; !check(j,i,sump,sums,p,s)) j = Next[j]; i++;j++; if (j &gt;= p_len) &#123; ans.push_back(i); j = Next[j]; &#125; &#125;&#125;int p[N],S[N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int q; scanf("%d%d%d",&amp;n,&amp;k,&amp;q); for0(i,n)ind(S[i]); for0(i,k)ind(p[i]); KMP(p,S); //puts(""); printf("%d\n",(int)ans.size()); for0(i,ans.size())printf("%d\n",ans[i]-k+1); return 0;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-675]]></title>
    <url>%2F2019%2F03%2F22%2FCF-675%2F</url>
    <content type="text"><![CDATA[C. Money Transfers题意有n家银行围成一个圈，有个人在有些银行里欠了钱，在一些银行里有存钱，欠的钱总数等于存的钱总数。现在可以有操作，如果两个银行相邻，那么就能在一个银行转任意多的钱到另一个银行。问最少的操作次数，使得在所有银行的存款钱数都为0。 题解首先我们要发现第一个贪心。如果有一段子串，里面的数字之和等于0，那么在这段子串中移动数字，所需要的代价为子串长度len-1，那么问题就转换成了，我们在这个圈中能找到多少段子串，里面的数字之和等于0，而且段数越多越好，记为k，那么很明显，答案就是n-k，现在问题来了，如何来求满足题意的最大的k。首先，我们考虑用前缀和来存放，如果遇到两个位置，前缀和相等，那么中间那一段数字之和肯定等于0。接下来就是一个跳跃性的思考了，那么如果某个前缀和的值出现了k次，是不是就是我们上述的k呢？答案是正确的！假如有k个位置的前缀和相等，那么中间k-1段子串内数字之和一定都是0，由于总数是0，那么最前面和最后面连着的那一段也肯定是0，所以，我们记录所有的前缀和的值，然后排序。然后用取尺法记录一个数出现的最多次数，就做完了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;strstream&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define MOD 1000000007#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int n,maxx=1,tmp; ll pre=0; map&lt;ll,int&gt;log; cin&gt;&gt;n; for0(i, n)&#123; cin&gt;&gt;tmp; pre+=tmp; if (log.count(pre)) &#123; log[pre]++; maxx=max(maxx, log[pre]); &#125;else log[pre]=1; &#125; cout&lt;&lt;n-maxx&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-5970 最大公约数]]></title>
    <url>%2F2019%2F03%2F22%2FHDU-5970%2F</url>
    <content type="text"><![CDATA[题意给一个函数 12345678910int f(int x,int y)&#123; int c=0; while(y&gt;0)&#123; c++; t=x%y; x=y; y=t; &#125; return c*x*x;&#125; 给出n,m,p，求$\Large\sum\limits_{i=1}^n\sum\limits_{j=1}^m\lfloor\frac {i*j} {f(i,j)}\rfloor$ 题解 ans=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{i+j*k\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor\\=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*(k+p*c))} {c*x*x}\rfloor\\ =\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor+\frac {p*j*j} {x*x}代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)using namespace std;#define mod (int)(1e9 + 7)#define N (int)(1.1e5)int f[700][700], c[700][700];void fun(int x, int y) &#123; int b = 0, i = x, j = y; while (y) &#123; b++; int tmp = x % y; x = y; y = tmp; &#125; c[i][j] = b; f[i][j] = b * x * x;&#125;int main() &#123;#ifndef ONLINE_JUDGE //freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif for1(i, 666) for1(j, 666) fun(i, j); int t; ind(t); while (t--) &#123; int n, m, p; ll ans = 0; scanf("%d%d%d", &amp;n, &amp;m, &amp;p); for1(j, m) &#123; for (int i = 1; i &lt;= j &amp;&amp; i &lt;= n; i++) &#123; int k = (n - i) / j; int tt = c[i][j] * j * j / f[i][j]; for (int q = 0; q &lt; c[i][j]&amp;&amp;q&lt;=k ; q++) &#123; //if (i + q * j &gt; n) break; //ll t = (n - (i + j * q)) / (c[i][j] * j) + 1; ll t=(k-q)/c[i][j]+1; ll tmp=(i+j*q)*j/f[i][j]; ans=(ans+tmp*t%p+(t-1)*t/2%p*tt%p)%p; // ll b = (i + j * q) * j / f[i][j]; // ans = (ans + b * t % p + (t - 1) * t / 2 % p * tt % p) % p; &#125; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1050 To the Max]]></title>
    <url>%2F2019%2F03%2F21%2FPOJ-1050%2F</url>
    <content type="text"><![CDATA[题意求最大子矩阵和。 题解枚举列区间，将该区间的值压缩到一起，转化成求一维最大字段。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;vector&gt;#define ll long long#define inf 0x3f3f3f3f#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main() &#123; ios::sync_with_stdio(false); int n, a[101][101],b[101][101]; cin &gt;&gt; n; mem0(b); for0(i, n) &#123; for0(j, n)&#123; cin&gt;&gt;a[i][j]; b[i][j+1]=b[i][j]+a[i][j]; &#125; &#125; int ans=0; for0(i, n) forl(j, i+1, n)&#123; int tmp=0; for0(k, n)&#123; tmp+=b[k][j]-b[k][i]; if (tmp&lt;0) &#123; tmp=0; &#125;else if(tmp&gt;ans)&#123; ans=tmp; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1024 Max Sum Plus Plus]]></title>
    <url>%2F2019%2F03%2F21%2FHDU-1024%2F</url>
    <content type="text"><![CDATA[题意给你一个序列n个数组成，然后让你在里面找到m个子序列，让这m个子序列的和最大。 题解$dp[i][j]$表示的是第j个数字在第i个子序列时的当前最优值。$dp[i][j] = maxx(dp[i][j-1] + num[j] ,maxx(dp[i-1][k]) + num[j])$，k是从1到 $j-1$.可以这么理解这个转移方程，对于当前的这个数字，如果把他放到第i个子序列中有两种情况，一个是他作为第i个子序列的第一个数字，另一个就是不作为第一个数字，作为第一个数字的时候是 $max(dp[i-2][k] + num[j]) ,1&lt;=k&lt;i $的意思是从之前的所有中找到 $i-1$ 个子序列的最大值+当前的值，不做为第一个的时候那么他前面的那个数字一定是i序列的，同一个子序列，又不是作为第一个，那么前面的那个货就一定是同一个子序列的，那么当前的值是$dp[i][j-1] + num[j]$,在两种决策中选择一个最有的就行了，还有就是$max(dp[i-1][k]+num[j])$的这个地方可以开一个数组记录下来，不能每次都跑，跑不起，再有就是这个题目没有给m的范围，所以开不了二维数组（目测不是很大，大的话会超时，但是肯定是先超内存在超时，所以为了保险，还是吧$dp[][]$压缩成一维的）那么状态转移就边成这样了$dp[j]$表示的是 j这个人在当前的这个子序列中的最优值，mk[j]表示的是在上一个子序列中1—j的dp的最大值，所以就变成 $dp[j] = maxx(dp[j-1] + num[j] ,mk[j-1]+num[j])$;还是 max(作为i个子序列的第一个元素，不是第一个元素取一个最大值)。在解释下代码的核心部分。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;ctime&gt;#include &lt;strstream&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int d[1000006],a[1000006],pre_max[2][1000006];int main()&#123; int n,m; while (cin&gt;&gt;m&gt;&gt;n) &#123; memset(d, 0, sizeof(d)); memset(pre_max, 0, sizeof(pre_max)); for (int i=1; i&lt;=n; i++) scanf("%d",&amp;a[i]); int maxx; //pre_max[0][0]=-99999999;pre_max[1][0]=-99999999; for (int i=1; i&lt;=m; i++) &#123; maxx=-9999999; for (int j=i; j&lt;=n; j++) &#123; d[j]=max(d[j-1]+a[j], pre_max[(i+1)%2][j-1]+a[j]); maxx=max(maxx, d[j]); pre_max[i%2][j]=maxx; &#125; &#125; cout&lt;&lt;pre_max[m%2][n]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-2559 Largest Rectangle in a Histogram]]></title>
    <url>%2F2019%2F03%2F21%2FPOJ-2559%2F</url>
    <content type="text"><![CDATA[题意 求柱形图中的最大矩形面积。 题解法一: 求每个点左边连续比它大的最左边的下标，保存在 $l[]$ 数组里,求每个点右边连续比它大的最右边的下标，保存在 $r[]$ 数组里 法二: 维护一个单调栈, 如果 $h$ 大于栈顶元素，则入栈, 否则，将栈内元素出栈，直到满足上面的条件。出栈时，我们要将出栈元素对之后问题的影响全部考虑进行处理，才能保证做法的正确性。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;ctime&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int n,tmp; while (cin&gt;&gt;n&amp;&amp;n) &#123; ll ans=0; vector&lt;pair&lt;int, int&gt; &gt;sta;//点的权值 权值大于等于该点的数量 for0(i, n)&#123; cin&gt;&gt;tmp; int count=0; forn(i, sta.size()-1)&#123; if (sta[i].first&gt;tmp) &#123; count+=sta[i].second; ans=max(ans, (ll)sta[i].first*count); sta.pop_back(); &#125;else break; &#125; sta.push_back(pair&lt;int, int&gt;(tmp,count+1)); &#125; int count=0; forn(i, sta.size()-1)&#123; count+=sta[i].second; ans=max(ans, (ll)sta[i].first*count); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[城市建设]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[题意n 个城市，m 条道路，每条道路有一个权值(可能为负)，每个点有一个权值，表示修建码头的费用(为-1时表示不可以修建码头)。 题解ans1不修建码头的最小生成树ans2额外添加一个0号城市，将可建立码头的城市与它相连，求出的最小生成树当不建码头也能联通时，答案为min(ans1,ans2)，否则答案为 ans2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 2e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct Edge&#123; int u,v,c; Edge()&#123;&#125; Edge(int a,int b,int _c)&#123; u=a,v=b,c=_c; &#125; bool operator &lt;(const Edge y)const&#123; return c&lt;y.c; &#125;&#125;edge[N];int uni[N];int find_r(int x)&#123; if(x==uni[x])return x; else return uni[x]=find_r(uni[x]);&#125;int merge(Edge x)&#123; int fa=find_r(x.u),fb=find_r(x.v); if(fa!=fb)&#123; uni[fa]=fb; return 1; &#125; if(x.c&lt;0)return -1; else return 0;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,c,w,Size=0; ll ans1=0,ans2=0; scanf("%d%d",&amp;n,&amp;m); for0(i,m)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); edge[Size++]=Edge(u,v,c); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); int cnt=0; for0(i,Size)&#123; switch(merge(edge[i]))&#123; case 1: ans1+=edge[i].c; cnt++; break; case -1: ans1+=edge[i].c; &#125; &#125; for1(i,n)&#123; ind(w); if(w&gt;0)edge[Size++]=Edge(0,i,w); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); for0(i,Size)&#123; if(merge(edge[i]))ans2+=edge[i].c; &#125; if(cnt==n-1)ans2=min(ans2,ans1); printf("%lld\n",ans2); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%2F</url>
    <content type="text"><![CDATA[题意$f(x)$为斐波那契数列，求$\large\left(\sum\limits_{i=1}^nf(i)\right) mod f(m) mod p$ $0&lt;n,m,p&lt;1e18$ 题解 f(n+m)=f(n+1)f(m)+f(n)f(m-1) \\ f(n)\ mod\ f(m)=f(n-m)f(m-1)\ mod\ f(m)\\ f(n)\ mod \ f(m)=f(m-1)^{\frac n m}f(n\%m)\ mod\ f(m)\\ f(n)^2=(-1)^{n+1}+f(n-1)f(n+1)\\ f(m-1)^2\ mod\ f(m)=(-1)^m m 为偶数 $\frac n m$为偶数，$f(n) mod f(m)=f(n\%m)$ $\frac n m$为奇数，$f(n) mod f(m)=f(m-1)f(n\%m) mod f(m)$ m 为奇数 $\frac n m$为偶数，$\frac n {2m}$为偶数，$f(n) mod f(m)=f(n\%m)$ $\frac n m$为偶数，$\frac n {2m}$为奇数，$f(n) mod f(m)=f(m)-f(n\%m)$ $\frac n m$为奇数，$\frac n {2m}$为偶数，$f(n) mod f(m)=f(m-1)f(n\%m) mod f(m)$ $\frac n m$为奇数，$\frac n {2m}$为奇数，$f(n) mod f(m)=f(m)-f(m-1)f(n\%m) mod f(m)$ 简化$f(m-1)f(n\%m) mod f(m)$ 性质：若$n\ge1,r\ge2$，则$f(n)f(n+r-1)-f(n+1)f(n+r-2)=(-1)^{n+1}f(r-2)$ 令$k=n\%m,k=n+1,m-1=n+r-2$，则$f(n)f(k-1)-f(m-1)f(k)=(-1)^kf(m-k)$ 所以$f(m-1)f(k) mod f(m)=(-1)^{k+1}f(m-k) mod f(m)$ 当$k$为奇时，$f(m-1)f(n\%m) mod f(m)=f(m-k)$ 当$k$为偶时，$f(m-1)f(n\%m) mod f(m)=f(m)-f(m-k)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f; ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct matrix &#123; ll a[2][2]; matrix()&#123; mem0(a); &#125;&#125;;ll qMulti(ll x,ll y,ll mod)&#123; //O(1)快速乘 return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod; &#125;matrix mat_mul(matrix x, matrix y) &#123; matrix res; for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) res.a[i][j] = (res.a[i][j] + qMulti(x.a[i][k] , y.a[k][j],mod) ) % mod; return res;&#125;ll mat_pow(ll n) &#123; if (n &lt;= 2) return 1; n -= 2; matrix c, res; c.a[0][0] = c.a[0][1] = c.a[1][0] = 1; for (int i = 0; i &lt; 2; i++) res.a[i][i] = 1; while (n) &#123; if (n % 2) res = mat_mul(res, c); c = mat_mul(c, c); n /= 2; &#125; return (res.a[0][0] + res.a[0][1]) % mod;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll n,m,p; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; mod=p; n+=2; ll k=n/m; if(n%m==0)&#123; cout&lt;&lt;((mat_pow(m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; int Sign; if(m%2)Sign=-1; else Sign=1; if(k%2)&#123; k/=2; if(k%2==0)Sign=1; if(n%m%2==0)Sign=-Sign; if(Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; k/=2; if(k%2&amp;&amp;Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125; &#125; return 0;&#125; 引用https://blog.csdn.net/acdreamers/article/details/21822165]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形排版]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9B%BE%E5%BD%A2%E6%8E%92%E7%89%88%2F</url>
    <content type="text"><![CDATA[题意小明需要在一篇文档中加入 N 张图片，其中第 i 张图片的宽度是 Wi，高度是 Hi。假设纸张的宽度是 M，小明使用的文档编辑工具会用以下方式对图片进行自动排版： 该工具会按照图片顺序，在宽度 M 以内，将尽可能多的图片排在一行。该行的高度是行内最高的图片的高度。例如在 M=10 的纸张上依次打印 3x4, 2x2, 3x3 三张图片，则效果如下图所示，这一行高度为4。(分割线以上为列标尺，分割线以下为排版区域；数字组成的矩形为第x张图片占用的版面) 如果当前行剩余宽度大于0，并且小于下一张图片，则下一张图片会按比例缩放到宽度为当前行剩余宽度(高度向上取整)，然后放入当前行。例如再放入一张4x9的图片，由于剩余宽度是2，这张图片会被压缩到2x5，再被放入第一行的末尾。此时该行高度为5： 如果当前行剩余宽度为0，该工具会从下一行开始继续对剩余的图片进行排版，直到所有图片都处理完毕。此时所有行的总高度和就是这 N 张图片的排版高度。例如再放入11x1, 5x5, 3x4 的图片后，效果如下图所示，总高度为11： 现在由于排版高度过高，图片的先后顺序也不能改变，小明只好从 N 张图片中选择一张删除掉以降低总高度。他希望剩余N-1张图片按原顺序的排版高度最低，你能求出最低高度是多少么？ 题解预处理以第 i 张图为行首的最低高度，然后枚举删图。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;pii a[N],b[N];int suf[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m,n,w,h; scanf("%d%d",&amp;m,&amp;n); for0(i,n)&#123; scanf("%d%d",&amp;w,&amp;h); a[i]=pii(w,h); &#125; for0(i,n)&#123; w=m; h=0; int len=i; for(;len&lt;n&amp;&amp;w;len++)&#123; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; // cout&lt;&lt;h&lt;&lt;endl; b[i]=pii(len,h); &#125; // puts(""); // for0(i,n)cout&lt;&lt;b[i].first&lt;&lt;' '&lt;&lt;b[i].second&lt;&lt;endl; for(int i=n-1;i&gt;=0;i--)&#123; suf[i]=suf[b[i].first]+b[i].second; &#125; // for0(i,n)cout&lt;&lt;suf[i]&lt;&lt;endl; int ans=inf,flag=0,tot=0; while(flag&lt;n)&#123; for(int i=flag;i&lt;b[flag].first;i++)&#123; w=m; h=0; int len=flag; for(;len&lt;n&amp;&amp;w;len++)&#123; if(len==i)continue; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; ans=min(ans,tot+h+suf[len]); &#125; tot+=b[flag].second; flag=b[flag].first; // tot+= &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格子刷油漆]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%A0%BC%E5%AD%90%E5%88%B7%E6%B2%B9%E6%BC%86%2F</url>
    <content type="text"><![CDATA[题意给一个$2*N$的矩阵，可以从任意一个格子刷起，但只能移动到和它相邻的格子（可以对角），求总的方案数，对$1e9+7$取模。 题解设a[n]为起点为某一角落长度为n终点任意的情况数，b[n]为起点为某一角落长度为n终点必须同列的情况数。 $b[i]=2^{i-1}$ 当起点在四个角落，以左上角为例 情况一，先向下移动，再向右移动某个位置，情况数相当于 做长度为i-1的终点任意的情况数*2 因为不需要在回到第一列，而且到第二列的时候可能是第一行或者第二行，即$a[i-1]*2$ 情况二，从起点出发最终回到第一列的第二行，那么情况数就是b[i]。 先进入第二列，然后返回第一列另一个位置，然后再回第二列，即$22a[i-2]$ 当起点在中间 情况一，向左运动后回到第i列然后向右运动 情况二，向右运动后回到第i列然后向左运动 \sum\limits_{i=2}^{n-1}2*(b[i+1]*a[n-i]+b[n-i+2]*a[i-1]) $a[1]=1,a[2]=6$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll a[N],b[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,ans=0; b[1]=1; forl(i,2,1e3)&#123; b[i]=b[i-1]*2%mod; &#125; a[1]=1;a[2]=6; forl(i,3,1e3)&#123; a[i]=(2ll*a[i-1]+b[i]+4ll*a[i-2])%mod; &#125; ind(n); if(n==1)&#123; puts("2"); return 0; &#125; ans=4ll*a[n]%mod; forl(i,2,n-1)&#123; ans=(ans+2ll*(b[i+1]*a[n-i]%mod+b[n-i+2]*a[i-1]%mod))%mod; &#125; printf("%d\n",ans); return 0;&#125; 引用https://blog.csdn.net/qq_35078631/article/details/54730870]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高僧斗法]]></title>
    <url>%2F2019%2F03%2F20%2F%E9%AB%98%E5%83%A7%E6%96%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题意n 个物品放在阶梯，向上移动物品，不能越过挡在前面的物品，最后物品都挤在高段台阶，不能移动的输。 题解两两一组，当移动上面的，可以移动下面的相同距离，所以可以把每组之间的间距看作一堆石子，转化为 Nim 博弈。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vii v,vv;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int x; while(~ind(x))v.pb(x); int Xor=0; for(int i=0;i+1&lt;v.size();i+=2)&#123; vv.pb(v[i+1]-v[i]-1); Xor^=vv.back(); &#125; if(Xor)&#123; for0(i,v.size()-1)&#123; forl(j,v[i]+1,v[i+1]-1)&#123; if(i%2)&#123; if((Xor^vv[i/2])==vv[i/2]+j-v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125;else&#123; if((Xor^vv[i/2])==vv[i/2]-j+v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125; &#125; &#125; &#125;else puts("-1"); return 0;&#125; graph TD 1-->3 2-->3 3-->4 3-->5]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国王的烦恼]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[题意n 个点 m 条边，每条边有一个权值表示该边消失的时间，求有新的点不联通的时刻的数量。 题解以时间从大到小排序，用并查集反向建图，注意同时刻只能计一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e4;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int uni[N];int find_r(int x)&#123; if(uni[x]==x)return x; else return uni[x]=find_r(uni[x]);&#125;bool merge(int a,int b)&#123; int fa=find_r(a),fb=find_r(b); if(fa==fb)return 0; uni[fa]=fb; return 1;&#125;struct edg&#123; int u,v,w; bool operator &lt; (const edg y)const&#123; return w&gt;y.w; &#125;&#125;edge[10*N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; scanf("%d%d",&amp;n,&amp;m); for1(i,n)uni[i]=i; for0(i,m)scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); sort(edge,edge+m); int ans=0,time=0; for0(i,m)&#123; // cout&lt;&lt;edge[i].u&lt;&lt;' '&lt;&lt;edge[i].v&lt;&lt;' '&lt;&lt;edge[i].w&lt;&lt;endl; if(merge(edge[i].u,edge[i].v))&#123; if(edge[i].w!=time)&#123; time=edge[i].w; ans++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1062]]></title>
    <url>%2F2019%2F03%2F02%2FCF-1062%2F</url>
    <content type="text"><![CDATA[D. Fun with Integers题意You are given a positive integer n​ greater or equal to 2. For every pair of integers a and b (2≤|𝑎|,|𝑏|≤𝑛2≤|a|,|b|≤n), you can transform a into b if and only if there exists an integer x such that 1&lt;|x| and (a⋅x=b or b⋅x=a), where |x| denotes the absolute value of x. After such a transformation, your score increases by |x| points and you are not allowed to transform a into b nor b into a anymore. Initially, you have a score of 0. You can start at any integer and transform it as many times as you like. What is the maximum score you can achieve? 题解答案为 2~n 每个数的因子( 范围为$[2,n)$ )之和。 \Huge\sum s_i代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; ll ans=0; cin&gt;&gt;n; forl(i,2,n)&#123; ans+=1ll*i*(n/i-1); &#125; cout&lt;&lt;ans*4&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1076]]></title>
    <url>%2F2019%2F03%2F02%2FCF-1076%2F</url>
    <content type="text"><![CDATA[D. Edge Deletion题意the length of the shortest path from vertex 1 to vertex i as $d_i$ . You have to erase some edges of the graph so that at most k edges remain. Let’s call a vertex i good if there still exists a path from 1 to i with length $d_i$ after erasing the edges. Your goal is to erase the edges in such a way that the number of good vertices is maximized. 题解先跑个最短路，再搜索，取最短路上的边。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf = 0x3f3f3f3f;const ll mod = 1e9 + 7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b) &#123; return sign(a - b); &#125;struct Edge &#123; int v, w, nxt, no;&#125; edge[2 * N];int fir[N], cnt;void addedge(int u, int v, int w, int no) &#123; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].nxt = fir[u]; edge[cnt].no = no; fir[u] = cnt++;&#125;struct node &#123; int u; ll d; node(int u, ll d) : u(u), d(d) &#123;&#125; bool operator&lt;(const node &amp;a) const &#123; return d &gt; a.d; &#125;&#125;;bool used[N];ll d[N];void dijkstra() &#123; priority_queue&lt;node&gt; que; meminf(d); d[1] = 0; que.push(node(1, d[1])); while (!que.empty()) &#123; int u = que.top().u; que.pop(); if (used[u]) continue; used[u] = 1; for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] &gt; d[u] + w) &#123; d[v] = d[u] + w; que.push(node(v, d[v])); &#125; &#125; &#125;&#125;bool used_edge[N];void init() &#123; mem_1(fir); cnt = 0;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif // ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); init(); int n, m, k, u, v, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for1(i, m) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w, i); addedge(v, u, w, i); &#125; if (k == 0) &#123; puts("0\n"); return 0; &#125; dijkstra(); queue&lt;int&gt; que; que.push(1); mem0(used); used[1] = 1; int ans = 0; while (que.size()) &#123; int u = que.front(); que.pop(); for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] == d[u] + w) &#123; used_edge[edge[i].no] = 1; used[v] = 1; ans++; if (ans == k) break; que.push(v); &#125; &#125; if (ans == k) break; &#125; printf("%d\n", ans); for1(i, m) &#123; if (used_edge[i]) printf("%d ", i); &#125; puts(""); return 0;&#125; E. Vasya and a Tree题意给一颗树，将 v 和与 v 距离小于 d 的 v 的子节点的权值加上 x，输出所有节点的权值。 题解保存每个点每次加权的终点和 x。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vi;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vi node[N];int dep[N];ll change[N];bool vis[N];int maxx;void dfs(int r,int dph)&#123; dep[r]=dph; vis[r]=1; maxx=max(maxx,dph); for(int v:node[r])if(vis[v]==0)dfs(v,dph+1);&#125;struct da&#123; int end,x; da()&#123;&#125; da(int a,int b):end(a),x(b)&#123;&#125;&#125;;vector&lt;da&gt; weight[N];ll tmpc[N];void ddfs(int r,int depth,ll sum)&#123; for(auto i:weight[r])&#123; sum+=i.x; tmpc[i.end]+=i.x; &#125; change[r]+=sum; sum-=tmpc[depth]; vis[r]=1; for(int v:node[r])if(vis[v]==0)ddfs(v,depth+1,sum); for(auto i:weight[r])tmpc[i.end]-=i.x;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,d,x; ind(n); for0(i,n-1)&#123; scanf("%d%d",&amp;u,&amp;v); node[u].push_back(v); node[v].push_back(u); &#125; dfs(1,1); ind(m); for0(i,m)&#123; scanf("%d%d%d",&amp;v,&amp;d,&amp;x); weight[v].push_back(da(min(dep[v]+d,maxx),x)); &#125; mem0(vis); ddfs(1,1,0); for1(i,n)printf("%lld ",change[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
</search>
