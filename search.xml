<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU-5077]]></title>
    <url>%2F2019%2F09%2F13%2FHDU-5077%2F</url>
    <content type="text"><![CDATA[题意给一个真值表，问最少使用多少个二输入与非门能够实现这个真值表的功能。 题解初始值 $15 - 00001111$ $51-00110011$ $85-01010101$ 用一个 $vector$ 表示当前具有的表达式，每次 $dfs$ 都选取两个做与非运算，加入队列再继续 $dfs$ ，有以下几个剪枝 标记 $vector$ 中的元素，避免重复加入 $dfs$ 的参数传入上一次的选取的两个值的下标，每次只取上一次右边的数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sz(a))#define mem_1(a) memset(a, -1, sz(a))#define mem0(a) memset(a, 0, sz(a))#define memcp(a,b) memcpy(a,b,sz(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define sz(a) (int)sizeof(a)typedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内 int inf = 0x3f3f3f3f;ll inf_ll = 0x3f3f3f3f3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e5;/*-----------------------------------head----------------------------------------------*/int ans[256];vii v;bool vis[256];void dfs(int dep,int l,int r)&#123; if(dep==11)return; int len=v.size(); for(int i=l;i&lt;len;i++) for(int j=(i==l?r:0);j&lt;=i;j++)&#123;//只取小于i的数，避免重复 int tm=255^(v[i]&amp;v[j]); ans[tm]=min(ans[tm],dep); if(!vis[tm])&#123; vis[tm]=1; v.pu_b(tm); dfs(dep+1,i,j); v.pop_back(); vis[tm]=0; &#125; &#125;&#125;int main() &#123; v.pu_b(15);v.pu_b(51);v.pu_b(85); meminf(ans); ans[0]=vis[0]=ans[255]=vis[255]=1; for(int i:v)ans[i]=vis[i]=1; dfs(2,0,0); for0(i,256)&#123; printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-750E]]></title>
    <url>%2F2019%2F09%2F10%2FCF-750E%2F</url>
    <content type="text"><![CDATA[题意输入一个字符串，区间询问 $[s_l,s_r]$ 中，删去最少的字符，使得出现子序列 $”2019”$ ，而不出现 $”2018”$ 题解 $5$ 个状态： 0 - $””$ 1 - $”2”$ 2 - $”20”$ 3 - $”201”$ 4 - $”2019”$ 使用一个 $5\times5$ 的矩阵来表示每个点的状态转移所需要的代价，区间查询即这个区间的矩阵的乘积，这里的乘积有些不同，有点像 $floyd$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sz(a))#define mem_1(a) memset(a, -1, sz(a))#define mem0(a) memset(a, 0, sz(a))#define memcp(a,b) memcpy(a,b,sz(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define sz(a) (int)sizeof(a)typedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内 int inf = 0x3f3f3f3f;ll inf_ll = 0x3f3f3f3f3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e5;/*-----------------------------------head----------------------------------------------*/char s[N],t[N];struct node&#123; int a[5][5]; node()&#123;meminf(a);&#125; node operator+(const node&amp; Y)const&#123; node res; for0(i,5) for0(j,5) for0(k,5)&#123; res.a[i][j]=min(res.a[i][j],a[i][k]+Y.a[k][j]); &#125; return res; &#125;&#125;Sum[N&lt;&lt;2];void PushUp(int rt)&#123;Sum[rt]=Sum[rt&lt;&lt;1]+Sum[rt&lt;&lt;1|1];&#125;//PushUp函数更新节点信息 ，这里是求和void Build(int l,int r,int rt)&#123; //Build函数建树，l,r表示当前节点区间，rt表示当前节点编号 if(l==r) &#123;//若到达叶节点 // scanf("%d",&amp;Sum[rt]); //Sum[rt]=A[l];//储存数组值 for0(i,5)Sum[rt].a[i][i]=0; if(t[l]=='2')&#123; Sum[rt].a[0][0]=1; Sum[rt].a[0][1]=0; &#125;else if(t[l]=='0')&#123; Sum[rt].a[1][1]=1; Sum[rt].a[1][2]=0; &#125;else if(t[l]=='1')&#123; Sum[rt].a[2][2]=1; Sum[rt].a[2][3]=0; &#125;else if(t[l]=='9')&#123; Sum[rt].a[3][3]=1; Sum[rt].a[3][4]=0; &#125;else if(t[l]=='8')&#123; Sum[rt].a[3][3]=1; Sum[rt].a[4][4]=1; &#125; return; &#125; int m=(l+r)&gt;&gt;1; Build(l,m,rt&lt;&lt;1); Build(m+1,r,rt&lt;&lt;1|1); PushUp(rt);//更新信息 &#125;node Query(int L,int R,int l,int r,int rt)&#123;//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号 if(L &lt;= l &amp;&amp; r &lt;= R)&#123;//在区间内，直接返回 return Sum[rt]; &#125; int m=(l+r)&gt;&gt;1; node ANS; if(L &lt;= m) ANS=ANS+ Query(L,R,l,m,rt&lt;&lt;1); if(R &gt; m) ANS=ANS+ Query(L,R,m+1,r,rt&lt;&lt;1|1); return ANS;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,q; in(n,q); in(s+1); for(int i = 1; i &lt;= n; i++)&#123; t[i] = s[n - i + 1]; &#125; Build(1,n,1); int l,r; while(q--)&#123; in(l,r); node tmp=Query(n-r+1,n-l+1,1,n,1); if(tmp.a[0][4]==inf)out(-1,1); else out(tmp.a[0][4],1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯-车轮轴迹]]></title>
    <url>%2F2019%2F09%2F04%2F%E8%93%9D%E6%A1%A5%E6%9D%AF-%E8%BD%A6%E8%BD%AE%E8%BD%B4%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[题意 求圆心轨迹的总长度。 题解圆有两种状态，一是在线段上，二是在端点上。平移或旋转时可能会被线段阻挡，也可能会被端点阻挡。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type Y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2]或[k2,k1] 内 ll inf =0x3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e5;/*-----------------------------------head----------------------------------------------*/struct Point&#123; db x,y; Point()&#123;&#125; Point(db _x,db _y) : x(_x),y(_y)&#123;&#125; Point operator + (const Point &amp;k1) const&#123;return Point(k1.x+x,k1.y+y);&#125; Point operator - (const Point &amp;k1) const&#123;return Point(x-k1.x,y-k1.y);&#125; Point operator * (const db k1) const&#123;return Point(x*k1,y*k1);&#125; Point operator / (const db k1) const&#123;return Point(x/k1,y/k1);&#125; db operator * (const Point b) const&#123;return x * b.x + y * b.y;&#125;//点积 db operator ^ (const Point b) const&#123;return x * b.y - y * b.x;&#125;//叉积,顺时针为负 bool operator == (const Point &amp;k1) const&#123;return db_cmp(x,k1.x)==0&amp;&amp;db_cmp(y,k1.y)==0;&#125; Point &amp; operator += (const Point &amp;k1) &#123;x+=k1.x;y+=k1.y;return *this;&#125; Point &amp; operator -= (const Point &amp;k1) &#123;x-=k1.x;y-=k1.y;return *this;&#125; Point &amp; operator *= (const db k1) &#123;*this=*this*k1;return *this;&#125; Point &amp; operator /= (const db k1) &#123;*this=*this/k1;return *this;&#125; Point rotate(db k1)&#123;return Point(x*cos(k1)-y*sin(k1),x*sin(k1)+y*cos(k1));&#125;// 逆时针旋转 Point rotate90()&#123;return Point(-y,x);&#125; db abs()&#123;return sqrt(x*x+y*y);&#125; db abs2()&#123;return x*x+y*y;&#125; Point unit()&#123;return *this/abs();&#125; db angle()&#123;return atan2(y,x);&#125; void out()&#123;printf("%.10f %.10f\n",x,y);&#125;&#125;;typedef Point Vector;int inmid(Point k1,Point k2,Point k3)&#123;return inmid(k1.x,k2.x,k3.x)&amp;&amp;inmid(k1.y,k2.y,k3.y);&#125;db angleOfTwoVector(Vector a, Vector b) &#123;return fabs(atan2(a ^ b, a * b));&#125;Point proj(Point q,Point k1,Point k2)&#123; // q 到直线 k1,k2 的投影 Point k=k2-k1; return k1+k*((q-k1)*k/k.abs2());&#125;Point reflect(Point q,Point k1,Point k2)&#123;// q 关于直线 k1,k2 的对称点 return proj(q,k1,k2)*2-q;&#125;Point getLL(Point k1,Point k2,Point k3,Point k4)&#123;//直线交点 db w1=(k1-k3)^(k4-k3),w2=(k4-k3)^(k2-k3); return (k1*w2+k2*w1)/(w1+w2);&#125;int intersect(db l1,db r1,db l2,db r2)&#123;//是否有交集 if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return db_cmp(r1,l2)!=-1&amp;&amp;db_cmp(r2,l1)!=-1;&#125;int checkSL(Point k1,Point k2,Point k3,Point k4)&#123;// 求线段 (S) k1,k2 和直线 (L) k3,k4 的交点 return sign((k3-k1)^(k4-k1))*sign((k3-k2)^(k4-k2))&lt;=0;&#125;int checkSS(Point k1,Point k2,Point k3,Point k4)&#123;//两线段是否相交 return intersect(k1.x,k2.x,k3.x,k4.x)&amp;&amp;intersect(k1.y,k2.y,k3.y,k4.y)&amp;&amp;checkSL(k1,k2,k3,k4)&amp;&amp;checkSL(k3,k4,k1,k2);&#125;db disPP(Point k1,Point k2)&#123;return (k2-k1).abs();&#125;db disPP2(Point k1,Point k2)&#123;return (k2-k1).abs2();&#125;db disPS(Point q,Point k1,Point k2)&#123; Point k3=proj(q,k1,k2); if (inmid(k1,k2,k3)) return disPP(q,k3); return min(disPP(q,k1),disPP(q,k2));&#125;db disPL(Point q,Point k1,Point k2)&#123; if(k1==k2)return disPP(q,k1); return fabs((q - k1) ^ (k2 - k1)) / (k2-k1).abs();&#125;db disSS(Point k1,Point k2,Point k3,Point k4)&#123; if (checkSS(k1,k2,k3,k4)) return 0; return min(min(disPS(k1,k3,k4),disPS(k2,k3,k4)),min(disPS(k3,k1,k2),disPS(k4,k1,k2)));&#125;db disSL(Point k1,Point k2,Point k3,Point k4)&#123; if (checkSL(k1,k2,k3,k4)) return 0; return min(disPL(k1,k3,k4),disPL(k2,k3,k4));&#125;int onS(Point q,Point k1,Point k2)&#123;return inmid(k1,k2,q)&amp;&amp;sign((k1-q)^(k2-k1))==0;&#125;struct Line &#123; Point s, t; Line()&#123;&#125; Line(Point _s,Point _t):s(_s),t(_t)&#123;&#125; Vector dir()&#123;return (t-s);&#125; Vector unitDir()&#123;return (t-s).unit();&#125; int place(Point k)&#123;return sign((t-s)^(t-k));&#125; db len()&#123;return (t-s).abs();&#125;&#125;;typedef Line Segment;Point proj(Point q,Line k)&#123;return proj(q,k.s,k.t);&#125;Point reflect(Point q,Line k)&#123;return reflect(q,k.s,k.t);&#125;Point getLL(Line k1,Line k2)&#123;return getLL(k1.s,k1.t,k2.s,k2.t);&#125;bool parallel(Line k1,Line k2)&#123;return sign(k1.dir()^k2.dir())==0;&#125;bool sameDir(Line k1,Line k2)&#123;return parallel(k1,k2)&amp;&amp;sign(k1.dir()*k2.dir())==1;&#125;int checkSS(Segment k1,Segment k2)&#123;return checkSS(k1.s,k1.t,k2.s,k2.t);&#125;int checkSL(Segment k1,Line k2)&#123;return checkSL(k1.s,k1.t,k2.s,k2.t);&#125;db disPS(Point a, Segment b) &#123;return disPS(a,b.s,b.t);&#125;db disPL(Point a, Line b) &#123;return disPL(a,b.s,b.t);&#125;db disSS(Segment k1,Segment k2)&#123;return disSS(k1.s,k1.t,k2.s,k2.t);&#125;db disSL(Segment k1,Line k2)&#123;return disSL(k1.s,k1.t,k2.s,k2.t);&#125;int onS(Point q,Segment k)&#123;return onS(q,k.s,k.t);&#125;Point a[N],center;Line b[N];db r;int main() &#123; int n; db ans=0; in(n); in(r); for0(i,n)in(a[i].x),in(a[i].y); center=Point(a[0].x,a[0].y+r); for1(i,n-1)b[i]=Segment(a[i-1],a[i]); int p=1; bool isOnLine=1; while(p&lt;=n-1)&#123; if(isOnLine)&#123; Vector dir=b[p].dir(); Vector ver=dir.rotate90().unit(); Line vli=Line(b[p].s+ver*r,b[p].t+ver*r); db k=disPP(center,vli.t); isOnLine=0; p++; for(int i=p;i&lt;n;i++)&#123; if((vli.dir()^b[i].dir())&gt;0&amp;&amp;disSS(vli,b[i])&lt;r)&#123; db tm=disPP(center,getLL(vli,b[i]))-dir.abs()*b[i].dir().abs()*r/abs(dir^b[i].dir()); Point t_center=center+vli.dir().unit()*tm; if(db_cmp (disPS(t_center,b[i]),r)==0&amp;&amp;tm&lt;k)&#123; k=tm; isOnLine=1; p=i; &#125; if(r-disPS(b[i].t,vli)&gt;-eps)&#123; db tmp=disPL(b[i].t,vli)*disPL(b[i].t,vli); db tm=sqrt(disPP2(center,b[i].t)-tmp)-sqrt(r*r-tmp); t_center=center+vli.dir().unit()*tm; if(tm&lt;k&amp;&amp;db_cmp (disPS(t_center,b[i]),r)==0)&#123; k=tm; isOnLine=0; p=i+1; &#125; &#125; &#125; &#125; center=center+dir.unit()*k; ans+=k; &#125;else&#123; Point poi=b[p-1].t; db k=angleOfTwoVector(b[p].dir().rotate90(),center-poi); isOnLine=1; for(int i=p+1;i&lt;n;i++)&#123; Line tm=b[i]; Vector ver =tm.dir().rotate90().unit()*r; tm.s=tm.s+ver;tm.t=tm.t+ver; if(r-disPS(poi,tm)&gt;-eps)&#123; db ttm=disPL(poi,tm)*disPL(poi,tm); db tmp=sqrt(disPP2(poi,tm.t)-ttm)-sqrt(r*r-ttm); Point t_center=tm.t-tm.dir().unit()*tmp; db tk=angleOfTwoVector(center-poi,t_center-poi); if(tk&lt;k&amp;&amp;db_cmp(disPS(t_center,b[i]),r)==0)&#123; k=tk; isOnLine=1; p=i; &#125; &#125; db tmp=disPP(poi,b[i].t); if(2*r-tmp&gt;-eps)&#123; tmp=sqrt(r*r-tmp*tmp/4); Point mid=(poi+b[i].t)/2; mid=mid+(b[i].t-poi).rotate90().unit()*tmp; db tk=angleOfTwoVector(center-poi,mid-poi); if(tk&lt;k&amp;&amp;db_cmp(disPS(mid,b[i]),r)==0)&#123; k=tk; isOnLine=0; p=i+1; &#125; &#125; &#125; ans+=k*r; center=(center-poi).rotate(2*pi-k)+poi; &#125; &#125; out(ans,2,1); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ-3992]]></title>
    <url>%2F2019%2F08%2F30%2FBZOJ-3992%2F</url>
    <content type="text"><![CDATA[题意集合 $S\subseteq \{x|x\in[0,m-1]\}$ ，由这些数组成一个长度为 $N$ 的数列，给定整数 $r(r\in[0,m-1])$，求满足数列中所有数的乘积 $\mod m$ 的值等于 $r$ 的不同的数列的有多少个。 题解将 $S$ 和 $x$ 由 $m$ 的原根来表示，这样就可以变乘为加，将集合 $S$ 表示为 $\large f(x)=a_0x^0+a_1x^1+\cdots+a_{m-2}x^{m-2}$ ， $a_i$ 表示 $g^i$ 是否属于 $S$ 将 $f(x)$ 看作一个整体，使用快速幂和 $NTT$ 求解 $f(x)^n$ ，答案就为 $x^r$ 的系数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;typedef int itn;// void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;// void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;// void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;// void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;// void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;// void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;ll inf =0x3f3f3f3f;ll mod = 1004535809;const int M = 2.1e5;const int N = 4.1e4;/*-----------------------------------head----------------------------------------------*/ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int factor[50];int num_factor = 0;void decomposition(ll n) &#123; num_factor = 0; int m=(int)sqrt(n+0.5); for(int i=2;i&lt;=m;i++)&#123; if(n%i==0)&#123; factor[num_factor]=i; while(n%i==0)n/=i; num_factor++; &#125; &#125; if (n &gt; 1) factor[num_factor++] =n;&#125;int root(int m)&#123;//求a在模m意义下的阶 int phi=m-1; decomposition(phi); int g=2; while(1)&#123; bool yes=1; for0(i,num_factor)&#123; if(qPow(g,phi/factor[i],m)==1)&#123; yes=0; break; &#125; &#125; if(yes)break; g++; &#125; return g;&#125;int Map[N];int n,r[N];ll g=3,inv_g,inv_n;void init(int a,int b)&#123; int L=0;n=1; while(n &lt; a + b) n &lt;&lt;= 1,L++; inv_g=qPow(3,mod-2,mod); inv_n = qPow(n,mod-2,mod); for(int i = 0; i &lt; n; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); &#125;inline void NTT(int *A, int type) &#123;//type=1 系数-&gt;点值 ; type=-1 点值-&gt;系数 for(int i = 0; i &lt; n; i++) if(i &lt; r[i]) swap(A[i], A[r[i]]); for(int mid = 1; mid &lt; n; mid &lt;&lt;= 1) &#123; ll Wn = qPow( type == 1 ? g : inv_g , (mod - 1) / (mid &lt;&lt; 1),mod); for(int j = 0; j &lt; n; j += (mid &lt;&lt; 1)) &#123; ll w = 1; for(int k = 0; k &lt; mid; k++, w = (w * Wn) % mod) &#123; int x = A[j + k], y = w * A[j + k + mid] % mod; A[j + k] = (x + y) % mod, A[j + k + mid] = (x - y + mod) % mod; &#125; &#125; &#125; if(type==-1) for0(i,n)A[i]=A[i]*inv_n%mod;&#125;int ans[N],a[N],b[N];int m;void mult(int a[],int b[])&#123; NTT(a,1); NTT(b,1); for(int i=0;i&lt;n;i++) a[i]=1ll*a[i]*b[i]%mod; NTT(a, -1); for(int i=m-1;i&lt;2*m-1;i++)&#123; a[i%(m-1)]=(a[i%(m-1)]+a[i])%mod; a[i]=0; &#125;&#125;int main() &#123; int N,x,s,y; in(N,m,x,s); int rt=root(m),tm=1; for(int i=0;i&lt;m-1;i++)&#123; Map[tm]=i; tm=tm*rt%m; &#125; Map[0]=m-1; x=Map[x]; bool have0=0; for0(i,s)&#123; in(y); a[Map[y]]=1; if(y==0)have0=1; &#125; if(x==m-1)&#123; if(have0)&#123; out((qPow(s,N,mod)-qPow(s-1,N,mod)+mod)%mod,1); &#125;else out(0,1); return 0; &#125; ans[0]=1;a[m-1]=0; init(m-1,m-1); while(N)&#123; if(N%2)&#123; memcpy(b,a,sizeof(int)*(2*m)); memcp(b,a); mult(ans,b); &#125; memcpy(b,a,sizeof(int)*(2*m)); mult(a,b); N/=2; &#125; out(ans[x],1); return 0;&#125;]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>ntt</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1207]]></title>
    <url>%2F2019%2F08%2F29%2FCF-1207%2F</url>
    <content type="text"><![CDATA[G. Indie Album题意有 $n$ 个字符串,对于第 $i$ 个字符串通过以下两种方式中的一个给出。 $1 c$，该字符串只含一个字符 $c$ 。 $2 x c$ ,该字符串为第 $x(1\le x&lt;i)$ 个字符串末尾添加一个字符 $c$ 得到。 有 $m$ 次询问，每次询问给出一个字符串 $s$ 和位置编号 $x$,问在上述第 $x$ 个字符串中，字符串 $s$ 出现了几次。 题解对询问构建 $AC$自动机，因为文本串是树形结构，我们可以跑一个 $dfs$ 枚举所有文本串，每次都添加一个字符，当回溯回去的时候删除这个字符对答案的贡献。 因为每个匹配串在文本串中出现的次数为将文本串在 $AC$自动机上跑一遍并将走到的位置权值 $+1$，该字符串所对应的 $fail$ 节点的子树权值和。所以我们拎出 $fail$ 树，对其 $dfs$ 序构造树状数组。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;ll inf =0x3f3f3f3f;ll mod = 1e9+7;const int M = 2.1e5;const int N = 4.1e5;/*-----------------------------------head----------------------------------------------*/ const int MAX = 26;int tot;vii failTree[N];struct Node &#123; int id; Node *Next[MAX]; Node *Fail; //失配指针,类似next数组,最大的next是和自身比较,fail是和其它匹配串比较 Node() &#123; memset(Next, 0, sizeof(Next)); Fail = 0; id=tot++; &#125;&#125; * root,*pp;int Insert(char s[]) &#123; Node *p = root; int len=strlen(s); for(int i=0;i&lt; len;i++) &#123; int c = s[i] - 'a'; if (p-&gt;Next[c] == NULL) &#123; Node *newnode = new Node; p-&gt;Next[c] = newnode; p = newnode; &#125; else p = p-&gt;Next[c]; &#125; return p-&gt;id;&#125;void BuildFail() &#123; queue&lt;Node *&gt; que; root-&gt;Fail=root; for(int i=0;i&lt;26;i++)&#123; if(root-&gt;Next[i])&#123; root-&gt;Next[i]-&gt;Fail=root; que.push(root-&gt;Next[i]); &#125;else root-&gt;Next[i]=root; &#125; while (!que.empty()) &#123; Node *p = que.front(); que.pop(); failTree[p-&gt;Fail-&gt;id].pu_b(p-&gt;id); for(int i=0;i&lt;26;i++)&#123; if(p-&gt;Next[i])&#123; p-&gt;Next[i]-&gt;Fail=p-&gt;Fail-&gt;Next[i]; que.push(p-&gt;Next[i]); &#125;else p-&gt;Next[i]=p-&gt;Fail-&gt;Next[i]; &#125; &#125;&#125;int L[N],R[N],cnt;void Dfs(int rt)&#123; L[rt]=cnt++; for(int v:failTree[rt])&#123; Dfs(v); &#125; R[rt]=cnt-1;&#125;int sum[N];void add(int p,int x,int n)&#123; //a[p]+=x,数组为[1,n] while(p&amp;&amp;p&lt;=n)sum[p]+=x,p+=p&amp;-p;&#125;ll query(int p)&#123; ll ans = 0; while(p)ans+=sum[p],p-=p&amp;-p; return ans;&#125;struct NODE&#123; char c; vector&lt;pii&gt; v;&#125;a[N]; vii node[N];char s[N];int ans[N];void dfs(int rt)&#123; for(int v:node[rt])&#123; Node *tmp=pp; pp = pp-&gt;Next[c-'a']; add(L[pp-&gt;id],1,cnt-1); for(auto i:a[v].v)ans[i.se]=query(R[i.fi])-query(L[i.fi]-1); dfs(v); add(L[pp-&gt;id],-1,cnt-1); pp=tmp; &#125;&#125;int main() &#123; int n,m,tp,v; root = new Node; pp=root; in(n); for1(i,n)&#123; in(tp); if(tp==1)&#123; in(s); node[0].pu_b(i); &#125;else&#123; in(v);in(s); node[v].pu_b(i); &#125; a[i].c=s[0]; &#125; in(m); for1(i,m)&#123; in(v);in(s); a[v].v.pu_b(pii(Insert(s),i)); &#125; BuildFail(); Dfs(0); dfs(0); for1(i,m)out(ans[i],1); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>binary indexed tree</tag>
        <tag>dfs</tag>
        <tag>ac automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1152]]></title>
    <url>%2F2019%2F08%2F27%2FCF-1152%2F</url>
    <content type="text"><![CDATA[D. Neko and Aki’s Prank题意将长度为 $2n$ 的所有合法括号匹配放入字典树中，求这棵树的最大的边集，边集里的边两两不相连 题解对于括号匹配 $(((),()((,(()($ 来说，其子树是一样的， $dp[i][j]$ 表示深度为 $i$ 的左括号比右括号多 $j$ 的括号匹配的答案，我们直接贪心的取边，能取就取，使用一个 $vis[i][j]$ 来标记点是否取了，$dp[i][j]=dp[i+1][j+1]+dp[i+1][j-1]+(vis[i+1][j+1]==0||vis[i+1][j-1]==0)$，注意判断 $[i][j]$ 是否是合法的节点 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long double ldb;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;ll&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld%c",*ptr,ptr==ti?'\n':' ');&#125;void out(initializer_list&lt;db&gt; li)&#123;auto ti=li.end();ti--;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%f%c",*ptr,ptr==ti?'\n':' ');&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln?'\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln?'\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln?'\n':' ');&#125;void out(ldb a,int digit,bool ln)&#123;printf("%.*Lf%c",digit,a,ln?'\n':' ');&#125;void out0(int a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(int a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;void out0(ll a[],int n)&#123;for0(i,n)out(a[i],i==n-1);&#125;void out1(ll a[],int n)&#123;for1(i,n)out(a[i],i==n);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c,ll &amp;d)&#123;return scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(ll &amp;a,ll &amp;b,ll &amp;c)&#123;return scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;c);&#125;int in(ll &amp;a,ll &amp;b)&#123;return scanf("%lld%lld",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;int in(ldb &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void in0(int a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(int a[],int n)&#123;for1(i,n)in(a[i]);&#125;void in0(ll a[],int n)&#123;for0(i,n)in(a[i]);&#125;void in1(ll a[],int n)&#123;for1(i,n)in(a[i]);&#125;const db pi = acos(-1);const db eps = 1e-8;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int M = 2.1e5;const int N = 2.1e3;/*-----------------------------------head----------------------------------------------*/int dp[N][N],n;bool vis[N][N];bool check(int i,int j)&#123; if(j&gt;=0&amp;&amp;j&lt;=n&amp;&amp;(i-j)%2==0&amp;&amp;i+j&lt;=2*n)retrun 1; else retrun 0;&#125;int main() &#123; in(n); for(int i=2*n-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;=min(n,i);j++)&#123; bool flag=0; if(check(i+1,j-1))&#123; if(vis[i+1][j-1]==0)vis[i+1][j-1]=1,flag=1; dp[i][j]=(dp[i][j]+dp[i+1][j-1])%mod; &#125; if(check(i+1,j+1))&#123; if(vis[i+1][j+1]==0&amp;&amp;flag==0)flag=1,vis[i+1][j+1]=1; dp[i][j]=(dp[i][j]+dp[i+1][j+1])%mod; &#125; if(flag)&#123; vis[i][j]=1,dp[i][j]=(dp[i][j]+1)%mod; &#125; &#125; &#125; out(dp[0][0],1); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1208]]></title>
    <url>%2F2019%2F08%2F27%2FCF-1208%2F</url>
    <content type="text"><![CDATA[C. Magic Grid题意给一个 $n(n\%4=0)$ ，将 $0\sim n^2-1$ 填入 $n\times n$ 的矩阵里，使得每行每列的异或和相同。 题解 \begin{matrix} 0 & 1 & 2&3 \\ 4 & 5 & 6 &7\\ 8 & 9&10 &11\\ 12 & 13&14 &15\\ \end{matrix}因为 $n$ 是 $4$ 的倍数，将这个 $4\times4$ 的矩阵看作一个整体来填充矩阵即可，以为这个矩阵每个元素加上 $16k$ 不会影响结果]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>constructive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019HDU多校-Day8]]></title>
    <url>%2F2019%2F08%2F20%2F2019HDU%E5%A4%9A%E6%A0%A1-Day8%2F</url>
    <content type="text"><![CDATA[F. Acesrc and Travel题意给一颗树，每个点有两个权值 $a_i,b_i$ ，两个人博弈，交替选择节点，A 获得 $a_i$ ，B 获得 $b_i$ ，每次只能选取与上一个人相邻的节点。 题解先以任意点为根节点，算出这种情况的结果，再利用换根的方法求出所有节，要注意处理好根节点和叶节点的情况 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;void out(int a,bool ln)&#123;printf("%d%c",a," \n"[ln]);&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a," \n"[ln]);&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a," \n"[ln]);&#125;const db pi = acos((db)-1);const ll inf =1e18;const db eps = 1e-8;const int N = 1.1e5;const int M = 2.1e5;const ll mod = 1e9;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;vii node[N];ll w[N];pll dp[N][2];ll ans;void dfs(int u,int fa)&#123; ll max_fi=-inf,max_se=-inf,min_fi=inf,min_se=inf; if(fa&amp;&amp;node[u].size()==1)&#123;//非根叶节点 dp[u][0]=pll(w[u],-inf); dp[u][1]=pll(w[u],inf); return; &#125; for(auto i:node[u])&#123; if(i!=fa)&#123; dfs(i,u); if(dp[i][0].fi+w[u]&lt;min_fi)&#123; min_se=min_fi; min_fi=dp[i][0].fi+w[u]; &#125;else min_se=min(min_se,dp[i][0].fi+w[u]); if(dp[i][1].fi+w[u]&gt;max_fi)&#123; max_se=max_fi; max_fi=dp[i][1].fi+w[u]; &#125;else max_se=max(max_se,dp[i][1].fi+w[u]); &#125; &#125; dp[u][0]=pll(max_fi,max_se); dp[u][1]=pll(min_fi,min_se);&#125;void dfs2(int u ,int fa ,ll max1,ll min0)&#123; if(u!=1)&#123; if(node[u].size()==1) ans=max(ans,min0+w[u]); else&#123; if(min0+w[u]&lt;dp[u][1].fi)ans=max(ans,min0+w[u]); else ans=max(ans,dp[u][1].fi); &#125; &#125; for(int v:node[u])&#123; if(v!=fa)&#123; ll tmin,tamx; if(dp[u][1].fi==dp[v][0].fi+w[u])tamx=min(min0+w[u],dp[u][1].se); else tamx=min(min0+w[u],dp[u][1].fi); if(dp[u][0].fi==dp[v][1].fi+w[u])tmin=max(max1+w[u],dp[u][0].se); else tmin=max(max1+w[u],dp[u][0].fi); // cout&lt;&lt;v&lt;&lt;' '&lt;&lt;tmin&lt;&lt; ' '&lt;&lt;tamx&lt;&lt;endl; dfs2(v,u,tamx,tmin); &#125; &#125;&#125;int main() &#123; int t,n,u,v,x; in(t); while(t--)&#123; in(n); for1(i,n)in(w[i]); for1(i,n)&#123; node[i].clear(); in(x); w[i]-=x; &#125; for0(i,n-1)&#123; in(u,v); node[u].pu_b(v); node[v].pu_b(u); &#125; dfs(1,0); ans=dp[1][1].fi; if(node[1].size()==1) dfs2(node[1][0],1,w[1],w[1]);// 特判根节点只连有一个点的情况 else dfs2(1,0,-inf,inf); out(ans,1); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++]]></title>
    <url>%2F2019%2F08%2F17%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[数据范围int $ -2.14\times10^9 \sim 2.14\times10^9$ unsigned int $0\sim4.29 \times10^ 9$ long long $-9.22\times10^{18}\sim9.22 \times10^ {18}$ unsigned long long $0\sim1.84 \times10^ {19}$ float $-3.40\times10^{38}\sim3.40 \times10^ {38}$ 6~7 double $-1.79\times10^{308}\sim1.79 \times10^ {308}$ 15~16 long double $-1.2\times10^{4932}~1.2\times10^{4932}$ 18~19 易错点memset只管后面的两个字符，然后前面的直接就复制过去, 所以 memset( a,0x3f,sizeof(a) ) 效果等同于 memset( a,0x3f3f3f3f,sizeof(a) ) strlen()的时间复杂度为O(n) s.size()的返回值为unsigned long 动态数组123456789101112131415int *a = new int[50]delete [] a;int (*a)[50] = new int[100][50]int **p= new int*[size];//定义指针数组 for(int i=0;i&lt;size;i++)&#123; p[i]=new int[Column];&#125;for(int i=0;i&lt;size;i++)&#123; delete [] p[i];&#125;char *p = (char *)malloc(100); free(p); IOscanf1234%f float%lf double%Lf long doublesscanf("3.42","%lf",&amp;b); //将字符串转换为数值double printf1234567- 左对齐0 右对齐时，用0填充左边未使用的列+ 当一个数为正数时，前面加上一个+号' ' 当一个数为正数时，前面加上一个空格printf("a = %08.3Lf",a); //右对齐，开头补零，字符宽度8位，精度3位，以long double型输出。printf("%*d",width,num);sprintf(buf,"%.2f",a); //将double型数值转换为字符串 整行读入123456789101112131415161718192021222324252627//scanf()读入char[]char str[1024];scanf("%[^\n]",&amp;str);getchar();//getchar()读入char[]char str[1024];int i=0;while((str[i]=getchar())!='\n') i++;getchar();//gets()读入char[]char str[1024];gets(str);//getline()string str;getline(cin,str);//读入stringchar str2[1024];cin.getline(str2,1024);//读入char数组//get()读入char[]char str3[1024];cin.get(str3,1024);//读入char数组cin.get(str,1024).get(); 文件输入输出12345678freopen("/Users/perpeternal/Downloads/test.in", "r", stdin); freopen("/Users/perpeternal/Downloads/test.out", "w", stdout);FILE *in = fopen("/Users/perpeternal/Downloads/test.in","r");FILE *out = fopen("/Users/perpeternal/Downloads/test.out", "w");fscanf(in,"%d",&amp;n);fprintf(out,"%d",n);fclose(in);fclose(out); 可变参数123456789101112void out(int count,...)&#123; va_list ap; //声明一个va_list变量 va_start(ap, count); //第二个参数表示形参的个数 for (int i = 0; i &lt; count; i++) &#123;printf("%d ",va_arg(ap, int));&#125; va_end(ap); //用于清理&#125;out(4,1,2,3,4);void out(initializer_list&lt;int&gt; list) &#123; for (auto ptr = list.begin(); ptr != list.end(); ptr++) printf("%d ",*ptr);&#125;out(&#123;1,2,3,4&#125;); 手动优化手动加栈1#pragma comment(linker, “/STACK:1024000000,1024000000”) 优化-O0 表示无优化状态 -O1 表示对代码进行了优化 -O2 表示减小目标文件大小 -O3 表示减小代码段及栈空间的大小 全局： 1#pragma GCC optimize (“O2”) 部分： 1234#pragma GCC push_options #pragma GCC optimize (“O0”) ...#pragma GCC pop_options 随机数1234//这是两个预定义类（类型），定义的变量可以用重载好的 () 运算符获取随机数mt19937 gen(time(0)); //生成 [0, 2^32-1]mt19937_64 gen(time(0)); //生成 [0, 2^64-1]gen(); //生成随机数 assert1assert(0); //终止程序，报re inf&amp;nan1234int isfinite(x); 判断x是否有限，是返回1，其它返回0；int isnormal(x); 判断x是否为一个数（非inf或nan），是返回1，其它返回0；int isnan(x); 当x时nan返回1，其它返回0；int isinf(x); 当x是正无穷是返回1，当x是负无穷时返回-1，其它返回0。有些编译器不区分。 priority_queue1234567891011121314151617//在结构体外重载结构体小于运算符struct Time&#123; int start, end;&#125;;bool operator &lt;(const Time&amp; a,const Time&amp; b)&#123; return a.start &gt; b.start;&#125;//只能重载小于，这里以大于重载小于是因为默认情况下，优先队列是以大的作为队首，这样一反，就可以再默认情况下使得小的作为队首//在结构体中重载小于运算符struct Time&#123; int start, end; bool operator &lt; (const Time&amp; t)const&#123; return start &gt; t.start; &#125; &#125;;priority_queue&lt;Time&gt; pq; set &amp; mapset1234567891011121314struct node&#123; int x,y; bool operator &lt; (const node&amp; t)const&#123; return x &gt; t.x; &#125; &#125;;set&lt;node&gt; SET;struct cmp&#123; bool operator()(const int &amp;k1,const int &amp;k2)const&#123; return k1&gt;k2; &#125;&#125;;set&lt;int,cmp&gt;s; map12345678910111213141516171819202122232425262728293031323334typedef struct UrlKey&#123; uint64_t dwBussID; uint64_t dwVersion; uint64_t dwHashUrl;&#125;UrlKey; //自定义map的valuetypedef struct UrlValue&#123; string strUrl;&#125;UrlValue;struct cmp_key&#123; bool operator()(const UrlKey &amp;k1, const UrlKey &amp;k2)const &#123; if(k1.dwBussID != k2.dwBussID) &#123; return k1.dwBussID &lt; k2.dwBussID; &#125; if(k1.dwVersion != k2.dwVersion) &#123; return k1.dwVersion &lt; k2.dwVersion; &#125; if(k1.dwHashUrl != k2.dwHashUrl) &#123; return k1.dwHashUrl &lt; k2.dwHashUrl; &#125; return false; &#125;&#125;; map&lt;UrlKey, UrlValue, cmp_key&gt; UrlMap; unordered_set1234567891011121314struct node&#123; string s; int step; node(string _s):s(_s),step(0)&#123;&#125; bool operator == (const node y)const&#123; return s==y.s; &#125;&#125;;struct Hash&#123; size_t operator () (const node y)const&#123; return hash&lt;string&gt;()(y.s); &#125;&#125;;unordered_set&lt;node,Hash&gt;us; multiset12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// cont/mset1.cpp #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main() &#123; /*type of the collection: *-duplicates allowed *-elements are integral values *-descending order */ typedef multiset&lt;int,greater&lt;int&gt; &gt; IntSet; IntSet coll1, // empty multiset container //insert elements in random order coll1.insert(4); coll1.insert(3); coll1.insert(5); coll1.insert(l); coll1.insert(6); coll1.insert(2); coll1.insert(5); //iterate over all elements and print them IntSet::iterator pos; for (pos = coll1.begin(); pos != coll1.end(); ++pos) &#123; cout &lt;&lt; *pos &lt;&lt; ' '; &#125; cout &lt;&lt; endl; //insert 4 again and process return value IntSet::iterator ipos = coll1.insert(4); cout &lt;&lt; "4 inserted as element " &lt;&lt; distance (coll1.begin(),ipos) + 1 &lt;&lt; endl; //assign elements to another multiset with ascending order multiset&lt;int&gt; coll2(coll1.begin(),coll1.end()); //print all elements of the copy copy (coll2.begin(), coll2.end(), ostream_iterator&lt;int&gt;(cout," ")); cout &lt;&lt; endl; //remove all elements up to element with value 3 coll2.erase (coll2.begin(), coll2.find(3)); //remove all elements with value 5 int num; num = coll2.erase (5); cout &lt;&lt; num &lt;&lt; " element(s) removed" &lt;&lt; endl; //print all elements copy (coll2.begin(), coll2.end(), ostream_iterator&lt;int&gt;(cout," ")); cout &lt;&lt; endl; &#125; string123456789101112131415161718192021222324252627282930313233343536373839404142434445string s(str) //拷贝构造函数 生成str的复制品string s(str,stridx) //将字符串str内“始于位置stridx”的部分当作字符串的初值string s(str,stridx,strlen) //将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值string s(cstr) //将C字符串作为s的初值string s(chars,chars_len) //将chars字符串前chars_len个字符作为字符串s的初值。s.assign(str); //不说s.assign(str,1,3);//如果str是”iamangel” 就是把”ama”赋给字符串s.assign(str,2,string::npos);//把字符串str从索引值2开始到结尾赋给ss.assign(“gaint”); //不说s.assign(“nico”,5);//把’n’ ‘I’ ‘c’ ‘o’ ‘\0’赋给字符串s.assign(5,’x’);//把五个x赋给字符串s.append(str);s.append(str,1,3);//不解释了 同前面的函数参数assign的解释s.append(str,2,string::npos)//不解释了s.append(“my name is jiayp”);s.append(“nico”,5);s.append(5,’x’);s.push_back(‘a’);//这个函数只能增加单个字符 对STL熟悉的理解起来很简单s.insert(0,”my name”);s.insert(1,str);s.replace(1,2,”nternationalizatio”);//从索引1开始的2个替换成后面的C_strings.erase(13);//从索引13开始往后全删除s.erase(7,5);//从索引7开始往后删5个s.substr();//返回s的全部内容s.substr(11);//从索引11往后的子串s.substr(5,6);//从索引5开始6个字符返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。find()rfind() //从后向前find_first_of()find_last_of()find_first_not_of()返回在字符串中首次出现的不匹配str中的任何一个字符的首字符索引, 从index开始搜索, 如果全部匹配则返回string::npos。find_last_not_of()s.c_str() 返回 char*strcmp(const char *s1,const char * s2)//若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。 编译过程compiletest.cpp - 预处理(Pre-processing) - test.i - 编译(Compiling) - test.s - 汇编(Assembling) - test.o - 链接(Linking) - test Pre-processing-E 选项使用g++/gcc将源代码预处理后不执行其他动作。下面的命令将test.cpp预处理，并在标准输出中显示： 1g++ -E test.cpp 后面加上 -o 选项表示将源代码预处理后输出在指定文件中，比如test.i： 1g++ -E test.cpp -o test.i Compiling-S 选项使用g++/gcc将预处理后的文件编译，翻译成汇编代码。只编译不汇编下面的命令将会编译test.i文件，并自动在当前文件夹生成test.s文件 1g++ -S test.i 若要指定其他输出名，则需 -o 指定，比如生成名为xxx.s的汇编代码文件 1g++ -S test.i -o xxx.s Assembling-c 选项将编译生成的test.s文件生成二进制目标代码下面的命令将在当前文件夹自动生成test.o的二进制目标代码文件 1g++ -c test.s 如果要指定输出文件名，则需 -o 指定，比如生成xxx.o的二进制目标代码文件 1g++ -c test.s -o xxx.o Linking链接阶段是将相关的目标文件链接起来，形成一个整体，生成可执行文件无选项链接下面的命令会把二进制目标文件test.o所需的相关文件链接成一个整体，并在当前文件夹自动生成一个名为a.out的可执行文件 1g++ test.o 如果要执行这个可执行文件，需要输入命令 1./a.out 当然也可以指定生成的可执行文件的文件名 1g++ test.o -o test.exe 单个源文件直接生成可执行文件当然g++/gcc也可以直接把源代码直接生成可执行文件下面的命令将test.cpp直接在当前文件夹生成a.out可执行文件，若要指定文件名，可使用 -o 选项 12g++ test.cppg++ test.cpp -o test.exe 多个源文件直接生成可执行文件也可以将多个源代码编译链接成一个可执行文件下面的命令将test.cpp直接在当前文件夹生成a.out可执行文件，若要指定文件名，可使用 -o 选项 12g++ test1.cpp test2.cpp g++ test1.cpp test2.cpp -o test.exe 使用C++11标准编译如果要使用C++11版本特性，则需要使用 -std=c++11 选项 1g++ -std=c++11 test.cpp -o test.exe]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DP]]></title>
    <url>%2F2019%2F08%2F17%2FDP%2F</url>
    <content type="text"><![CDATA[背包数位 $1-n$ 所有数中，数位 $0-9$ 的数量 $f[i]$ 表示前 $i$ 位出现的数码次数 12345678910111213141516171819202122232425262728ll f[20],cnt[10];void fun(ll n)&#123; mem0(cnt); if(!n)return; if(!f[1])&#123; f[1]=1; ll s=10; for(int i=2;i&lt;20;i++)f[i]=f[i-1]*10+s,s*=10; &#125; ll k=n,m; int w=0,i,j,sum[15]; while(k) sum[++w]=k%10,k/=10; for (m=1,i=1; i&lt;w; i++)&#123; cnt[0]+=f[i-1]*9; for (j=1; j&lt;=9; j++) cnt[j]+=f[i-1]*9+m; m*=10; &#125; k=n-sum[w]*m; for (i=1; i&lt;sum[w]; i++) cnt[i]+=m; for (i=0; i&lt;=9; i++) cnt[i]+=f[w-1]*(sum[w]-1); cnt[sum[w]]+=k+1; for (i=w-1; i; i--)&#123; m/=10,k-=sum[i]*m; for (j=0; j&lt;sum[i]; j++) cnt[j]+=m; for (j=0; j&lt;=9; j++) cnt[j]+=f[i-1]*sum[i]; cnt[sum[i]]+=k+1; &#125;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Combination & Sequence]]></title>
    <url>%2F2019%2F08%2F17%2FCombination%20%26%20Sequence%2F</url>
    <content type="text"><![CDATA[组合数性质 mC_n^m=nC_{n-1}^{m-1}\\ C_n^m=C_{n-1}^{m-1}+C_{n-1}^{m}\\ C_n^0+C_n^1+C_n^2+\cdots+C_n^n=2^n\\ 1C_n^1+2C_n^2+3C_n^3+\cdots+nC_n^n=n2^{n-1}\\ (C_n^0)^2+(C_n^1)^2+(C_n^2)^2+\cdots+(C_n^n)^2=C_{2n}^n\\ 1^2C_n^1+2^2C_n^2+3^2C_n^3+\cdots+n^2C_n^n=n(n+1)2^{n-2}\\ \frac {C_n^1} 1-\frac {C_n^2} 2+\frac {C_n^3} 3-\cdots+(-1)^{n-1}\frac {C_n^m} n=1+\frac 1 2+\frac 1 3+\cdots+\frac 1 n\\n 个球 m 个盒子1.球同，盒同，可空 dp_1[n][m]= \left\{ \begin{array}{c} 1 & n\le 1\&m=1 \\ dp_1[n][m-1]+dp_1[n-m][m] & n\ge m \\ dp_1[n][m-1] & n0\\ m*dp_2[n-1][m]+dp_2[n-1][m-1]&otherwise \end{array} \right.6.球不同，盒同，可空 \sum_{i=1}^mdp_2[n][i]7.球不同，盒不同，不可空 m!\times dp_2[n][m]8.球不同，盒不同，可空 m^nBurnside引理对于一个置换 $f$, 若一个染色方案 $s$ 经过置换后不变，称 $s$ 为 $f$ 的不动点。将 $f$ 的不动点数目记为 $c(f)$，则可以证明等价类数目为所有的 $c(f)$ 平均值。 t=\frac 1 {|G|} [ c(a_1)+c(a_2)+\cdots+c(a_g)]例子: 一正方形分成4格，2着色，有多少种方案？ 对于这16种方案可以归一下类： Θ不动：a1=(1)(2)…(16) Θ逆时针转90度 ：a2=(1)(2)(3 4 5 6)(7 8 9 10) (11 12)(13 14 15 16) Θ顺时针转90度 ：a3=(1)(2)(6 5 4 3)(10 9 8 7)(11 12)(16 15 14 13) Θ转180度：a4=(1)(2)(3 5)(4 6)(7 9)(8 10)(11)(12) (13 15)(14 16) (a,b,c)表示可以通过a,b,c旋转得到 所以共有(16+2+2+4)/4=6种方案. Polya定理假设一个置换有k个循环，易知每个循环对应的所有位置颜色需一致，而任意两个循环之间选什么颜色互不影响。因此，如果有m种可选颜色，则该置换对应的不动点个数为$m^k$。用其替换burnside引理中的$c(f)$，即$C(f)=m^k$得到等价类数目为： \Large \frac {\sum\nolimits_{i=0}^{\left|F\right|}m^{k_i}} {\left|F\right|}Θ不动：a1=(1)(2)(3)(4) Θ旋转90度 ：a2=(1 2 3 4) Θ旋转180度 ：a3=(1 3)(2 4) Θ旋转270度：a4=(1 4 3 2) 由Polya定理得，共有 $\huge\frac {2^4+2^1+2^2+2^1}4=6$ 种方案. 容斥原理 \left|\bigcup\limits_{i=1}^nA_i\right|=\sum\limits_{i=1}^n|A_i|-\sum\limits_{1\le i]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Game]]></title>
    <url>%2F2019%2F08%2F17%2FGame%2F</url>
    <content type="text"><![CDATA[只要找到一个子局面是P-position(先手必败)就能说明是N-position(后手必败)，反之为P-position。 SG函数(Sprague-Grund) f(v)=mex\{f(u)|u为v的后继状态\}mex(minimal excludant)是定义在整数集合上的操作。它的自变量是任意整数集合，函数值是不属于该集合的最小自然数。 mex(A)=min\{k|k\in \complement_NA\}终止状态的SG值显然为0，并且SG值为0的状态就是P状态，SG值不为0的状态就是N状态. Nim Game有n堆石子，石子数目=分别为$a_1,a_2,a_3 · · · a_n$，A，B两人每次可以选一堆石子取走任意多个 P-position: $a_1\wedge a_2\wedge · · · \wedge a_n=0$ Wythoff’s Game两堆石子，个数为$x_1,x_2$; A，B轮流取石子，规定要么只取一堆的任意多个，要么在两堆里取同样任意多个 P-position: (0,0)(1,2)(3,5)(4,7) $a_k$是未在之前出现过的最小自然数 $b_k=a_k+k$ 由Beatty定理可得: $\frac 1\alpha+\frac 1 {\alpha+1}=1,\alpha=\frac {1+\sqrt5}2$ Beatty数列和Beatty定理取正无理数α,β，使得$\frac 1\alpha+\frac 1 \beta=1$ 构造两个数列a,b,它们的通项为$a_n=⌊αn⌋,b_n=⌊βn⌋$ 那么这个数列显然是正整数序列，Beatty定理指出，两个数列都是严格递增的，并且每个正整数在两个数列中只出现一次 Fibonacci Nim有一堆个数为n的石子，A，B轮流取石子，满足： 先手不能在第一次把所有的石子取完； 之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间 (包含1和对手刚取的石子数的2倍) P-position: 1,2,3,5,8,13,21,34,55,89,…(Fibonacci) Zeckendorf定理任何正整数可以表示为若干个不连续的Fibonacci数之和。 Staircase Nimn堆石子，每堆石子的数量为$x_1,x_2,….x_n$，A，B轮流操作，每次可以选第k堆中的任意多个石子放到第k-1堆中，第1堆中的石子可以放到第0堆中. P-position: $x_1 \wedge x_3\wedge x_5…\wedge x_{2*n+1}=0$ Anti Nim有n堆石子，A，B两人每次可以选一堆石子取走任意多个,取到最后一个石子的人为输. N-position: 所有堆石子数都为1且SG值为0 ; 至少有一堆石子数大于1且SG值不为0 Nim变形两个人在一个1*N的格子内挪动棋子，刚开始在若干个位置上有若干个棋子，每一个选手可以进行的操作时选择一个棋子并把它向左方移动，当然不能越过其它的棋子，也不能超出边界。 按位置升序排列后，从后往前把他们两两绑定成一对。如果总个数是奇数，就把最前面一个和边界（位置为0）绑定。对手移动左,你移动相同步数;对手移动右,表示取相应的石子. K倍动态减法 K=1 P-position: 2^k 先手的策略是取lowbit(n) K=2 P-position: Fibonacci Nim K&gt;2 (K=1或K=2也可以用次方法构造)仿照斐波那契博弈的构造方法构造一个数列an b[]作为辅助数组表示前i个的a能够按规则构造出的最大的数 1234a[i+1]=b[i]+1;//寻找最大的 t 使得 a[t] * K &lt; a[i+1];b[i+1] = b[t] + a[i+1];P-position: a[]]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DataStructure]]></title>
    <url>%2F2019%2F08%2F17%2FDataStructure%2F</url>
    <content type="text"><![CDATA[树重心对于一棵树来说，删去该树的重心后，所有的子树的大小不会超过原树大小的 $\large\frac 1 2$。树的重心还有一个性质，是相对于树上的其他点而言的，就是删去重心后形成的所有子树中最大的一棵节点数最少。换句话说，就是删去重心后生成的多棵子树是最平衡的。一棵树的重心至多有两个。我们可以很容易的在一次DFS过程中求出所有节点的 $size$，即子树大小。我们每搜索完一个节点 u 的儿子 v，就判断 size[v] 是否大于 $\frac n 2$，然后在搜索完所有儿子后计算出本节点的 $size$，再判断 $n-size[u]$ 是否大于 n/2（ n-siz[u] 是节点 u 上面的连通块大小）即可求出重心，时间复杂度 O(n)。 直径树上的最长路径，可以有多条。法一：任取树中的一个节点x，找出距离它最远的点y，那么点y就是这棵树中一条直径的一个端点。我们再从y出发，找出距离y最远的点就找到了一条直径。对于树中的任一个点，距离它最远的点一定是树上一条直径的一个端点。法二：定义F[i]表示从i出发向远离根节点的方向走的最长路径的长度，G[i]表示从i向远离根节点的方向走的次长路径的长度。注意F[i]和G[i]不能沿着i的同一个儿子走。特别地，如果i只有一个儿子，那么G[i]=0。答案为max(F[i]+G[i])。 最近公共祖先（LCA）树链剖分树状数组lowbit123int lowbit(int x)&#123; return x&amp;(-x);&#125; 单点修改，区间查询12345678void add(int p,int x,int n)&#123; //a[p]+=x,数组为[1,n] while(p&lt;=n)sum[p]+=x,p+=p&amp;-p;&#125;ll query(int p)&#123; ll ans = 0; while(p)ans+=sum[p],p-=p&amp;-p; return ans;&#125; 求逆序对离散化，排序，逆序对数就是下标的逆序对数，逐一加入，加上已加入的大于当前值的数量。 区间极值123456789101112131415161718192021222324int lowbit(int x)&#123; return x&amp;(-x);&#125;int a[N],h[N];void update(int p,int x,int n)&#123; a[p]=x; int lx; while(p&lt;=n)&#123; h[p]=a[p]; lx = lowbit(p); for (int i=1; i&lt;lx; i&lt;&lt;=1) h[p] = max(h[p], h[p-i]); p += lowbit(p); &#125;&#125;int query(int l,int r)&#123; int ans = 0; while(l&lt;=r)&#123; ans = max(ans,a[r]); r--; for(; l&lt;=r-lowbit(r) ;r-=lowbit(r))ans = max(ans,h[r]); &#125; return ans;&#125; 区间修改，单点查询差分，设数组 $d[i]=a[i]-a[i-1],(a[0]=0)$，则 $a[i]=\sum\limits_{j=1}^id[j]$。 1234567891011void add(int p, int x, int n)&#123; //这个函数用来在树状数组中直接修改 while(p &lt;= n) sum[p] += x, p += p &amp; -p;&#125;void range_add(int l, int r, int x)&#123; //给区间[l, r]加上x add(l, x), add(r + 1, -x);&#125;ll query(int p)&#123; //单点查询 ll res = 0; while(p) res += sum[p], p -= p &amp; -p; return res;&#125; 区间修改，区间查询$\sum\limits_{i=1}^pa[i]=\sum\limits_{i=1}^p\sum\limits_{j=1}^id[j]=(p+1)\times\sum\limits_{i=1}^pd[i]-\sum\limits_{i=1}^pd[i]\times i$，所以我们需要维护两个数状数组$d[i],d[i]*i$ 1234567891011121314void add(int p, ll x)&#123; while(p&lt;=n)sum1[i] += x, sum2[i] += x * p ,p+=p&amp;-p;&#125;void range_add(int l, int r, ll x)&#123; add(l, x), add(r + 1, -x);&#125;ll query(int p)&#123; ll res = 0; while(p)res += (p + 1) * sum1[i] - sum2[i],p-=p&amp;-p; return res;&#125;ll range_query(int l, int r)&#123; return query(r) - query(l - 1);&#125; 二维树状数组单点修改+区间查询定义$tree[x][y]$记录的是右下角为(x, y)，高为lowbit(x), 宽为 lowbit(y)的区间的区间和。 123456789101112131415161718void add(int x, int y, int z)&#123; //将点(x, y)加上z int memo_y = y; while(x &lt;= n)&#123; y = memo_y; while(y &lt;= n) tree[x][y] += z, y += y &amp; -y; x += x &amp; -x; &#125;&#125;void ask(int x, int y)&#123;//求左上角为(1,1)右下角为(x,y) 的矩阵和 int res = 0, memo_y = y; while(x)&#123; y = memo_y; while(y) res += tree[x][y], y -= y &amp; -y; x -= x &amp; -x; &#125;&#125; 区间修改 + 单点查询差分 $d[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$ 123456789101112131415161718192021222324void add(int x, int y, int z)&#123; int memo_y = y; while(x &lt;= n)&#123; y = memo_y; while(y &lt;= n) tree[x][y] += z, y += y &amp; -y; x += x &amp; -x; &#125;&#125;void range_add(int xa, int ya, int xb, int yb, int z)&#123; add(xa, ya, z); add(xa, yb + 1, -z); add(xb + 1, ya, -z); add(xb + 1, yb + 1, z);&#125;void ask(int x, int y)&#123; int res = 0, memo_y = y; while(x)&#123; y = memo_y; while(y) res += tree[x][y], y -= y &amp; -y; x -= x &amp; -x; &#125;&#125; 区间修改 + 区间查询 \sum\limits_{i=1}^x\sum\limits_{j=1}^y\sum\limits_{k=1}^i\sum\limits_{h=1}^jd[h][[k]=\\\sum\limits_{i=1}^x\sum\limits_{j=1}^y(x+1-i)(y+1-j)d[i][j]=\\(x+1)(y+1)\sum\limits_{i=1}^x\sum\limits_{j=1}^yd[i][j]-(y+1)\sum\limits_{i=1}^x\sum\limits_{j=1}^yi*d[i][j]-(x+1)\sum\limits_{i=1}^x\sum\limits_{j=1}^yj*d[i][j]+\sum\limits_{i=1}^x\sum\limits_{j=1}^yi*j*d[i][j]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;ll read()&#123; char c; bool op = 0; while((c = getchar()) &lt; '0' || c &gt; '9') if(c == '-') op = 1; ll res = c - '0'; while((c = getchar()) &gt;= '0' &amp;&amp; c &lt;= '9') res = res * 10 + c - '0'; return op ? -res : res;&#125;const int N = 205;ll n, m, Q;ll t1[N][N], t2[N][N], t3[N][N], t4[N][N];void add(ll x, ll y, ll z)&#123; for(int X = x; X &lt;= n; X += X &amp; -X) for(int Y = y; Y &lt;= m; Y += Y &amp; -Y)&#123; t1[X][Y] += z; t2[X][Y] += z * x; t3[X][Y] += z * y; t4[X][Y] += z * x * y; &#125;&#125;void range_add(ll xa, ll ya, ll xb, ll yb, ll z)&#123; //(xa, ya) 到 (xb, yb) 的矩形 add(xa, ya, z); add(xa, yb + 1, -z); add(xb + 1, ya, -z); add(xb + 1, yb + 1, z);&#125;ll ask(ll x, ll y)&#123; ll res = 0; for(int i = x; i; i -= i &amp; -i) for(int j = y; j; j -= j &amp; -j) res += (x + 1) * (y + 1) * t1[i][j] - (y + 1) * t2[i][j] - (x + 1) * t3[i][j] + t4[i][j]; return res;&#125;ll range_ask(ll xa, ll ya, ll xb, ll yb)&#123; return ask(xb, yb) - ask(xb, ya - 1) - ask(xa - 1, yb) + ask(xa - 1, ya - 1);&#125;int main()&#123; n = read(), m = read(), Q = read(); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; ll z = read(); range_add(i, j, i, j, z); &#125; &#125; while(Q--)&#123; ll ya = read(), xa = read(), yb = read(), xb = read(), z = read(), a = read(); if(range_ask(xa, ya, xb, yb) &lt; z * (xb - xa + 1) * (yb - ya + 1)) range_add(xa, ya, xb, yb, a); &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++) printf("%lld ", range_ask(i, j, i, j)); putchar('\n'); &#125; return 0;&#125; 线段树 建树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int A[N],Sum[N&lt;&lt;2],Lazy[N&lt;&lt;2];void PushUp(int rt)&#123;Sum[rt]=Sum[rt&lt;&lt;1]+Sum[rt&lt;&lt;1|1];&#125;//PushUp函数更新节点信息 ，这里是求和void Build(int l,int r,int rt)&#123; //Build函数建树，l,r表示当前节点区间，rt表示当前节点编号 if(l==r) &#123;//若到达叶节点 scanf("%d",&amp;Sum[rt]); //Sum[rt]=A[l];//储存数组值 return; &#125; int m=(l+r)&gt;&gt;1; Build(l,m,rt&lt;&lt;1); Build(m+1,r,rt&lt;&lt;1|1); PushUp(rt);//更新信息 &#125;void PushDown(int rt,int ln,int rn)&#123; //ln,rn为左子树，右子树的数字数量。 if(Lazy[rt])&#123; //下推标记 Lazy[rt&lt;&lt;1]+=Lazy[rt]; Lazy[rt&lt;&lt;1|1]+=Lazy[rt]; //修改子节点的Sum使之与对应的Lazy相对应 Sum[rt&lt;&lt;1]+=Lazy[rt]*ln; Sum[rt&lt;&lt;1|1]+=Lazy[rt]*rn; Lazy[rt]=0;//清除本节点标记 &#125;&#125;//区间修改void Update(int L,int R,int C,int l,int r,int rt)&#123;//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号 if(L &lt;= l &amp;&amp; r &lt;= R)&#123;//如果本区间完全在操作区间[L,R]以内 Sum[rt]+=C*(r-l+1);//更新数字和，向上保持正确 Lazy[rt]+=C;//增加Lazy标记，表示本区间的Sum正确，子区间的Sum仍需要根据Lazy的值来调整 return ; &#125; int m=(l+r)&gt;&gt;1; PushDown(rt,m-l+1,r-m);//下推标记 //这里判断左右子树跟[L,R]有无交集，有交集才递归 if(L &lt;= m) Update(L,R,C,l,m,rt&lt;&lt;1); if(R &gt; m) Update(L,R,C,m+1,r,rt&lt;&lt;1|1); PushUp(rt);//更新本节点信息 &#125;//区间查询int Query(int L,int R,int l,int r,int rt)&#123;//L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号 if(L &lt;= l &amp;&amp; r &lt;= R)&#123;//在区间内，直接返回 return Sum[rt]; &#125; int m=(l+r)&gt;&gt;1; PushDown(rt,m-l+1,r-m); //下推标记 int ANS=0; if(L &lt;= m) ANS+=Query(L,R,l,m,rt&lt;&lt;1); if(R &gt; m) ANS+=Query(L,R,m+1,r,rt&lt;&lt;1|1); return ANS;&#125; 平衡二叉树heap 建堆 123456789101112131415161718192021222324252627282930int Heap[n],n;void node_swap(int x,int y)&#123; int temp=Heap[x]; Heap[x]=Heap[y]; Heap[y]=temp;&#125;void siftdown(int i)&#123; //i表示操作的结点编号（从1开始） while (2*i&lt;=n) &#123; int minn=Heap[2*i],temp=2*i; if (2*i+1&lt;=n&amp;&amp;Heap[2*i]&gt;Heap[2*i+1]) &#123; minn=Heap[2*i+1]; temp=2*i+1; &#125; if (Heap[i]&gt;minn) &#123; node_swap(i,temp); i=temp; &#125;else break; &#125;&#125;void siftup(int i)&#123; //i表示操作的结点编号（从1开始） while (i!=1) &#123; if (Heap[i]&lt;Heap[i/2]) &#123; node_swap(i,i/2); i/=2; &#125;else break; &#125;&#125;void creat()&#123;//建立堆 for (int i=n/2; i&gt;=1; i--) siftdown(i);&#125; 删除-输出最小元素 1234567int delete_min()&#123; int t=Heap[1]; Heap[1]=Heap[n]; n--; siftdown(1); return t;&#125; 堆排序(从大到小) 1234567void heap_sort()&#123; while (n&gt;1) &#123; node_swap(1, n); n--; siftdown(1); &#125;&#125; top-kn 个数中，找出最大（最小）的 m 个，建立一个小（大）顶堆维护当前最大（最小）的 m 个数再将剩余的推入。 RMQ12345678910111213void ST(int n) &#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = A[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) &#123; dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int RMQ(int l, int r) &#123; int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= r - l + 1) k++; return max(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);&#125; 主席树dfs序12345678910int L[N],R[N],dep[N],tot;vii node[N];void dfs(int rt,int fa,int d)&#123; L[rt]=++tot; dep[rt]=d; for(int v:node[rt])&#123; if(v!=fa)dfs(v,rt,d+1); &#125; R[rt]=tot;&#125; 对某个节点X权值加上一个数W, 查询某个子树X里所有点权的和. 对节点X到Y的最短路上所有点权都加一个数W, 查询某个点的权值. 这个操作等价于 a. 对X到根节点路径上所有点权加W b. 对Y到根节点路径上所有点权加W c. 对LCA(x, y)到根节点路径上所有点权值减W d. 对LCA(x,y)的父节点 fa(LCA(x, y))到根节点路径上所有权值减W 于是要进行四次这样从一个点到根节点的区间修改.将问题进一步简化, 进行一个点X到根节点的区间修改, 查询其他一点Y时,只有X在Y的子树内, X对Y的值才有贡献且贡献值为W.当单点更新X时,X实现了对X到根的路径上所有点贡献了W.于是只需要更新四个点(单点更新) ,查询一个点的子树内所有点权的和(区间求和)即可. 对节点X到Y的最短路上所有点权都加一个数W, 查询某个点子树的权值之和. 同问题2中的修改方法, 转化为修改某点到根节点的权值加/减W 当修改某个节点A, 查询另一节点B时 只有A在B的子树内, Y的值会增加 W (dep[A] - dep[B] + 1) =&gt; W (dep [A] + 1) - W dep[B] 那么我们处理两个数组就可以实现: 处理出数组Sum1,每次更新W(dep[A]+1),和数组Sum2,每次更新W. 每次查询结果为Sum1(R[B]) – Sum1(L[B]-1) - (Sum2(R[B]) – Sum2(L[B]-1)) * dep [B]. 对某个点X权值加上一个数W, 查询X到Y路径上所有点权之和. 求X到Y路径上所有的点权之和, 和前面X到Y路径上所有点权加一个数相似 这个问题转化为 X到根节点的和 + Y到根节点的和 - LCA(x, y)到根节点的和 - fa(LCA(x,y)) 到根节点的和 更新某个点x的权值时,只会对它的子树产生影响,对x的子树的每个点到根的距离都加了W. 那么我们用”刷漆”(差分前缀和),更新一个子树的权值.给L[x]加上W,给R[x]+1减去W,那么sum(1~L[k])就是k到根的路径点权和. 对节点X的子树所有节点加上一个值W, 查询X到Y的路径上所有点的权值和 同问题4把路径上求和转化为四个点到根节点的和 X到根节点的和 + Y到根节点的和 - LCA(x, y)到根节点的和 - parent(LCA(x,y)) 到根节点的 再用刷漆只更新子树. 修改一点A, 查询某点B到根节点时, 只有B在A的子树内, A对B才有贡献. 贡献为W (dep[B] - dep[A] + 1) =&gt; W (1 - dep[A]) + W dep[B] 和第三题一样, 用两个sum1,sum2维护 W (dep[A] + 1),和W. 最后答案就是sum2*dep[B]-sum1. 对子树X里所有节点加上一个值W, 查询某个点的值. 对DFS序来说, 子树内所有节点加W, 就是一段区间加W. 所以这个问题就是 区间修改, 单点查询.树状数组+刷漆. 对子树X里所有节点加上一个值W, 查询某个子树的权值和. 子树所有节点加W, 就是某段区间加W, 查询某个子树的权值和, 就是查询某段区间的和 区间修改区间求和,用线段树可以很好解决. 欧拉序 从根结点出发，按dfs的顺序在绕回原点所经过所有点的顺序 Others曼哈顿最小生成树以每个点为原点，划分八个区域，将每个区域里距离 $S$ 最近的点连边，再跑最小生成树算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889struct point&#123; int x,y,id; oper(point)&#123; if(x==obj.x)return y&lt;obj.y; else return x&lt;obj.x; &#125;&#125;a[N];int b[N];int uni[N];int find_root(int x)&#123; if (uni[x]==x) return x; else return uni[x]=find_root(uni[x]);&#125;struct Edge&#123; int u,v,w; oper(Edge)&#123; return w&lt;obj.w; &#125;&#125;edge[2*M];int cnt;void addedge(int u,int v,int w)&#123; edge[cnt].u=u; edge[cnt].v=v; edge[cnt++].w=w;&#125;int n;pii h[N];void add(int p,int loc,int x,int nn)&#123; while(p&lt;=nn)&#123; if(h[p].fi&gt;x)h[p]=pii(x,loc); p+=p&amp;-p; &#125;&#125;pii query(int p)&#123; pii mi(inf,-1); while(p)&#123; if(h[p].fi&lt;mi.fi)mi=h[p]; p-=p&amp;-p; &#125; return mi;&#125;bool cmp(int a,int b)&#123; return a&gt;b;&#125;void fun()&#123; sort(a,a+n); for0(i,n)b[i]=a[i].y-a[i].x; sort(b,b+n,cmp); int m=unique(b,b+n)-b;//离散化 y-x for(int i=1;i&lt;=m;i++)h[i]=pii(inf,-1); for(int i=n-1;i&gt;=0;i--)&#123; int p=upper_bound(b,b+m,a[i].y-a[i].x,cmp)-b; pii mi=query(p); if(mi.se!=-1)addedge(a[i].id,mi.se,mi.fi-a[i].y-a[i].x); add(p,a[i].id,a[i].y+a[i].x,m); &#125;&#125;int main() &#123; int k; in(n,k); for0(i,n)&#123; in(a[i].x,a[i].y); a[i].id=i; &#125; fun(); for0(i,n)swap(a[i].x,a[i].y); fun(); for0(i,n)a[i].x*=-1; fun(); for0(i,n)swap(a[i].x,a[i].y); fun(); sort(edge,edge+cnt); for0(i,n)uni[i]=i; int ans=0,cc=0; for0(i,cnt)&#123; int u=edge[i].u,v=edge[i].v; if(find_root(u)!=find_root(v))&#123; cc++; uni[find_root(u)]=find_root(v); if(cc==n-k)&#123; ans=edge[i].w; break; &#125; &#125; &#125; out(ans,1); return 0;&#125; 莫队对区间询问按左端点排序，将序列分成 $sqrt(n)$ 个长度为 $sqrt(n)$ 的块，若左端点在同一个块内，则按右端点排序。 优化 块的大小为 $\huge\frac n {\sqrt{\frac 2 3 m}}$ 最优 奇偶排序 在块的序号为奇时，对 r 按从小到大排序，反之按从大到小排序 12345678910111213141516struct node &#123; int l,r,id;&#125;q[N];bool cmp(node a,node b)&#123; return a.l/block==b.l/block?a.l/block&amp;1?a.r&lt;b.r:a.r&gt;b.r:a.l&lt;b.l;&#125;int main()&#123; block=n/sqrt(Q*2/3); for(int i=0;i&lt;m;i++)&#123; while(pl &lt; q[i].l) del(a[pl++]); while(pl &gt; q[i].l) add(a[--pl]); while(pr &lt; q[i].r) add(a[++pr]); while(pr &gt; q[i].r) del(a[pr--]); ans[q[i].id] = sum; &#125;&#125; 带修改加上一个时间维，表示操作的时间。即把询问 $[l,r]$ 变为 $[l,r,time]$这一次我们排序的方式是以 $n^{\frac 2 3}$ 为一块，分成了 $n^{\frac 1 3}$ 块，第一关键字是左端点所在块，第二关键字是右端点所在块，第三关键字是时间。 Union Find12345int uni[N];int find_root(int x)&#123; if (uni[x]==x) return x; else return uni[x]=find_root(uni[x]);&#125; 主元素问题找出数组中数量超过一半的数 123456789101112131415161718192021222324252627int findMainElement(const int* array, size_t size) &#123; int candidate = array[0]; int counter = 1; for (int i = 1; i &lt; size; ++i) &#123; if (candidate == array[i]) &#123; ++counter; &#125; else if (counter == 1) &#123; candidate == array[i]; &#125; else &#123; --counter; &#125; &#125; counter = 0; for (int i = 0; i &lt; size; ++i) &#123; if (candidate == array[i]) &#123; ++counter; &#125; &#125; if (counter * 2 &gt; size) &#123; return candidate; &#125; else &#123; return -1; &#125;&#125; 子段和最大子段和123456int b=0,sum=-100000000,l,r;for(int i=0;i&lt;n;i++)&#123; if(b&gt;0) b=b+a[i]; else b=a[i]; if(b&gt;sum) sum=b;&#125; 最大环形子段和思路一： ​ 把环形最大子段和可以看做两部分。第一部分——正常最大子段和，第二部分——跨越a[0] 和 a[n-1]的最大子段和。 第一部分可以用O(n) 求出，第二部分我们从a[0] 开始计算 0~n-2 的最大和，记录结束位置position1。 再从a[n-1] 开始计算 n-1~1的最大和，记录结束位置 position2。 position2 &gt; position1 则第二部分最大和 a[0] + … a[position1] + a[position2] + …a[n-1] position2 &lt;= position1 则第二部分最大和 a[0] + ……. a[n-1] 思路二： 数组总和 - 最小子段和 最大M个子段和设F(i, j) 为 在前i个元素中选j个子段的最大和，且包含元素a[j]. 那么对于a[j] , 1) a[j] 自己组成第 j 子段 ； 2) a[j] 包含于第 j 子段中； 长度不超过m的最大子段和dp[i] = sum[i] - min(sum[j] | i- m &lt;= j &lt;= i) 利用单调队列优化.如果来了一个前缀，肯定下标是比在队列里的是靠后的，如果它的值还比队列里的小，那么队列里的元素就没有必要存在了，就把它们踢出去。 这样的话最小值就是队首的元素，当然在用队首元素的时候还要在看一下当前的队首元素还符不符合限制条件，如果不符合就弹出。 123456789101112ll fun(ll m, ll a[], int len) &#123; // a的下标从1开始 list&lt;ll&gt; li; li.push_back(0); ll ans = 0; for1(i, len) &#123; while (!li.empty() &amp;&amp; a[li.back()] &gt; a[i]) li.pop_back(); li.push_back(i); while (!li.empty() &amp;&amp; i - li.front() &gt; m) li.pop_front(); ans = max(ans, a[i] - a[li.front()]); &#125; return ans;&#125; 最大绝对值子段和要么正的最大，要么负的最小。 所以问题解等于max{abs(最大子段和)， abs(最小子段和)} 最小绝对值字段和 构造数组 b[0] = a[0];\\ b[1] = a[0] + a[1];\\ \cdots\\ b[n-1] = a[0] + \cdots +a[n-1]; 对b排序（保留index 信息） 求排序后数组相邻位置差最小 固定长度的区间极值1234567int l=1,r=0,q[N];//q[i]表示从 i 开始长度为 len 的序列中的最小值的下标for1(i,n)&#123; while(i-q[l]+1&gt;a&amp;&amp;l&lt;=r)l++; while(a[q[r]]&gt;a[i]&amp;&amp;l&lt;=r)r--; q[++r]=i; minn[i]=a[q[l]];//minn[i]表示以 i 结尾的长度为 len 的序列中的最小值&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Graph]]></title>
    <url>%2F2019%2F08%2F17%2FGraph%2F</url>
    <content type="text"><![CDATA[存图前向星1234567891011121314151617181920212223struct Edge&#123; int u,v,w,nxt;&#125;edge[2*M];int fir[N],cnt,FLAG;void addedge(int u,int v,int w)&#123; if(!FLAG)&#123; mem_1(fir); FLAG=1; &#125; //edge[cnt].u=u; edge[cnt].v=v; edge[cnt].w=w; edge[cnt].nxt=fir[u]; fir[u]=cnt++;&#125;struct node&#123; int u; int d; node(int u,int d):u(u),d(d)&#123;&#125; bool operator &lt; (const node &amp;a) const&#123; return d&gt;a.d; &#125;&#125;; 最短路floyd-warshall123456//Floyd-Warshall算法核心语句 for(k=1;k&lt;=n;k++)//先枚举中转点 for(i=1;i&lt;=n;i++)//枚举起点 for(j=1;j&lt;=n;j++)//枚举终点 if(e[i][k]&lt;inf &amp;&amp; e[k][j]&lt;inf &amp;&amp; e[i][j]&gt;e[i][k]+e[k][j]) e[i][j]=e[i][k]+e[k][j]; bellman1234567891011121314151617181920bool bellman_ford(int start, int n)&#123; for (int i = 1; i &lt;= n; i++)dist[i] = INF; dist[start] = 0; for (int i = 1; i&lt;n; i++)&#123; bool flag = false; for (int j = 0; j&lt;E.size(); j++)&#123; int u = E[j].u; int v = E[j].v; int cost = E[j].cost; if (dist[v]&gt;dist[u] + cost)&#123; dist[v] = dist[u] + cost; flag = true; &#125; &#125; if (!flag)return true; &#125; for (int j = 0; j&lt;E.size(); j++) if (dist[E[j].v]&gt;dist[E[j].u] + E[j].cost) return false; return true;&#125; SPFA123456789101112131415161718192021222324252627282930const int inf=0x3f3f3f3f;int cnt[509],bm[109];bool used[509];vector&lt; pair&lt;int,int&gt; &gt; edge[509];bool spfa(int st)&#123; for(int i=1; i&lt;=n; i++)bm[i]=inf; memset(used,0,sizeof(used)); memset(cnt,0,sizeof(cnt));//记录从起点到i点的最短距离包含点的个数 bm[st]=0; cnt[st]=1; used[st]=1; queue&lt;int&gt; que; que.push(st); while(!que.empty())&#123; int u=que.front(); used[u]=0; que.pop(); for(int i=0; i&lt;edge[u].size(); i++)&#123; int v=edge[u][i].first; int w=edge[u][i].second; if(bm[v]&gt;bm[u]+w)&#123; bm[v]=bm[u]+w; cnt[v]=cnt[u]+1; if(cnt[v]&gt;n) return 0;//存在负环 if(!used[v])&#123; que.push(v); used[v]=1; &#125; &#125; &#125; &#125; return 1;&#125; 堆优dijkstra123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Edge&#123; int u,v,w,nxt;&#125;edge[2*M];int fir[N],cnt,FLAG;void addedge(int u,int v,int w)&#123; if(!FLAG)&#123; mem_1(fir); FLAG=1; &#125; //edge[cnt].u=u; edge[cnt].v=v; edge[cnt].w=w; edge[cnt].nxt=fir[u]; fir[u]=cnt++;&#125;struct node&#123; int u; int d; node(int u,int d):u(u),d(d)&#123;&#125; bool operator &lt; (const node &amp;a) const&#123; return d&gt;a.d; &#125;&#125;;bool used[N];int dis[N];void dijkstra()&#123; priority_queue&lt;node&gt; que; while(!que.empty()) que.pop(); for(int i=1; i&lt;N; i++)dis[i]=inf; dis[1]=0; que.push(node(1,dis[1])); memset(used,0,sizeof(used)); while(!que.empty())&#123; int u=que.top().u; que.pop(); if(used[u]) continue; used[u]=1; for(int i=fir[u]; i!=-1; i=edge[i].nxt)&#123; int v=edge[i].v; int w=edge[i].w; if(used[v]) continue; if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; que.push(node(v,dis[v])); &#125; &#125; &#125;&#125; dijkstra1234567891011121314151617181920212223242526for(int i=1; i&lt;=n; i++) &#123; dis[i]=edge[1][i]; used[i]=1; &#125; used[1]=0; dis[1]=0; for(int i=1; i&lt;=n; i++) &#123; //printf("ASD\n"); int minV=inf; int id=1;//important for(int j=1; j&lt;=n; j++) if(used[j]&amp;&amp;minV&gt;dis[j]) &#123; minV=dis[j]; id=j; &#125; used[id]=0; for(int j=1; j&lt;=n; j++) &#123; if(edge[id][j]&lt;inf&amp;&amp;used[j]&amp;&amp;dis[j]&gt;dis[id]+edge[id][j]) dis[j]=dis[id]+edge[id][j]; &#125; &#125; 差分约束系统 求解差分约束系统，都可以转化成图论的单源最短路径（或最长路径）问题。我们观察上面例子中的不等式，都是x[i] - x[j] &lt;= a[k]，可以进行移项，成为x[i] &lt;= x[j] + a[k]，我们令a[k] = w(j, i)，dis[i]=x[i],并使i=v,j=u,那么原始就变为：dis[u]+w(u,v)&gt;=dis[v],于是可以联想到最短路模型中的一部分代码但是好像不等号方向刚好相反，但其实这并不矛盾，上面的代码要实现的是使dis[u]+w(u,v)&gt;dis[v],而对于不等式，我们进行建边的操作：对于每个不等式 x[i] - x[j] &lt;= a[k]，对结点 j 和 i 建立一条 j -&gt; i的有向边，边权为a[k]，求x[n-1] - x[0] 的最大值就是求 0 到n-1的最短路，两者刚好吻合。所以求解差分约束问题就转化为了最短路问题。 差分约束 求解不等式组，当把不等式整理成 $d[a]+w&lt;=d[b]$ 时，我们求最长路。整理成 $d[a]+w&gt;=d[b]$ 时，我们求最短路。在一个未知数定死的情况下，最短路求得是最大值，最长路求得是最小值。 candies1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int inf=0x3f3f3f3f;int n,m,cnt;struct Edge&#123; int u,v,w,nxt;&#125;edge[150005];int fir[30004];void addedge(int u,int v,int w)&#123; //edge[cnt].u=u; edge[cnt].v=v; edge[cnt].w=w; edge[cnt].nxt=fir[u]; fir[u]=cnt++;&#125;struct node&#123; int u; int d; node(int u,int d):u(u),d(d)&#123;&#125; bool operator &lt; (const node &amp;a) const &#123; return d&gt;a.d; &#125;&#125;;bool used[30004];int dis[30004];void dijkstra()&#123; priority_queue&lt;node&gt; que; while(!que.empty()) que.pop(); for(int i=1; i&lt;=n; i++) dis[i]=inf; dis[1]=0; que.push(node(1,dis[1])); memset(used,0,sizeof(used)); while(!que.empty()) &#123; int u=que.top().u; que.pop(); if(used[u]) continue; used[u]=1; for(int i=fir[u]; i!=-1; i=edge[i].nxt) &#123; int v=edge[i].v; int w=edge[i].w; if(used[v]) continue; if(dis[v]&gt;dis[u]+w) &#123; dis[v]=dis[u]+w; que.push(node(v,dis[v])); &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)==2) &#123; memset(fir,-1,sizeof(fir)); cnt=0; for(int i=1; i&lt;=m; i++) &#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addedge(u,v,w); &#125; dijkstra(); printf("%d\n",dis[n]); &#125; return 0;&#125; 最小生成树最大独立集与最大团最大团12345678910111213141516171819202122232425262728293031323334int n,m,ans;int used[N];int cnt[N];//cnt[i] 结点[i,n]构成的最大团的数量int group[N];bool edge[N][N];bool dfs(int u,int dep)&#123; for(int i=u+1; i&lt;=n; i++)&#123; if(cnt[i]+dep&lt;=ans)return 0; if(edge[u][i])&#123; int j=0; for(j=0; j&lt;dep; j++)&#123; if(!edge[i][used[j]])break; &#125; if(j==dep)&#123; used[dep]=i; if(dfs(i,dep+1))return 1; &#125; &#125; &#125; if(dep&gt;ans)&#123; for(int i=0; i&lt;dep; i++)group[i]=used[i]; ans=dep; return 1; &#125; return 0;&#125;void maxclique()&#123; memset(used,0,sizeof(used)); for(int i=n; i&gt;=1; i--)&#123;//n为点数 used[0]=i; dfs(i,1); cnt[i]=ans; &#125;&#125; 最大独立集补图的最大团]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Geomerty]]></title>
    <url>%2F2019%2F08%2F17%2FGeometry%2F</url>
    <content type="text"><![CDATA[preprocess123456typedef long double db;const db pi = acos(-1.0);const db inf = 1e100;const db eps = 1e-8;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125; Point&amp;Vector&amp;PolarPoint123456789101112131415161718192021222324252627282930struct Point&#123; db x,y; Point()&#123;&#125; Point(db _x,db _y) : x(_x),y(_y)&#123;&#125;&#125;;typedef Point Vector;bool operator == (Point a, Point b) &#123;return sign(a.x - b.x) == 0 &amp;&amp; sign(a.y - b.y) == 0;&#125;Vector operator + (Vector a, Vector b) &#123;return (Vector)&#123;a.x + b.x, a.y + b.y&#125;;&#125;Vector operator - (Vector a, Vector b) &#123;return (Vector)&#123;a.x - b.x, a.y - b.y&#125;;&#125;db operator * (Vector a, Vector b) &#123;return a.x * b.x + a.y * b.y;&#125;//点积db operator ^ (Vector a, Vector b) &#123;return a.x * b.y - a.y * b.x;&#125;//叉积,顺时针为负Vector operator * (Vector a, db b) &#123;return (Vector)&#123;a.x * b, a.y * b&#125;;&#125;Vector operator / (Vector a, db b) &#123;return (Vector)&#123;a.x / b, a.y / b&#125;;&#125;db DisPointToPoint(Point a, Point b) &#123;return sqrt((a - b) * (a - b));&#125;db AngleOfVector(Vector a, Vector b) &#123;return fabs(atan2(a ^ b, a * b));&#125;Vector RotateAnticlockwise(Vector v, db Angle) &#123;//逆时针旋转Angle度 return (Point)&#123;v.x * cos(Angle) - v.y * sin(Angle),v.x * sin(Angle) + v.y * cos(Angle)&#125;;&#125;db LengthOfVector(Vector a) &#123;return DisPointToPoint(a, Point(0,0));&#125;struct PolarPoint &#123; db Angle, Length; PolarPoint(db a,db b):Angle(a),Length(b)&#123;&#125;&#125;;Vector PolarPointToVector(PolarPoint a) &#123; return (Vector)&#123;a.Length * cos(a.Angle),a.Length * sin(a.Angle)&#125;;&#125;PolarPoint VectorToPolarPoint (Vector a)&#123; return PolarPoint(atan2(a.y,a.x),LengthOfVector(a));&#125; Line&amp;Segment12345678910111213141516struct Line &#123; Point s, t; Line()&#123;&#125; Line(Point _s,Point _t):s(_s),t(_t)&#123;&#125;&#125;;typedef Line Segment;db LengthOfSegment(Segment a) &#123;return DisPointToPoint(a.s, a.t);&#125;db DisPointToLine(Point a, Line b) &#123; if(b.s==b.t)return DisPointToPoint(a,b.s); return fabs((a - b.s) ^ (b.t - b.s)) / LengthOfSegment(b);&#125;db DisPointToSegment(Point a, Segment b) &#123; if (sign((a - b.s) * (b.t - b.s)) &lt; 0 || sign((a - b.t) * (b.s - b.t)) &lt; 0) return min(DisPointToPoint(a, b.s), DisPointToPoint(a, b.t)); return DisPointToLine(a, b);&#125; Ciercle12345struct Circle &#123; Point Center; db Radius; Circle(Point _C,db _R):Center(_C),Radius(_R)&#123;&#125;&#125;; Simpson用二次曲线逼近原函数，在平面直角坐标系中，由三点 $(x_1,y_1),(x_2,y_2),(x_3,y_3) (x_1&lt;x_2&lt;x_3,x_2=\frac{x_1+x_3} 2)$ 确定的抛物线 $y=f(x)$ 的定积分为 \large\int_{x_1}^{x_3}f(x)dx=\frac 1 6(x_3-x_1)(y_1+4y_2+y_3)将要积分的区域 $[L, R]$ 划分成 $n$ 份，横坐标为 $x_0\sim x_n$，对应的函数值分别为 $y_0\sim y_n$ 其结果为 \large\int_L^Rf(x)dx\approx \frac {R-L}{3n}[(y_0+y_n)+2(y_2+y_4+\cdots+y_{n-2})+4(y_1+y_3+\cdots+y_{n-1})]自适应Simpson对要积分的区域 $[L, R]$ 分成两半 $[L, mid]$ 和 $[mid, R]$，如果用二次曲线对 $(L, mid, R)$ 求出的积分值，和对 $(L, \frac {L+mid} 2, mid)$ 和 $(mid,\frac {L+mid} 2, R)$ 分别积分再加起来的值，相差不超过某个精确度，那么就可以停止划分。 1234567891011121314// 1db simpson (db a,db b)&#123; db c = a + (b-a)/2; return (F(a)+4*F(c)+F(b))*(b-a)/6;&#125;db asr (db a,db b,db eps,db A)&#123; db c = a + (b-a)/2; db L=simpson(a,c),R=simpson(c,b); if(fabs(L+R-A)&lt;=15*eps)return L+R+(L+R-A)/15.0; return asr(a,c,eps/2,L)+asr(c,b,eps/2,R);&#125;db asr(db a,db b,db eps)&#123;//a-左端点, b-右端点 return asr(a,b,eps,simpson(a,b));&#125; 1234567891011// 2db calc(db len,db fL,db fM,db fR)&#123; //求长度为len的[L,R]区间，中点为M的Simpson近似面积 return (fL+4*fM+fR)*len/6;&#125;db Simpson(db L,db R) &#123;//Simpson积分求区间[L,R]的面积并,F(L)=L,F(R)=R,F(M)=M,把[L,R]当成整体来拟合得到的面积是sqr db M=(L+R)/2,fL=F(L),fM=F(M),fR=F(R),sqr=calc(R-L,fL,fM,fR); db g1=calc(M-L,fL,F((L+M)/2),fM),g2=calc(R-M,fM,F((M+R)/2),fR); if(fabs(sqr-g1-g2)&lt;=eps) //把当前区间分成2半再拟合得到的答案差别很小，就不再递归下去了 return g1+g2; return Simpson(L,M)+Simpson(M,R);&#125; Othersn 维球体的体积递推公式 V_{n+1}=2 \int_{0}^{\frac{\pi}{2}} V_{n} \cos ^{n} \theta\ d({\sin \theta})]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2F2019%2F08%2F17%2FJava%2F</url>
    <content type="text"><![CDATA[temple1234567891011import java.io.*;import java.util.*;import java.math.*; public class Main&#123; public static void main(String[] args) throws IOException&#123; Scanner sc =new Scanner(System.in); sc.close(); &#125;&#125; IO1234567891011121314151617181920//System.in，只能读取单个字符char i = (char) System.in.read(); //BufferedReader类和InputStreamReader类，读取一个字符串BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); String str = null; str = reader.readLine(); System.out.println("your value is :"+str); int n = Integer.parseInt(reader.readLine());//ScannerScanner sc = new Scanner(System.in); System.out.println("请输入你的姓名："); String name = sc.nextLine(); //next()方法是不接收空格的，在接收到有效数据前，所有的空格或者tab键等输入被忽略，若有有效数据，则遇到这些键退出。nextLine()可以接收空格或者tab键，其输入应该以enter键结束。System.out.println("请输入你的年龄："); int age = sc.nextInt(); System.out.println("请输入你的工资："); float salary = sc.nextFloat(); System.out.println("你的信息如下："); System.out.println("姓名："+name+"\n"+"年龄："+age+"\n"+"工资："+salary); BigInteger12345678910111213141516String temp1 = "-1000000000000000000000000000000000000";BigInteger bg1 = new BigInteger(temp1); //注意初始化的方式,使用字符串来初始化System.out.println(bg1.abs()); //绝对值方法 object.abs()String temp2 = "100000000000000000000000000";BigInteger bg2 = new BigInteger(temp2);System.out.println(bg1.add(bg2)); //加法 object.add(BigInteger b)System.out.println(bg1.subtract(bg2)); //减法 返回为 bg1 - bg2 (this - param)System.out.println(bg1.multiply(bg2)); //乘法 返回 bg1 * bg2System.out.println(bg1.divide(bg2)); //除法 返回bg1 / bg2System.out.println(bg1.mod(bg2)); //取模运算 返回的是 bg1%bg2 (this mod param)System.out.println(bg1.gcd(bg2)); //直接封装好了 求解bg1,bg2 的最大公约数int temp5 = 5;System.out.println(bg2.pow(temp5)); //乘方运算 注意这个方法的参数是基本类型intSystem.out.println(bg2.compareTo(bg1)); // 比较方法 结果为1,bg2大;0,相等;-1,bg1大System.out.println(bg3.equals(bg4)); //返回结果为true//在BigDecimal更直观，例如0.1 与0.10 ，equal返回false 而compareTo则是正确的结果。 BigDecimal123456789101112131415String temp1 = "1.2222222222222222222222222";BigDecimal bd1 = new BigDecimal(temp1);String temp2 = "2.333333333333333333333333";BigDecimal bd2 = new BigDecimal(temp2);System.out.println(bd1.add(bd2)); // 加法 System.out.println(bd1.add(bd2).doubleValue()); //3.5555555555555554 这里用了一个方法将结果转化为double类型了System.out.println(bd2.subtract(bd1)); //减法 输出 1.1111111111111111111111108System.out.println(bd2.subtract(bd1).doubleValue()); //输出 1.1111111111111112System.out.println(bd2.multiply(bd1)); //乘法System.out.println(bd2.divide(bd1, 5, RoundingMode.HALF_UP));//除法应该注意很有可能会有除不尽的情况，这时候会有异常抛出，所以要传入控制参数System.out.println(bd1.compareTo(bd2)); //比较方法BigDecimal bd3 = new BigDecimal("1.20");BigDecimal bd4 = new BigDecimal("1.2");System.out.println(bd3.compareTo(bd4)); //返回0表示相等System.out.println(bd3.equals(bd4));//返回的是false 是错误的,所以比较的时候使用compareTo()方法 vector1234567891011121314151617Vector&lt;E&gt; v = new Vector&lt;E&gt;();//下标访问v.elementAt(int index);//遍历for(Iterator&lt;E&gt; iter=v.iterator(); ite.hasNext() ;) &#123; System.out.println(ite.next());&#125;Iterator&lt;E&gt; ite=S_vec.iterator();while(ite.hasNext()) &#123; System.out.println(ite.next());&#125;Enumeration&lt;E&gt; e=v.elements();while(e.hasMoreElements()) &#123; System.out.println(e.nextElement());&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NumberTheory]]></title>
    <url>%2F2019%2F08%2F17%2FNumberTheory%2F</url>
    <content type="text"><![CDATA[NumberTheory 快速乘12345678910111213ll qMulti(ll x,ll y,ll n)&#123; //求(x*y)%n ll ret=0,tmp=x%n; while(y) &#123; if(y&amp;0x1)if((ret+=tmp)&gt;n)ret-=n; if((tmp&lt;&lt;=1)&gt;n)tmp-=n; y&gt;&gt;=1; &#125; return ret; &#125;ll qMulti(ll x,ll y,ll mod)&#123; //O(1)快速乘 return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod; &#125; 快速幂12345678910111213141516171819ll qPow(ll a,ll b,ll c)&#123; //求(a^b) % c ，c超出int范围 ll ret=1; while(b) &#123; if(b&amp;0x1)ret=qMulti(ret,a,c); a=qMulti(a,a,c); b&gt;&gt;=1; &#125; return ret;&#125;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125; 欧几里得算法gcd12345ll gcd(ll x,ll y)&#123; return y?gcd(y, x%y):x;&#125;__gcd(x,y) exgcd123456789101112131415ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; //求解ax+by=gcd(a,b),返回gcd(a,b) if(b==0)&#123; x = 1; y = 0; return a; &#125; ll r = exgcd(b, a%b, y, x); y -= a/b*x; //这里已经是递归，回溯的过程了，x,y已经颠倒了 return r;&#125;/*x = c/gcd(a,b)*x0 + b/gcd(a,b)*t;y = c/gcd(a,b)*y0 - a/gcd(a,b)*t; (x0, y0 为方程的一组特解, t为整数)*/ 裴蜀定理$ax+by=c$ 有解的充要条件为 $gcd(a,b) | c$ 推广: $a_1x_1+a_2x_2+\cdots+a_nx_n=c$ 有解的充要条件为 $gcd(a_1,a_2,\cdots,a_n) | c$ 类欧问题素数和因子打表12345678910111213bool notP[N];int prime[N],num_prime=0;void get_prime()&#123; notP[1]=1; for(int i=2;i&lt;N;i++)&#123; if(!notP[i]) prime[num_prime++]=i; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;N;j++)&#123; int k = i*prime[j]; notP[k] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125; 区间素数12345678memset(visab,0,sizeof(visab));for (int i = 0; i &lt; cnt &amp;&amp; prime[i] &lt;= b; i++) &#123; LL k = a / prime[i]; if (k * prime[i] &lt; a) k++; for (LL j = k * prime[i]; j &lt;= b; j += prime[i]) &#123; visab[j - a] = 1; &#125;&#125; 唯一分解定理12345678910111213141516171819202122232425262728293031323334pair&lt;ll,int&gt; factor[50];int num_factor = 0;void decomposition(ll n) &#123; num_factor = 0; for (int i = 0; i &lt; num_prime &amp;&amp; (ll)prime[i] * prime[i] &lt;= n &amp;&amp; n &gt; 1;++i) &#123; if (n % prime[i] == 0) &#123; int cnt=0; while (n % prime[i] == 0 ) &#123; n /= prime[i]; cnt++; &#125; factor[num_factor++] = pair&lt;ll,int&gt;(prime[i],cnt); &#125; &#125; if (n &gt; 1) factor[num_factor++] = pair&lt;ll,int&gt;(n,1);&#125;pair&lt;ll,int&gt; factor[50];int num_factor = 0;void decomposition(ll n) &#123; num_factor = 0; int m=(int)sqrt(n+0.5); for(int i=2;i&lt;=m;i++)&#123; if(n%i==0)&#123; factor[num_factor]=pair&lt;ll,int&gt;(i,0); while(n%i==0)&#123; factor[num_factor].se++; n/=i; &#125; num_factor++; &#125; &#125; if (n &gt; 1) factor[num_factor++] = pair&lt;ll,int&gt;(n,1);&#125; n 的因子数分解 n，$\large n=p_1^{a_1}*p_2^{a_2}\cdots p_m^{a_m}$，n 的因子和为 \Large\tau(n)=\prod\limits_{i=1}^ma_i+1n 的因子和分解 n，$\large n=p_1^{a_1}*p_2^{a_2}\cdots p_m^{a_m}$，n 的因子和为 \Large\sigma(n)=\prod\limits_{i=1}^m(p_i^0+p_i^1+\cdots+p_i^{a_i})=\prod\limits_{i=1}^m\frac {p_i^{a_i+1}-1} {p_i-1}1-n的因子数$\Large\sum\limits_{i=1}^n\lfloor\frac n i\rfloor$ n=12 $\large\lfloor\frac n i\rfloor$ [l,r] 12 [1,1] 6 [2,2] 4 [3,3] 3 [4,4] 2 [5,6] 1 [7,12] 每个 $l$ 等于上一个 $r+1$，$r=n/(n/l)$ 1234567891011121314151617//solution1ll res = 0;for (int l = 1; l &lt;= n; l = r + 1) &#123; int r = n / (n / l); res += (n / l) * (r - l + 1);&#125;//solution2int k=sqrt(n+0.1);for (int i = 1; i &lt;= k; i++) &#123; ans+=n/i; if (n/(i+1)&lt;i)break; else ans+=(n/i-n/(i+1))*i;&#125;//solution3for (int i = 1; i &lt;= k; i++) ans+=n/i;ans*=2;ans-=k*k; 1-n的因子之和统计 1-n 每个数取的次数$\Large\frac n i$，即$\Large\sum\limits_{i=1}^n\lfloor\frac n i\rfloor*i$ 12345ll res = 0;for (int l = 1; l &lt;= n; l = r + 1) &#123; int r = n / (n / l); res += (n / l) * (r + l) * (r - l + 1) / 2;&#125; 费马小定理 x^{p-1}\equiv1(mod\ p)威尔逊定理 (p-1)!\equiv-1(mod\ p)积性函数 $f[1]=1$ $设n=\prod p_i^{k_i},则f(n)=f(\prod p_i^{k_i})=\prod f(p_i^{l_i})$ $设n=\prod p_i^{k_i},则f(n)=f(\prod p_i^{k_i})=\prod f(p_i)^{k_i}$ 若满足这一项称为完全积性函数。 欧拉函数 {\phi(n)=\left\{\begin{array}{c}1&n=1\\\prod(p_i-1)p_i^{k_i-1}=n\prod\left(1-\frac1 p_i\right)& n=\prod p_i^{k_i}\\\end{array}\right.} $1\sim n$中与 n 互质的个数(包括 1 ) 积性 \phi(mn)=\phi(m)\phi(n)\ , \ gcd(m,n)=1 $prime[i]\le x&lt;prime[i+1]$，必定有$\phi(x)\le prime[i]$ 欧拉定理 a^{\phi(n)}\equiv1(mod\ n)\ ,\ gcd(n,a)=1 扩展欧拉定理 \large A^K \equiv \left\{\begin{array}{c} A^{K\mod\phi(n)}&gcd(n,A)=1 \\ A^K&K< \phi(n)\\ A^{K\mod\phi(n)+\phi(n) }&K\ge \phi(n) \end{array}\right.\qquad(mod\ n) $1\sim n$中与 n 互质的数的和为$\large \frac {n*\phi(n)} 2+\epsilon(n)$ 设 gcd(n,p)=1，由更相减损术得 gcd(n-p,p)=1，且一定有p≠n-p，故 1~n 中与 n 互质的数可以由此两两配对，而每一对的和都为 n，所以总和为 n*φ(n)/2 求欧拉函数 1234567891011121314151617181920212223242526int euler(int n)&#123; int ans=1; for (int i=0; i&lt;prime.size()&amp;&amp;prime[i]*prime[i]&lt;=n&amp;&amp;n!=1; i++) &#123; int e=0; while (n%prime[i]==0&amp;&amp;n!=1) &#123; e++; n/=prime[i]; &#125; if (e) ans*=pow(prime[i], e-1)*(prime[i]-1); &#125; if (n&gt;1) ans*=(n-1); return ans;&#125;O(sqrt(n))int euler(int n)&#123; int m=(int)sqrt(n+0.5); int ans=n; for(int i=2;i&lt;=m;i++)&#123; if(n%i==0)&#123; ans=ans/i*(i-1); while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) ans=ans/n*(n-1); return ans;&#125; 欧拉函数打表 直接打表 123456for(i=1; i&lt;=maxn; i++) p[i]=i;for(i=2; i&lt;=maxn; i+=1) if(p[i]==i)&#123; for(j=i; j&lt;=maxn; j+=i) p[j]=p[j]/i*(i-1); &#125; 利用线筛打表O(n) 123456789101112131415161718bool notPrime[N+1];int prime[N+1],num_prime=0,phi[N];void get_prime()&#123; notPrime[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!notPrime[i]) &#123; prime[num_prime++]=i; phi[i]=i-1; &#125; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;=N;j++)&#123; notPrime[i*prime[j]] = 1; if(i%prime[j] == 0) &#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125;else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125;&#125; 莫比乌斯函数 \mu(n)= \left\{ \begin{array}{c} 1&n=1\\ (-1)^r& n=\prod\limits_{i=1}^r p_i\\ 0&other \end{array} \right. 打表 123456789101112131415161718bool notPrime[N+1];int prime[N+1],num_prime=0,miu[N];void get_prime()&#123; notPrime[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!notPrime[i]) &#123; prime[num_prime++]=i; miu[i]=-1; &#125; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;=N;j++)&#123; notPrime[i*prime[j]] = 1; if(i%prime[j] == 0) &#123; miu[i*prime[j]]=0; break; &#125;else miu[i*prime[j]]=miu[i]*(-1); &#125; &#125;&#125; 除数函数 \large\sigma_x(n)=\sum\limits_{d|n}d^x一些完全积性函数 常函数 \forall n\in N,1(n)=1 单位函数 \forall n\in N,id(n)=n 幂函数 \forall n\in N,id_k(n)=n^k 狄利克雷卷积单位函数 \epsilon(n)= \left\{ \begin{array}{c} 1&n=1\\ 0&n>1 \end{array} \right. 卷积乘积函数 (f*g)(n)=f(n)g(n)Dirichlet卷积函数 (f\times g)(n)=\sum\limits_{d|n}f(d)g(\frac n d)一些卷积 \epsilon \times 1=1\\ \mu\times1=\epsilon\\ \ \\ \phi\times1=id\\ \mu\times id=\phi莫比乌斯反演 f\times 1=g\Longleftrightarrow \mu\times g=f取模除法取模 b和m不互质 $\frac a b \%m =\frac{a \% (bm)}b$ 证: 设$\frac a b \%m=r$ $\frac a b =km+r$ $a=kbm+br$ $br=a-kbm$ $r=\frac{a \% (b*m)}b$ 逆元( inv ) $\frac a b \%m$时，因 $b$ 可能会过大，会出现爆精度的情况，所以需变除法为乘法，设 $c$ 是 $b$ 的逆元，则有 $b*c≡1(mod m)$，即 $\frac a b$ 的模等于 $a\times inv(b)$ 的模； $m$ 为素数，根据费马小定理 $c=b^{m-2}(\mod m)$ ; $b*c≡1(\mod m)$ 使用扩展欧几里得算法 逆元打表 123456789101112131415//求1,2,...,N关于mod的逆元（mod为质数）ll inv[N];inv[1] = 1;for (int i = 2; i &lt; N; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;/*证明 : i* inv[i] = inv[mod % i] * ((i - 1) * mod + mod - mod / i * i) % mod;i* inv[i] = inv[mod % i] * ((i - 1) * mod + mod % i) % mod;i* inv[i] = (inv[mod % i] * (i - 1) * mod + 1) % mod;i* inv[i] = 1 % mod;*///求N!关于mod的逆元（mod为质数）ll inv[N];inv[N-1] = qPow(fac[N-1], mod - 2, mod);for (int i = N - 2; i &gt;= 0; i--) inv[i] = (inv[i + 1] * (i + 1)) % mod;/*证明 : inv[i + 1] * (i + 1) != 1 % mod;inv[i + 1] * (i + 1) * i != 1 % mod;*/ 组合数取模 n,m 1e5 预处理出逆元和阶乘 1234567891011ll fac[N],inv[N];ll C(ll a,ll b)&#123; if(b&gt;a)return 0; return fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;void init()&#123;//快速计算阶乘的逆元 fac[0]=fac[1]=1; for(int i=2;i&lt;N;i++)fac[i]=fac[i-1]*i%mod; inv[N-1] = qPow(fac[N-1], mod - 2, mod); for (int i = N - 2; i &gt;= 0; i--) inv[i] = (inv[i + 1] * (i + 1)) % mod;&#125; n 1e9 , m 1e5 12for(int i=1;i&lt;=m;i++) ans=ans*(n-i+1)%mod*qPow(i,mod-2,mod)%mod; n,m 1e18 , mod 1e5,素数 卢卡斯定理(Lucas) \left(\begin{array}{c}{m} \\ {n}\end{array}\right) \equiv \prod_{i=0}^{k}\left(\begin{array}{c}{m_{i}} \\ {n_{i}}\end{array}\right) \quad(\bmod p)\\ m=m_{k} p^{k}+m_{k-1} p^{k-1}+\cdots+m_{1} p+m_{0}\\ n=n_{k} p^{k}+n_{k-1} p^{k-1}+\cdots+n_{1} p+n_{0}123456ll Lucas(ll n, ll m)&#123; if(m==0) return C(n, m); return C(n % mod, m % mod) * Lucas(n / mod, m / mod)%mod;&#125;/*表达式：C(n,m)%p=C(n/p,m/p)*C(n%p,m%p)%p。（可以递归）递归方程：(C(n%p, m%p)*Lucas(n/p, m/p))%p。（递归出口为m==0，return 1）*/ exLucas 求解 $C_n^m \mod p$ ， $p$ 不是素数 分解 $\large p=\prod p_i^{k_i}$ ，分别求 $C_n^m\mod p_i^{k_i}$ ，使用中国剩余定理合并 求解 $C_n^m\mod p_i^{k_i}$ C_n^m=\frac {n!}{m!\times (n-m)!}\\ \text{提出 }n!,m!,(n-m)!\text{ 中的素因子 }p\\ \frac {\frac {n!}{p^{k1}}}{\frac {m!}{p^{k2}}\times\frac {(n-m)!}{p^{k3}}}\times p^{k1-k2-k3} 易证 $k1-k2-k3\ge0$ 求解 $f(n)=\large\frac {n!}{p^a}\mod p^k$ ，分三部分 $1\sim n$ 中拥有 $p$ 因子的数的贡献：$f(\lfloor\frac n p\rfloor)$ $\Large\prod\limits_{i=1,(i,p)=1}^{p^k}i^{\lfloor\frac n {p^k}\rfloor}$ $\Large\prod\limits_{i=1,(i,p)=1}^{n\mod p^k}i$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; //求解ax+by=gcd(a,b),返回gcd(a,b) if(b==0)&#123; x = 1; y = 0; return a; &#125; ll r = exgcd(b, a%b, y, x); y -= a/b*x; //这里已经是递归，回溯的过程了，x,y已经颠倒了 return r;&#125;ll Chinese_Remainder(ll a[],ll m[],int len)&#123;//中国剩余定理 a存放余数 m存放两两互质的数 ll M=1,ret=0; for(int i = 0; i &lt; len; i++) M *= m[i]; for(int i = 0; i &lt; len; i++)&#123; ll Mi = M/m[i],x,y; exgcd(m[i],Mi,x,y); ret = (ret+y*Mi*a[i])%M; &#125; return (M+ret%M)%M;&#125;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;ll pre[N],cnt;ll fac(ll n,ll pk,ll p)&#123; if(n&lt;p)return pre[n]; cnt+=n/pk; return pre[n%pk]*fac(n/p,pk,p)%pk;&#125;ll vp(ll n,ll p)&#123; ll ans=0; while(n)&#123; ans+=n/p; n/=p; &#125; return ans;&#125;ll C(ll n,ll m,ll pk,ll p)&#123; pre[0]=1; for(int i=1;i&lt;=pk;i++)&#123; pre[i]=pre[i-1]; if(i%p)pre[i]=pre[i-1]*i%pk; &#125; cnt=0; ll ans=fac(n,pk,p)*qPow(pre[pk],cnt,pk)%pk*qPow(p,vp(n,p)-vp(m,p)-vp(n-m,p),pk)%pk; ll x,y; cnt=0; exgcd(fac(m,pk,p)*qPow(pre[pk],cnt,pk)%pk,pk,x,y); ans=ans*x%pk; cnt=0; exgcd(fac(n-m,pk,p)*qPow(pre[pk],cnt,pk)%pk,pk,x,y); ans=ans*x%pk; return ans;&#125;ll exLucas(ll n,ll m,ll p)&#123; ll a[100],b[100]; int sq=sqrt(p+0.1); int tot=0; for(int i=2;i&lt;=sq&amp;&amp;p&gt;1;i++)&#123; int pk=1; while(p%i==0)&#123; pk*=i; p/=i; &#125; if(pk&gt;1)&#123; a[tot]=C(n,m,pk,i); b[tot++]=pk; &#125; &#125; if(p&gt;1)&#123; a[tot]=C(n,m,p,p); b[tot++]=p; &#125; return Chinese_Remainder(a,b,tot);&#125; $n!$ 中 $p$ (素数) 的幂次 v_p(n!)=\sum_{i=1}^{\infty}\lfloor\frac n {p^i}\rfloor 库默尔定理 设 $m,n(\ge0)$，$p$ 为素数，则 $v_p(C_{m+n}^m)$ 等于在 $p$ 进制下 $m+n$ 时进位次数。 连分数 \Huge a_0+\frac 1 {a_1+\frac 1{a_2+\frac 1 {\cdots+\frac 1 {a_n}}}}记为 [a_0,a_1,\cdots,a_n]=\frac {p_n}{q_n}\\ p_0=a_0,p_1=a_1a_0+1,p_k=a_kp_{k-1}+p_{k-2}\ (2\le k\le n)\\ q_0=1,q_1=a_1,q_k=a_kq_{k-1}+q_{k-2}\ (2\le k\le n)\\ p_nq_{n-1}-p_{n-1}q_n=(-1)^{n-1}\ (n\ge1)佩尔方程$x^2-dy^2=1$ 定理1: 对于正整数 p,q ,如果有 |p^2-a^2q^2|]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Others]]></title>
    <url>%2F2019%2F08%2F17%2FOthers%2F</url>
    <content type="text"><![CDATA[快速排序1234567891011121314151617void quick_sort(int l,int r,int m[])&#123; int i=l,j=r,temp=m[l]; if (l&gt;r) return; while (i!=j) &#123; while (m[j]&gt;=temp&amp;&amp;i&lt;j) j--; while (m[i]&lt;=temp&amp;&amp;i&lt;j) i++; if (i&lt;j)&#123; int k=m[j]; m[j]=m[i]; m[i]=k; &#125; &#125; m[l]=m[i]; m[i]=temp; quick_sort(l,i-1,m); quick_sort(i+1,r,m);&#125; 分数123456789101112131415161718192021222324252627282930313233343536struct fraction&#123; ll son, mom; fraction()&#123;&#125; fraction(ll a,ll b)&#123; if(a)&#123;ll gc=gcd(abs(a),abs(b));if(b&lt;0) son=-a/gc,mom=-b/gc;else son=a/gc,mom=b/gc;&#125; else son=0,mom=1; &#125; bool operator==(const fraction &amp;x)const&#123; return son==x.son&amp;&amp;mom==x.mom; &#125; bool operator!=(const fraction &amp;x)const&#123; return !(son==x.son&amp;&amp;mom==x.mom); &#125; bool operator&lt;(const fraction &amp;y)const&#123; return son * y.mom &lt; y.son * mom; &#125; bool operator&lt;=(const fraction &amp;y)const&#123; return son * y.mom &lt;= y.son * mom; &#125; fraction operator*(const fraction &amp;y)const&#123; return fraction(son*y.son,mom*y.mom); &#125; fraction operator+(const fraction &amp;y)const&#123; return fraction(son * y.mom + y.son * mom,mom*y.mom); &#125; fraction operator/(const fraction &amp;y)const&#123; return fraction(son*y.mom,mom*y.son); &#125; fraction operator-(const fraction &amp;y)const&#123; return fraction(son * y.mom - y.son * mom,mom*y.mom); &#125; void display()&#123; if(mom==1)printf("%lld\n",son); else printf("%lld/%lld\n",son,mom); &#125;&#125;; 蔡勒公式求星期 1234int week(int y,int m,int d)&#123; if(m==1||m==2) m+=12,y=y-1; return (d+2*m+3*(m+1)/5+y+y/4-y/100+y/400+1)%7;&#125; 曼哈顿距离和切比雪夫距离曼哈顿距离$\large dis_m=|x1-x2|+|y1-y2|$ 切比雪夫距离$\large dis_q=max(|x1-x2|,|y1-y2|)$ 转换 将坐标 $(x,y)\to(x+y,x-y)$ ，原坐标的 $dis_m$ 等于新坐标的 $dis_q$ 将坐标 $(x,y)\to(\frac {x+y}2,\frac {x-y}2)$ ，原坐标的 $dis_q$ 等于新坐标的 $dis_m$ 位运算 按位与运算符（&amp;） 运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1; x &amp; (x - 1)1.用于消去x最后一位的12.检查n是否为2的幂次3.计算在一个 32 位的整数的二进制表式中有多少个 14.如果要将整数A转换为B，需要改变多少个bit位：对A^B进行操作 Lowbit(x) 12x&amp;(-x) x&amp;(x^(x-1)) 枚举所有集合的子集 12345for (int S=1,len=1&lt;&lt;n; S&lt;len; S++)&#123; for (int T=(S-1)&amp;S; T ; T=(T-1)&amp;S)&#123; //枚举S的所有非空真子集 //do something. &#125;&#125; 按位或运算符（|） 运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1 异或运算符（$\text{^}$） 运算规则：$\text{0^0=0； 0^1=1； 1^0=1； 1^1=0；}$ 性质：1.交换律2.结合律 $\text{即(a^b)^c == a^(b^c)}$3.对于任何数 x，都有 $\text{x^x=0，x^0=x}$4.自反性: $\text{a^b^b=a^0=a;}$ $\text{a ^ b ^ b = a}$数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数 读入挂 整数 1234567891011121314151617inline void read(ll &amp;x) &#123; ll f=1; x=0; char ch=getchar(); for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1; for(;isdigit(ch);ch=getchar())x=x*10+ch-'0'; x*=f;&#125;inline void write(ll x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt;= 10)write(x / 10); putchar(x % 10 + '0'); &#125; 实数 1234567891011121314151617181920212223242526272829303132inline bool scan_lf(double &amp;num) &#123; char in; double Dec = 0.1; bool IsN = false, IsD = false; in = getchar(); if (in == EOF) return false; while (in != '-' &amp;&amp; in != '.' &amp;&amp; (in &lt; '0' || in &gt; '9')) in = getchar(); if (in == '-') &#123; IsN = true; num = 0; &#125; else if (in == '.') &#123; IsD = true; num = 0; &#125; else num = in - '0'; if (!IsD) &#123; while (in = getchar(), in &gt;= '0' &amp;&amp; in &lt;= '9') &#123; num *= 10; num += in - '0'; &#125; &#125; if (in != '.') &#123; if (IsN) num = -num; return true; &#125; else &#123; while (in = getchar(), in &gt;= '0' &amp;&amp; in &lt;= '9') &#123; num += Dec * (in - '0'); Dec *= 0.1; &#125; &#125; if (IsN) num = -num; return true;&#125; binary search123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//求最小的i，使得a[i] = key，若不存在，则返回-1int Equal_Min(int a[], int n, int key) &#123; int m, l = 0, r = n - 1; //闭区间[0, n - 1] while (l &lt; r) &#123; m = l + ((r - l) &gt;&gt; 1); if (a[m] &gt;= key)r = m - 1; else l = m + 1; &#125; return (m &lt; n) &amp;&amp; (a[m] == key) ? m : -1;&#125;//求最大的i，使得a[i] = key，若不存在，则返回-1int Equal_Max(int a[], int n, int key) &#123; int m, l = 0, r = n - 1; //闭区间[0, n - 1] while (l &lt; r) &#123; m = l + ((r - l) &gt;&gt; 1); if (a[m] &gt; key)r = m - 1; else l = m + 1; &#125; return (l - 1 &gt;= 0 &amp;&amp; (a[l - 1] == key)) ? l - 1 : -1;&#125;//求最小的i，使得a[i] &gt; key，若不存在，则返回-1int Grater(int a[], int n, int key) &#123; int m, l = 0, r = n - 1; //闭区间[0, n - 1] while (l &lt;= r) &#123; m = l + ((r - l) &gt;&gt; 1); if (a[m] &gt; key) r = m - 1; else l = m + 1; &#125; return l &lt; n ? l : -1;&#125;//求最小的i，使得a[i] &gt;= key，若不存在，则返回-1int Grater_Equal(int a[], int n, int key) &#123; int m, l = 0, r = n - 1; //闭区间[0, n - 1] while (l &lt;= r) &#123; m = l + ((r - l) &gt;&gt; 1); if (a[m] &gt;= key) r = m - 1; else l = m + 1; &#125; return l &lt; n ? l : -1;&#125;//求最大的i，使得a[i] &lt; key，若不存在，则返回-1int Smaller(int a[], int n, int key) &#123; int m, l = 0, r = n - 1; //闭区间[0, n - 1] while (l &lt;= r) &#123; m = l + ((r - l) &gt;&gt; 1); if (a[m] &gt;= key) r = m - 1; else l = m + 1; &#125; return l &gt; 0 ? l - 1 : -1;&#125;//求最大的i，使得a[i] &lt;= key，若不存在，则返回-1int Equal_Smaller(int a[], int n, int key) &#123; int m, l = 0, r = n - 1; //闭区间[0, n - 1] while (l &lt;= r) &#123; m = l + ((r - l) &gt;&gt; 1); if (a[m] &gt; key) r = m - 1; else l = m + 1; &#125; return l &gt; 0 ? l - 1 : -1;&#125; 线性递推式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#define SZ(x) ((ll)(x).size())typedef vector&lt;ll&gt; VI;typedef pair&lt;ll,ll&gt; PII;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;namespace linear_seq &#123; const long long N = 10010; ll res[N], base[N], _c[N], _md[N]; VI Md; void mul(ll *a, ll *b, long long k) &#123; for0(i, k + k) _c[i] = 0; for0(i, k) if (a[i]) for0(j, k) _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod; for (long long i = k + k - 1; i &gt;= k; i--) if (_c[i]) for0(j, SZ(Md)) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod; for0(i, k) a[i] = _c[i]; &#125; long long solve(ll n, VI a, VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+... ll ans = 0, pnt = 0; long long k = SZ(a); assert(SZ(a) == SZ(b)); for0(i, k) _md[k - 1 - i] = -a[i]; _md[k] = 1; Md.clear(); for0(i, k) if (_md[i] != 0) Md.push_back(i); for0(i, k) res[i] = base[i] = 0; res[0] = 1; while ((1ll &lt;&lt; pnt) &lt;= n) pnt++; for (long long p = pnt; p &gt;= 0; p--) &#123; mul(res, res, k); if ((n &gt;&gt; p) &amp; 1) &#123; for (long long i = k - 1; i &gt;= 0; i--) res[i + 1] = res[i]; res[0] = 0; for0(j, SZ(Md)) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod; &#125; &#125; for0(i, k) ans = (ans + res[i] * b[i]) % mod; if (ans &lt; 0) ans += mod; return ans; &#125; VI BM(VI s) &#123; VI C(1, 1), B(1, 1); long long L = 0, m = 1, b = 1; for0(n, SZ(s)) &#123; ll d = 0; for0(i, L + 1) d = (d + (ll)C[i] * s[n - i]) % mod; if (d == 0) ++m; else if (2 * L &lt;= n) &#123; VI T = C; ll c = mod - d * powmod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); for0(i, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; L = n + 1 - L; B = T; b = d; m = 1; &#125; else &#123; ll c = mod - d * powmod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); for0(i, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; ++m; &#125; &#125; return C; &#125; ll gao(VI a, ll n) &#123; VI c = BM(a); c.erase(c.begin()); for0(i, SZ(c)) c[i] = (mod - c[i]) % mod; return solve(n, c, VI(a.begin(), a.begin() + SZ(c))); &#125;&#125;; // namespace linear_seq//2struct LinearRecurrence &#123; using vec = vector&lt;LL&gt;; static void extand(vec &amp;a, LL d, LL value = 0) &#123; if (d &lt;= a.size()) return; a.resize(d, value); &#125; static vec BerlekampMassey(const vec &amp;s, LL mod) &#123; std::function&lt;LL(LL)&gt; inverse = [&amp;](LL a) &#123; return a == 1 ? 1 : (LL) (mod - mod / a) * inverse(mod % a) % mod; &#125;; vec A = &#123;1&#125;, B = &#123;1&#125;; LL b = s[0]; for (size_t i = 1, m = 1; i &lt; s.size(); ++i, m++) &#123; LL d = 0; for (size_t j = 0; j &lt; A.size(); ++j) &#123; d += A[j] * s[i - j] % mod; &#125; if (!(d %= mod)) continue; if (2 * (A.size() - 1) &lt;= i) &#123; auto temp = A; extand(A, B.size() + m); LL coef = d * inverse(b) % mod; for (size_t j = 0; j &lt; B.size(); ++j) &#123; A[j + m] -= coef * B[j] % mod; if (A[j + m] &lt; 0) A[j + m] += mod; &#125; B = temp, b = d, m = 0; &#125; else &#123; extand(A, B.size() + m); LL coef = d * inverse(b) % mod; for (size_t j = 0; j &lt; B.size(); ++j) &#123; A[j + m] -= coef * B[j] % mod; if (A[j + m] &lt; 0) A[j + m] += mod; &#125; &#125; &#125; return A; &#125; static void exgcd(LL a, LL b, LL &amp;g, LL &amp;x, LL &amp;y) &#123; if (!b) x = 1, y = 0, g = a; else &#123; exgcd(b, a % b, g, y, x); y -= x * (a / b); &#125; &#125; static LL crt(const vec &amp;c, const vec &amp;m) &#123; LL n = c.size(); LL M = 1, ans = 0; for (LL i = 0; i &lt; n; ++i) M *= m[i]; for (LL i = 0; i &lt; n; ++i) &#123; LL x, y, g, tm = M / m[i]; exgcd(tm, m[i], g, x, y); ans = (ans + tm * x * c[i] % M) % M; &#125; return (ans + M) % M; &#125; static vec ReedsSloane(const vec &amp;s, LL mod) &#123; auto inverse = [](LL a, LL m) &#123; LL d, x, y; exgcd(a, m, d, x, y); return d == 1 ? (x % m + m) % m : -1; &#125;; auto L = [](const vec &amp;a, const vec &amp;b) &#123; LL da = (a.size() &gt; 1 || (a.size() == 1 &amp;&amp; a[0])) ? (LL) a.size() - 1 : -1000; LL db = (b.size() &gt; 1 || (b.size() == 1 &amp;&amp; b[0])) ? (LL) b.size() - 1 : -1000; return max(da, db + 1); &#125;; auto prime_power = [&amp;](const vec &amp;s, LL mod, LL p, LL e) &#123; // linear feedback shift register mod p^e, p is prime vector&lt;vec&gt; a(e), b(e), an(e), bn(e), ao(e), bo(e); vec t(e), u(e), r(e), to(e, 1), uo(e), pw(e + 1);; pw[0] = 1; for (LL i = pw[0] = 1; i &lt;= e; ++i) pw[i] = pw[i - 1] * p; for (LL i = 0; i &lt; e; ++i) &#123; a[i] = &#123;pw[i]&#125;, an[i] = &#123;pw[i]&#125;; b[i] = &#123;0&#125;, bn[i] = &#123;s[0] * pw[i] % mod&#125;; t[i] = s[0] * pw[i] % mod; if (t[i] == 0) &#123; t[i] = 1, u[i] = e; &#125; else &#123; for (u[i] = 0; t[i] % p == 0; t[i] /= p, ++u[i]); &#125; &#125; for (LL k = 1; k &lt; s.size(); ++k) &#123; for (LL g = 0; g &lt; e; ++g) &#123; if (L(an[g], bn[g]) &gt; L(a[g], b[g])) &#123; ao[g] = a[e - 1 - u[g]]; bo[g] = b[e - 1 - u[g]]; to[g] = t[e - 1 - u[g]]; uo[g] = u[e - 1 - u[g]]; r[g] = k - 1; &#125; &#125; a = an, b = bn; for (LL o = 0; o &lt; e; ++o) &#123; LL d = 0; for (LL i = 0; i &lt; a[o].size() &amp;&amp; i &lt;= k; ++i) &#123; d = (d + a[o][i] * s[k - i]) % mod; &#125; if (d == 0) &#123; t[o] = 1, u[o] = e; &#125; else &#123; for (u[o] = 0, t[o] = d; t[o] % p == 0; t[o] /= p, ++u[o]); LL g = e - 1 - u[o]; if (L(a[g], b[g]) == 0) &#123; extand(bn[o], k + 1); bn[o][k] = (bn[o][k] + d) % mod; &#125; else &#123; LL coef = t[o] * inverse(to[g], mod) % mod * pw[u[o] - uo[g]] % mod; LL m = k - r[g]; extand(an[o], ao[g].size() + m); extand(bn[o], bo[g].size() + m); for (LL i = 0; i &lt; ao[g].size(); ++i) &#123; an[o][i + m] -= coef * ao[g][i] % mod; if (an[o][i + m] &lt; 0) an[o][i + m] += mod; &#125; while (an[o].size() &amp;&amp; an[o].back() == 0) an[o].pop_back(); for (LL i = 0; i &lt; bo[g].size(); ++i) &#123; bn[o][i + m] -= coef * bo[g][i] % mod; if (bn[o][i + m] &lt; 0) bn[o][i + m] -= mod; &#125; while (bn[o].size() &amp;&amp; bn[o].back() == 0) bn[o].pop_back(); &#125; &#125; &#125; &#125; return make_pair(an[0], bn[0]); &#125;; vector&lt;tuple&lt;LL, LL, LL&gt;&gt; fac; for (LL i = 2; i * i &lt;= mod; ++i) if (mod % i == 0) &#123; LL cnt = 0, pw = 1; while (mod % i == 0) mod /= i, ++cnt, pw *= i; fac.emplace_back(pw, i, cnt); &#125; if (mod &gt; 1) fac.emplace_back(mod, mod, 1); vector&lt;vec&gt; as; LL n = 0; for (auto &amp;&amp;x: fac) &#123; LL mod, p, e; vec a, b; tie(mod, p, e) = x; auto ss = s; for (auto &amp;&amp;x: ss) x %= mod; tie(a, b) = prime_power(ss, mod, p, e); as.emplace_back(a); n = max(n, (LL) a.size()); &#125; vec a(n), c(as.size()), m(as.size()); for (LL i = 0; i &lt; n; ++i) &#123; for (LL j = 0; j &lt; as.size(); ++j) &#123; m[j] = get&lt;0&gt;(fac[j]); c[j] = i &lt; as[j].size() ? as[j][i] : 0; &#125; a[i] = crt(c, m); &#125; return a; &#125; LinearRecurrence(const vec &amp;s, const vec &amp;c, LL mod) : init(s), trans(c), mod(mod), m(s.size()) &#123;&#125; LinearRecurrence(const vec &amp;s, LL mod, bool is_prime = true) : mod(mod) &#123; vec A; if (is_prime) A = BerlekampMassey(s, mod); else A = ReedsSloane(s, mod); if (A.empty()) A = &#123;0&#125;; m = A.size() - 1; trans.resize(m); for (LL i = 0; i &lt; m; ++i) &#123; trans[i] = (mod - A[i + 1]) % mod; &#125; reverse(trans.begin(), trans.end()); init = &#123;s.begin(), s.begin() + m&#125;; &#125; LL calc(LL n) &#123; if (mod == 1) return 0; if (n &lt; m) return init[n]; vec v(m), u(m &lt;&lt; 1); LL msk = !!n; for (LL m = n; m &gt; 1; m &gt;&gt;= 1LL) msk &lt;&lt;= 1LL; v[0] = 1 % mod; for (LL x = 0; msk; msk &gt;&gt;= 1LL, x &lt;&lt;= 1LL) &#123; fill_n(u.begin(), m * 2, 0); x |= !!(n &amp; msk); if (x &lt; m) u[x] = 1 % mod; else &#123; // can be optimized by fft/ntt for (LL i = 0; i &lt; m; ++i) &#123; for (LL j = 0, t = i + (x &amp; 1); j &lt; m; ++j, ++t) &#123; u[t] = (u[t] + v[i] * v[j]) % mod; &#125; &#125; for (LL i = m * 2 - 1; i &gt;= m; --i) &#123; for (LL j = 0, t = i - m; j &lt; m; ++j, ++t) &#123; u[t] = (u[t] + trans[j] * u[i]) % mod; &#125; &#125; &#125; v = &#123;u.begin(), u.begin() + m&#125;; &#125; LL ret = 0; for (LL i = 0; i &lt; m; ++i) &#123; ret = (ret + v[i] * init[i]) % mod; &#125; return ret; &#125; vec init, trans; LL mod; LL m;&#125;; 归并排序12345678910111213141516void merge_core(int arr[], int begin, int mid, int end)&#123;//将两个有序数组合并成一个 int i=begin, j=mid, k=0; int *tmp = (int*)malloc(sizeof(int)*(end-begin)); for(; i&lt;mid &amp;&amp; j&lt;end; tmp[k++]=(arr[i]&lt;arr[j]?arr[i++]:arr[j++])); for(; i&lt;mid; tmp[k++]=arr[i++]); for(; j&lt;end; tmp[k++]=arr[j++]); for(i=begin, k=0; i&lt;end; arr[i++]=tmp[k++]); free(tmp);&#125;void merge_sort(int arr[], int begin, int end)&#123; if (end-begin &lt; 2) return; int mid = (begin+end)&gt;&gt;1; merge_sort(arr,begin,mid); merge_sort(arr,mid,end); merge_core(arr,begin,mid,end);&#125; 利用归并排序求逆序对 123456789101112131415int tmpA[100005], cnt = 0;void merge_sort(int l, int r, int *A) &#123; if (l &gt;= r) return ; int mid = (l + r) &gt;&gt; 1; merge_sort(l, mid, A); merge_sort(mid + 1, r, A); int pl = l, pr = mid + 1, tmpp = 0; while(pl &lt;= mid &amp;&amp; pr &lt;= r) &#123; if (A[pl] &lt;= A[pr]) tmpA[tmpp++] = A[pl++]; else tmpA[tmpp++] = A[pr++], cnt += mid - pl + 1; &#125; while(pl &lt;= mid) tmpA[tmpp++] = A[pl++]; while(pr &lt;= r) tmpA[tmpp++] = A[pr++]; for (int i = 0; i &lt; tmpp; i++) A[i + l] = tmpA[i];&#125; hash_table123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int seed = N;int tot, First[seed], Next[N], Val[N], Key[N];void init() &#123; tot = 0; mem0(First);&#125;void Insert(int key, int val) &#123; int u = val % seed; for (int v = First[u]; v; v = Next[v]) if (Val[v] == val &amp;&amp; Key[v] &lt; key) &#123; Key[v] = key; return; &#125; Next[++tot] = First[u]; First[u] = tot; Val[tot] = val; Key[tot] = key;&#125;int Find(int val) &#123; int u = val % seed; for (int v = First[u]; v; v = Next[v])if (Val[v] == val) return Key[v]; return -1;&#125;unsigned int ELFhash(char *str) &#123; unsigned int hash = 0, x = 0; while (*str) &#123; hash = (hash &lt;&lt; 4) + *str; if ((x = hash &amp; 0xf0000000) != 0) &#123; hash ^= (x &gt;&gt; 24); hash &amp;= ~x; &#125; str++; &#125; return (hash &amp; 0x7fffffff);&#125;unsigned int ELFhash(string str) &#123; unsigned int hash = 0,x = 0; for0(i, str.size()) &#123; hash = (hash &lt;&lt; 4) + str[i]; if ((x = hash &amp; 0xf0000000) != 0) &#123; hash ^= (x &gt;&gt; 24); hash &amp;= ~x; &#125; &#125; return (hash &amp; 0x7fffffff);&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F2019%2F08%2F17%2FString%2F</url>
    <content type="text"><![CDATA[最长公共子串$dp[i][j]$表示前 $i$ 个 $a$ 和前 $j$ 个 $b$ 组成的最长公共子串长度 dp[i][j]=\left\{\begin{array}{c} 0&i=0||j=0\\ dp[i-1][j-1]+1&a[i]=b[j]\\ 0&a[i]\ne b[j] \end{array}\right.最长公共子序列$dp[i][j]$表示的前 $i$ 个 $a$ 和前 $j$ 个 $b$ 组成最长公共子序列长度 dp[i][j]=\left\{ \begin{array}{c} 0&i=0||j=0\\ dp[i-1][j-1]+1&a[i]=b[j]\\ max(dp[i][j-1],dp[i-1][j])&a[i]\ne b[j] \end{array} \right.最长上升公共子序列$dp[i][j]$ 表示前 $i$ 个 $a$ 和前 $j$ 个 $b$ 组成的以 $b[j]$ 结尾的最长上升子公共子序列长度 dp[i][j]=\left\{ \begin{array}{c} dp[i-1][j]&a[i]\ne b[j]\\ max(dp[i-1][k])(1\le k< j\ \&\&\ b[j]>b[k])&a[i]= b[j] \end{array} \right.最长回文子序列 LPS[i,j]=\left\{\begin{array}{c} 2+LPS[i+1,j-1]&S_i=S_j\\ max(LPS[i,j-1],LPS[i+1,j])&S_i\ne S_j \end{array}\right.最长回文子串 Manacher 算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950char s[N];int Manacher(char *s, int len) &#123; char Ma[2 * N + 10]; int l = 0, ans = 0, Mp[2 * N + 10]; Ma[l++] = '$'; Ma[l++] = '#'; for (int i = 0; i &lt; len; i++) &#123; Ma[l++] = s[i]; Ma[l++] = '#'; &#125; Ma[l] = 0; int mx = 0, id = 0; for (int i = 1; i &lt; l; i++) &#123; Mp[i] = mx &gt; i ? min(Mp[2 * id - i], mx - i) : 1; while (Ma[i + Mp[i]] == Ma[i - Mp[i]]) Mp[i]++; if (i + Mp[i] &gt; mx) &#123; mx = i + Mp[i]; id = i; &#125; &#125; for0(i, 2 * len + 2) ans = max(ans, Mp[i] - 1); return ans;&#125;int Manacher(char *s, int len) &#123;//s 从1开始 int ans = 0, r[N]; int R = 0, id = 0; for (int i = 1; i &lt;=len; i++) &#123; r[i] = R&gt;i ? min(r[2 * id - i], R - i):0; //r[i] 表示以 i 为中心的回文串半径（不包括 i ） while (i+r[i]+1&lt;=len&amp;&amp;s[i - r[i] - 1]==s[i + r[i] + 1] ) r[i]++; if (i + r[i] &gt; R) &#123; R = i + r[i]; id = i; &#125; ans=max(ans,2*r[i]+1); &#125; id=R=0; for(int i=2;i&lt;=len;i++)&#123; r[i] = R&gt;i ? min(r[2 * id - i], R - i + 1):0;//r[i] 表示以 i-1 和 i 为中心的回文串半径 while (i+r[i]&lt;=len&amp;&amp;s[i - r[i] - 1]==s[i + r[i]])&#123; r[i]++; &#125; if (i + r[i]-1 &gt; R) &#123; R = i + r[i]-1; id = i; &#125; ans=max(ans,2*r[i]); &#125; return ans;&#125; 回文自动机功能： 求串 S 前缀 0~i 内本质不同回文串的个数（两个串长度不同或者长度相同且至少有一个字符不同便是本质不同） 求串 S 内每一个本质不同回文串出现的次数 求串 S 内回文串的个数（其实就是1和2结合起来） 求以下标 i 结尾的回文串的个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int C = 26;struct Palindromic_Tree &#123; int next[N][C] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[N] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[N] ;//cnt[i]表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的） int num[N] ;//num[i]表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数。 int len[N] ;//len[i]表示节点i表示的回文串的长度 int S[N] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int newnode ( int l ) &#123;//新建节点 for ( int i = 0 ; i &lt; C ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125; PAM; 字符串哈希123456789101112131415161718192021222324252627ull P = 1313131;ull sqr[N/2],has[N/2],V[N];int Laxt[N],Next[N],cnt=0;const int MOD = 2e6+7;bool _insert(ull Now)&#123; int u=Now%MOD; for(int i=Laxt[u];i;i=Next[i])&#123; if(V[i]==Now) return 0; &#125; Next[++cnt]=Laxt[u]; Laxt[u]=cnt; V[cnt]=Now; return 1;&#125;int ans=0;void _hash(int x,int y)&#123; ull Now=has[y]-has[x-1]*sqr[y-x+1];//求s[x]···s[y]的hash值 if(_insert(Now)) ++ans;&#125;void init(char *s,int Len)&#123;//s 从1开始 sqr[0]=1; for(int i=1;i&lt;=Len;i++)&#123; sqr[i]=sqr[i-1]*P; has[i]=has[i-1]*P+s[i]; &#125;&#125; 序列自动机$nxt[i][j]$ 表示在原串 $s$ (从 $1$ 开始) 第 $i$ 位后面的第一个 $j$ 出现的位置，设串长为 $n$ ,字符集大小为 $a$，预处理时间复杂度为 $O(n*a)$ 1234for(int i=n;i;i--)&#123; for(int j=1;j&lt;=a;j++) nxt[i-1][j]=nxt[i][j]; nxt[i-1][s[i]-'a']=i;&#125; 求子序列个数 1234567int dfs(int x)&#123; if(f[x]) return f[x]; for(r int i=1;i&lt;=a;i++) if(next[x][i]) f[x]+=dfs(next[x][i]); return ++f[x];&#125;//调用：dfs(0); 求回文子序列或两个串的公共子序列个数等 1234567int dfs(int x,int y)&#123;//表示目前字符是串1的第x位，串2的第y位 if(f[x][y]) return f[x][y]; for(r int i=1;i&lt;=a;i++) if(next1[x][i]&amp;&amp;next2[y][i]) f[x][y]+=dfs(next1[x][i],next2[y][i]); return ++f[x][y];&#125;//调用：dfs(0,0); 求一个串的回文子序列个数 对原串和反串构造 $next$ 数组, 然后 $dfs$ , 对回文分奇偶, $dfs$ 过程中应该保证 $x+y&lt;=n+1$ , 若 $x+y=n+1$ 为奇串, 否则为偶串. $dfs $ 到一个偶串时，可能会有奇串被漏掉(如自动机只能找到 $abba$，却忽略了 $aba$) 因此，我们考虑手动加上被忽略的奇串，同时注意已经找到的奇串不能再加一次（如 $ababa$），只要特判一下就可以了，代码如下。 1234567891011int dfs(int x,int y)&#123; if(f[x][y]) return f[x][y];//记忆化 for(int i=1;i&lt;=26;i++) if(next1[x][i]&amp;&amp;next2[y][i])&#123; if(next1[x][i]+next2[y][i]&gt;n+1) continue;//x+y&gt;n+1,状态不合法,不进行统计 if(next1[x][i]+next2[y][i]&lt;n+1) f[x][y]++; //满足x+y=n+1的奇串不会被漏掉,其他奇串需要特别统计 f[x][y]=(f[x][y]+dfs(next1[x][i],next2[y][i]))%mod; &#125; return ++f[x][y];&#125; 给定三个串 $A,B.C$, 求一个最长的 $A,B$ 的公共子序列 $S$, 要求 $C$ 是 $S$ 的子序列 再加一个参数 $z$ 表示当前字符是 $C$ 的第 $z$ 位, 但这么做显然是错的，因为匹配过程中 $C$ 的某些字符可能会被跳过, 所以需要对 $next$ 做一些修改 12345for(int i=1;i&lt;=26;i++) nextc[n][i]=n;//字符集为26个字母,C长度为nfor(int i=0;i&lt;n;i++)&#123; for(r int j=1;j&lt;=26;j++) nextc[i][j]=i; nextc[i][c[i+1]]=i+1;&#125; KMP12345678910111213141516171819202122int Next[N];// Next[i] 为满足 p[i-z,...,i-1]=p[0,...,z-1] 的最大 z 值(就是 p 的自身匹配)void kmp_pre(char *p, int p_len,int Next[]) &#123; int i = 0, j = Next[0] = -1; while (i &lt; p_len) &#123; while (j != -1 &amp;&amp; p[i] != p[j]) j = Next[j]; Next[++i] = ++j; &#125;&#125;int KMP(char *p, char *s) &#123; // p 是模式串，s 是主串 int ans = 0, i = 0, j = 0, p_len = strlen(p), s_len = strlen(s); kmp_pre(p, p_len, Next); while (i &lt; s_len) &#123; while (-1 != j &amp;&amp; s[i] != p[j]) j = Next[j]; i++; j++; if (j &gt;= p_len) &#123; ans++; j = Next[j]; &#125; &#125; return ans;&#125; 扩展KMP12345678910111213141516171819202122232425262728293031323334353637int Extend[N], Next[N];void GetNext(string S) &#123; // Next[i] 为满足 S[i,...,i+z-1]=S[0,...,z-1] 的最大 z 值,即S[i]...S[s_len-1]与S的最长公共前缀长度 int s_len = (int)S.size(), a = 0, p = 0; Next[0] = s_len; for (int i = 1, j = -1; i &lt; s_len; i++, j--) &#123; if (j &lt; 0 || i + Next[i - a] &gt;= p) &#123; if (j &lt; 0) &#123; p = i; j = 0; &#125; while (p &lt; s_len &amp;&amp; S[p] == S[j]) &#123; p++; j++; &#125; Next[i] = j; a = i; &#125; else Next[i] = Next[i - a]; &#125;&#125;void exKMP(string P, string S) &#123; // P[i]...P[p_len-1]与S的最长公共前缀的长度 GetNext(S); int a = 0, p = 0, p_len = (int)P.size(), s_len = (int)S.size(); //记录匹配成功的字符的最远位置p，及起始位置a for (int i = 0, j = -1; i &lt; p_len; i++,j--) &#123; // j即等于p与i的距离，其作用是判断i是否大于p（如果j&lt;0，则i大于p） if (j &lt; 0 || i + Next[i - a] &gt;= p) &#123; if (j &lt; 0) &#123; p = i; j = 0; &#125; while (p &lt; p_len &amp;&amp; j &lt; s_len &amp;&amp; P[p] == S[j]) &#123; p++; j++; &#125; Extend[i] = j; a = i; &#125; else Extend[i] = Next[i - a]; &#125;&#125; 字典树 数组实现 1234567891011121314151617181920212223int ch[N][30], tot, val[N];void Insert(char *s) &#123; int root = 0, len = (int)strlen(s); for0(i, len) &#123; int c = s[i] - 'a'; if (!ch[root][c]) &#123; mem0(ch[tot + 1]); //使用的时候才用memset开辟空间可以减低空间复杂度 ch[root][c] = ++tot; &#125; root = ch[root][c]; val[root]++; &#125;&#125;int Query(char *s) &#123; int root = 0; int len = (int)strlen(s); for0(i, len) &#123; int c = s[i] - 'a'; if (!ch[root][c]) return 0; root = ch[root][c]; &#125; return val[root];&#125; 指针实现 12345678910111213141516171819202122232425262728293031323334353637const int MAX = 26;struct Trie &#123; Trie *Next[MAX]; int count; Trie() &#123; count = 1; memset(Next, NULL, sizeof(Next)); &#125;&#125; * root;void Insert(string s) &#123; Trie *tmpRoot = root, *tmp; for0(i, s.size()) &#123; if (tmpRoot-&gt;Next[s[i] - 'a'] == NULL) &#123; tmp = new Trie; tmpRoot-&gt;Next[s[i] - 'a'] = tmp; tmpRoot = tmp; &#125; else &#123; tmpRoot = tmpRoot-&gt;Next[s[i] - 'a']; tmpRoot-&gt;count++; &#125; &#125;&#125;int Query(string s) &#123; Trie *tmpRoot = root; for0(i, s.size()) &#123; if (tmpRoot-&gt;Next[s[i] - 'a'] == NULL) return 0; tmpRoot = tmpRoot-&gt;Next[s[i] - 'a']; &#125; return tmpRoot-&gt;count;&#125;void Free(Trie *T) &#123; if (T == NULL) return; for (int i = 0; i &lt; MAX; ++i) &#123; if (T-&gt;Next[i]) Free(T-&gt;Next[i]); &#125; delete (T);&#125; AC自动机多模匹配算法，多个模式串，在文本串中找出拥有的模式串数，求 $fail$ : 直接与根节点相连的节点来说，如果这些节点失配，他们的Fail指针直接指向root即可;假设当前节点为father，其孩子节点记为child。求child的Fail指针时，首先我们要找到其father的Fail指针所指向的节点,假如是t的话，我们就要看t的孩子中有没有和child节点所表示的字母相同的节点，如果有的话，这个节点就是child的fail指针，如果发现没有，则需要找father-&gt;fail-&gt;fail这个节点，然后重复上面过程，如果一直找都找不到，则child的Fail指针就要指向root。 数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Trie &#123; int next[N][26], fail[N], end[N], root, L; // N的范围为所有pattern的字符数 int newnode() &#123; for (int i = 0; i &lt; 26; i++) next[L][i] = -1; end[L++] = 0; return L - 1; &#125; void init() &#123; L = 0; root = newnode(); &#125; void insert(char buf[]) &#123; int len = (int)strlen(buf), now = root; for (int i = 0; i &lt; len; i++) &#123; if (next[now][buf[i] - 'a'] == -1)next[now][buf[i] - 'a'] = newnode(); now = next[now][buf[i] - 'a']; &#125; end[now]++; &#125; void build() &#123; queue&lt;int&gt; Q; fail[root] = root; for (int i = 0; i &lt; 26; i++) &#123; if (next[root][i] == -1)next[root][i] = root; else &#123; fail[next[root][i]] = root; Q.push(next[root][i]); &#125; &#125; while (!Q.empty()) &#123; int now = Q.front(); Q.pop(); for (int i = 0; i &lt; 26; i++) &#123; if (next[now][i] == -1)next[now][i] = next[fail[now]][i]; else &#123; fail[next[now][i]] = next[fail[now]][i]; Q.push(next[now][i]); &#125; &#125; &#125; &#125; int query(char buf[]) &#123; int len = (int)strlen(buf), now = root, res = 0; for (int i = 0; i &lt; len; i++) &#123; now = next[now][buf[i] - 'a']; int temp = now; while (temp != root) &#123; res += end[temp]; end[temp] = 0; temp = fail[temp]; &#125; &#125; return res; &#125;&#125;;char *pattern, *str; 指针实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int MAX = 26;int tot;vii failTree[N];struct Node &#123; int id; Node *Next[MAX]; Node *Fail; //失配指针,类似next数组,最大的next是和自身比较,fail是和其它匹配串比较 Node() &#123; memset(Next, 0, sizeof(Next)); Fail = 0; id=tot++; &#125;&#125; * root;int Insert(char s[]) &#123; Node *p = root; int len=strlen(s); for(int i=0;i&lt; len;i++) &#123; int c = s[i] - 'a'; if (p-&gt;Next[c] == NULL) &#123; Node *newnode = new Node; p-&gt;Next[c] = newnode; p = newnode; &#125; else p = p-&gt;Next[c]; &#125; return p-&gt;id;&#125;void BuildFail() &#123; queue&lt;Node *&gt; que; root-&gt;Fail=root; for(int i=0;i&lt;26;i++)&#123; if(root-&gt;Next[i])&#123; root-&gt;Next[i]-&gt;Fail=root; que.push(root-&gt;Next[i]); &#125;else root-&gt;Next[i]=root; &#125; while (!que.empty()) &#123; Node *p = que.front(); que.pop(); failTree[p-&gt;Fail-&gt;id].pu_b(p-&gt;id); for(int i=0;i&lt;26;i++)&#123; if(p-&gt;Next[i])&#123; p-&gt;Next[i]-&gt;Fail=p-&gt;Fail-&gt;Next[i]; que.push(p-&gt;Next[i]); &#125;else p-&gt;Next[i]=p-&gt;Fail-&gt;Next[i]; &#125; &#125;&#125; 后缀数组 \large height[i]=\left\{ \begin{array}{l} 0&i=0\\ LCP(suffix(SA[i]),suffix(SA[i-1]))&i>0 \end{array}\right.倍增算法 $O(n*logn)$ 待排序数组长度为n, 放在[0,n-1]中，在最后面补一个0，需要保证每个元素大于零 srank[0,n-1]为有效值，srank[n]必定为0无效值,srank[i]保存Suffix(i)在所有后缀中从小到大排列的“名次”。 sa[1,n]为有效值，sa[0] 必定为n是无效值, sa[i]表示排名第i的起点为sa[i]; height[2,n]为有效值,suffix(sa[i-1])和suffix(sa[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀 123456789101112131415161718192021222324252627282930313233343536373839int t1[N],t2[N],c[N],srank[N],height[N],sa[N];bool cmp(int *r,int a,int b,int l)&#123; return r[a] == r[b] &amp;&amp; r[a+l] == r[b+l];&#125;void DA(int str[],int n,int m)&#123;//m为字符串中的最大值+1 n++; int i, j, p, *x = t1, *y = t2; //第一轮基数排序，如果s 的最大值很大，可改为快速排序 for(i = 0;i &lt; m;i++)c[i] = 0; for(i = 0;i &lt; n;i++)c[x[i] = str[i]]++; for(i = 1;i &lt; m;i++)c[i] += c[i-1]; for(i = n-1;i &gt;= 0;i--)sa[--c[x[i]]] = i; for(j = 1;j &lt;= n; j &lt;&lt;= 1)&#123; p = 0; //直接利用sa 数组排序第二关键字 for(i = n-j; i &lt; n; i++)y[p++] = i;//后面的j 个数第二关键字为空的最小 for(i = 0; i &lt; n; i++)if(sa[i] &gt;= j)y[p++] = sa[i] - j;//这样数组y保存的就是按照第二关键字排序的结果 //基数排序第一关键字 for(i = 0; i &lt; m; i++)c[i] = 0; for(i = 0; i &lt; n; i++)c[x[y[i]]]++; for(i = 1; i &lt; m;i++)c[i] += c[i-1]; for(i = n-1; i &gt;= 0;i--)sa[--c[x[y[i]]]] = y[i];//根据sa 和x 数组计算新的x 数组 swap(x,y); p = 1; x[sa[0]] = 0; for(i = 1;i &lt; n;i++)x[sa[i]] = cmp(y,sa[i-1],sa[i],j)?p-1:p++; if(p &gt;= n)break; m = p;//下次基数排序的最大值 &#125; int k = 0; n--; for(i = 0;i &lt;= n;i++)srank[sa[i]] = i; for(i = 0;i &lt; n;i++)&#123; if(k)k--; j = sa[srank[i]-1]; while(str[i+k] == str[j+k])k++; height[srank[i]] = k; &#125;&#125;int r[N]; DC3算法 $O(n)$ 所有的相关数组都要开三倍 待排序数组长度为n, 放在[0,n-1]中，在最后面补一个0 srank[0,n-1]为有效值，srank[n]必定为0无效值,srank[i]保存Suffix(i)在所有后缀中从小到大排列的“名次” sa[1,n]为有效值，sa[0] 必定为n是无效值, sa[i]表示排名第i的起点为sa[i]; height[2,n]为有效值,suffix(sa[i-1])和suffix(sa[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#define F(x) ((x)/3+((x)%3==1?0:tb))#define G(x) ((x)&lt;tb?(x)*3+1:((x)-tb)*3+2)int wa[N],wb[N],wv[N],wss[N],sa[N],srank[N],height[N];int c0(int *r,int a,int b)&#123; return r[a] == r[b] &amp;&amp; r[a+1] == r[b+1] &amp;&amp; r[a+2] == r[b+2];&#125;int c12(int k,int *r,int a,int b)&#123; if(k == 2) return r[a] &lt; r[b] || ( r[a] == r[b] &amp;&amp; c12(1,r,a+1,b+1) ); else return r[a] &lt; r[b] || ( r[a] == r[b] &amp;&amp; wv[a+1] &lt; wv[b+1]); &#125; void sort(int *r,int *a,int *b,int n,int m)&#123; int i; for(i = 0;i &lt; n;i++)wv[i] = r[a[i]]; for(i = 0;i &lt; m;i++)wss[i] = 0; for(i = 0;i &lt; n;i++)wss[wv[i]]++; for(i = 1;i &lt; m;i++)wss[i]+=wss[i-1]; for(i = n-1;i &gt;= 0;i--)b[--wss[wv[i]]] = a[i];&#125;void dc3(int *r,int *sa,int n,int m)&#123; int i, j, *rn = r + n; int *san = sa + n, ta = 0, tb = (n+1)/3, tbc = 0, p; r[n] = r[n+1] = 0; for(i = 0;i &lt; n;i++)if(i %3 != 0)wa[tbc++] = i; sort(r + 2, wa, wb, tbc, m); sort(r + 1, wb, wa, tbc, m); sort(r, wa, wb, tbc, m); for(p = 1, rn[F(wb[0])] = 0, i = 1;i &lt; tbc;i++)rn[F(wb[i])] = c0(r, wb[i-1], wb[i]) ? p - 1 : p++; if(p &lt; tbc)dc3(rn,san,tbc,p); else for(i = 0;i &lt; tbc;i++)san[rn[i]] = i; for(i = 0;i &lt; tbc;i++) if(san[i] &lt; tb)wb[ta++] = san[i] * 3; if(n % 3 == 1)wb[ta++] = n - 1; sort(r, wb, wa, ta, m); for(i = 0;i &lt; tbc;i++)wv[wb[i] = G(san[i])] = i; for(i = 0, j = 0, p = 0;i &lt; ta &amp;&amp; j &lt; tbc;p++)sa[p] = c12(wb[j] % 3, r, wa[i], wb[j]) ? wa[i++] : wb[j++]; for(;i &lt; ta;p++)sa[p] = wa[i++]; for(;j &lt; tbc;p++)sa[p] = wb[j++];&#125;void DA(int str[],int n,int m)&#123; for(int i = n;i &lt; n*3;i++)str[i] = 0; dc3(str, sa, n+1, m); int i,j,k = 0; for(i = 0;i &lt;= n;i++)srank[sa[i]] = i; for(i = 0;i &lt; n; i++)&#123; if(k) k--; j = sa[srank[i]-1]; while(str[i+k] == str[j+k]) k++; height[srank[i]] = k; &#125;&#125;string s;int r[N]; 应用 本质不同子串 \large\sum_{i=1}^n(n-sa[i]-height[i])=\frac{n*(n+1)}2-\sum_{i=2}^nheight[i] 后缀自动机模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int CHAR = 26;struct SAM_Node &#123; SAM_Node *fa, *next[CHAR]; int len; long long cnt; void clear() &#123; fa = 0; memset(next, 0, sizeof(next)); cnt = 0; &#125;&#125; pool[N * 2];SAM_Node *root, *tail;SAM_Node* newnode(int len) &#123; SAM_Node* cur = tail++; cur-&gt;clear(); cur-&gt;len = len; return cur;&#125;void SAM_init() &#123; tail = pool; root = newnode(0);&#125;SAM_Node* extend(SAM_Node* last, int x) &#123; SAM_Node *p = last, *np = newnode(p-&gt;len + 1); while (p &amp;&amp; !p-&gt;next[x]) p-&gt;next[x] = np, p = p-&gt;fa; if (!p) np-&gt;fa = root; else &#123; SAM_Node* q = p-&gt;next[x]; if (q-&gt;len == p-&gt;len + 1) np-&gt;fa = q; else &#123; SAM_Node* nq = newnode(p-&gt;len + 1); memcpy(nq-&gt;next, q-&gt;next, sizeof(q-&gt;next)); nq-&gt;fa = q-&gt;fa; q-&gt;fa = np-&gt;fa = nq; while (p &amp;&amp; p-&gt;next[x] == q) p-&gt;next[x] = nq, p = p-&gt;fa; &#125; &#125; return np;&#125;//2struct NODE&#123; int ch[26]; int len,fa; void newNode(int _len)&#123;memset(ch,0,sizeof(ch));len=_len;&#125;&#125;pool[N&lt;&lt;1];int las=1,tot=1;void init()&#123; las=tot=1; memset(pool[1].ch,0,sizeof(pool[1].ch)); pool[1].len=0;&#125;void add(int c)&#123; int p=las,np=las=++tot; pool[np].newNode(pool[p].len+1); for(;p&amp;&amp;!pool[p].ch[c];p=pool[p].fa)pool[p].ch[c]=np; if(!p)pool[np].fa=1;//以上为case 1 else&#123; int q=pool[p].ch[c]; if(pool[q].len==pool[p].len+1)pool[np].fa=q;//以上为case 2 else&#123; int nq=++tot; pool[nq]=pool[q]; pool[nq].len=pool[p].len+1; pool[q].fa=pool[np].fa=nq; for(;p&amp;&amp;pool[p].ch[c]==q;p=pool[p].fa) pool[p].ch[c]=nq;//以上为case 3 &#125; &#125;&#125; 广义后缀自动机广义后缀自动机就是把所有串放到一个后缀自动机里一起处理。每次往后缀自动机里添加一个字符串后，将 $last$ 重新挪到 $1$ 号节点上，再添加下一个字符串即可。添加字符串 $S_i$ 时，添加出来的所有实节点及它们在 $pre$ 树上的祖先们代表的子串，都在字符串 $S_i$ 中出现过。于是我们可以利用一些类似于 $set$ 启发式合并的方法，来得到每个节点在多少个字符串中出现过。 应用 本质不同回文串 manacher &amp; hash 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156int t1[N],t2[N],c[N],srank[N],height[N],sa[N];bool cmp(int *r,int a,int b,int l)&#123; return r[a] == r[b] &amp;&amp; r[a+l] == r[b+l];&#125;void DA(int str[],int n,int m)&#123;//m为字符串中的最大值+1 n++; int i, j, p, *x = t1, *y = t2; //第一轮基数排序，如果s 的最大值很大，可改为快速排序 for(i = 0;i &lt; m;i++)c[i] = 0; for(i = 0;i &lt; n;i++)c[x[i] = str[i]]++; for(i = 1;i &lt; m;i++)c[i] += c[i-1]; for(i = n-1;i &gt;= 0;i--)sa[--c[x[i]]] = i; for(j = 1;j &lt;= n; j &lt;&lt;= 1)&#123; p = 0; //直接利用sa 数组排序第二关键字 for(i = n-j; i &lt; n; i++)y[p++] = i;//后面的j 个数第二关键字为空的最小 for(i = 0; i &lt; n; i++)if(sa[i] &gt;= j)y[p++] = sa[i] - j;//这样数组y保存的就是按照第二关键字排序的结果 //基数排序第一关键字 for(i = 0; i &lt; m; i++)c[i] = 0; for(i = 0; i &lt; n; i++)c[x[y[i]]]++; for(i = 1; i &lt; m;i++)c[i] += c[i-1]; for(i = n-1; i &gt;= 0;i--)sa[--c[x[y[i]]]] = y[i];//根据sa 和x 数组计算新的x 数组 swap(x,y); p = 1; x[sa[0]] = 0; for(i = 1;i &lt; n;i++)x[sa[i]] = cmp(y,sa[i-1],sa[i],j)?p-1:p++; if(p &gt;= n)break; m = p;//下次基数排序的最大值 &#125; int k = 0; n--; for(i = 0;i &lt;= n;i++)srank[sa[i]] = i; for(i = 0;i &lt; n;i++)&#123; if(k)k--; j = sa[srank[i]-1]; while(str[i+k] == str[j+k])k++; height[srank[i]] = k; &#125;&#125;int r[N]; int ans[M];ull P = 1313131;ull sqr[M],has[M];unordered_set&lt;ull&gt;ss;vector&lt;pii&gt; v;ull getHash(int x,int y)&#123; return has[y]-has[x-1]*sqr[y-x+1];&#125;void init(char *s,int Len)&#123;//s 从1开始 sqr[0]=1; for(int i=1;i&lt;=Len;i++)&#123; sqr[i]=sqr[i-1]*P; has[i]=has[i-1]*P+s[i]; &#125;&#125;char s[M];int dp[M][30];void ST(int n) &#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = height[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) &#123; dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int RMQ(int l, int r) &#123; int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= r - l + 1) k++; return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);&#125;int len;void query(int x,int y)&#123; // printf("%d %d\n",x,y); pii tmp(x,y); int dep=srank[tmp.fi]; int l=2,r=dep,mid,tans=1; if(l&lt;=dep)&#123; while(l&lt;=r)&#123; mid=(l+r)/2; if(RMQ(mid,dep)&lt;tmp.se)l=mid+1; else r=mid-1; &#125; tans+=dep-l+1; &#125; l=dep+1,r=len; while(l&lt;=r)&#123; mid=(l+r)/2; if(RMQ(dep+1,mid)&gt;=tmp.se)l=mid+1; else r=mid-1; &#125; tans+=r-dep; ans[tmp.se]+=tans;&#125;int insert(int x,int y)&#123; if(!ss.count(getHash(x,y)))&#123; ss.insert(getHash(x,y)); if((y-x+1)%2)&#123; if(getHash(x,(x+y)/2)==getHash((x+y)/2,y))query(x-1,y-x+1); &#125;else&#123; if(getHash(x,(x+y)/2)==getHash((x+y)/2+1,y))query(x-1,y-x+1); &#125; &#125; return 0;&#125;void Manacher(char *s, int len) &#123; int r[M]; int R = 0, id = 0; for (int i = 1; i &lt;=len; i++) &#123; r[i] = R&gt;i ? min(r[2 * id - i], R - i):insert(i,i); //r[i] 表示以 i 为中心的回文串半径（不包括 i ） while (i+r[i]+1&lt;=len&amp;&amp;s[i - r[i] - 1]==s[i + r[i] + 1] )&#123; insert(i - r[i] - 1,i + r[i] + 1); r[i]++; &#125; if (i + r[i] &gt; R) &#123; R = i + r[i]; id = i; &#125; &#125; id=R=0; for(int i=2;i&lt;=len;i++)&#123; r[i] = R&gt;i ? min(r[2 * id - i], R - i + 1):0;//r[i] 表示以 i-1 和 i 为中心的回文串半径 while (i+r[i]&lt;=len&amp;&amp;s[i - r[i] - 1]==s[i + r[i]])&#123; insert(i - r[i] - 1,i + r[i]); r[i]++; &#125; if (i + r[i]-1 &gt; R) &#123; R = i + r[i]-1; id = i; &#125; &#125;&#125;int main() &#123; whiel(~in(s+1))&#123; len=strlen(s+1); init(s,len); for1(i,len)&#123; r[i-1]=s[i]-'a'+1; &#125; r[len]=0; DA(r,len,30); ST(len); Manacher(s,len); for1(i,len)&#123; out(ans[i]); ans[i]=0; &#125; ss.clear(); puts(""); &#125; cerr&lt;&lt;clock()&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CF-1203F]]></title>
    <url>%2F2019%2F08%2F15%2FCF-1203F%2F</url>
    <content type="text"><![CDATA[题意给两个序列 $a[],b$ ，你拥有的技能点为 $r(1\le r\le 3e4)$ ，只有当技能点 $\ge a_i$ 时，才可以做第 $i$ 份工作，技能点加上 $b_i$ 问他能否完成这 $n$ 份工作 如果不能，最多能完成几份 题解 显然，对于 $b_i\ge 0$ ，我们以 $a_i$ 排序；对于 $b_i&lt; 0$ ，我们以 $a_i+b_i$ 排序。因为对于 $x,y$ 两个工作，假设 $xa+xb&lt;ya+yb$ ，如果 $r+xb&lt;ya$ ，那么一定有 $r+yb&lt;ax$ 对于 $b_i\ge 0$ 容易求解；对于 $b_i&lt; 0$ ，使用 $dp$ 来求解，同样以 $a_i+b_i$ 排序，$dp[i][j]$ 表示前 $i$ 份工作剩余 $j$ 技能点的最大完成数。 代码12345678910111213141516171819202122232425262728293031323334353637int dp[N];vector&lt;pii&gt;q,w;bool cmp(pii x,pii y)&#123; retrun x.fi+x.se&gt;y.fi+y.se;&#125;int main() &#123; int n,r,a,b; in(n,r); for0(i,n)&#123; in(a,b); if(b&gt;=0)&#123; q.pu_b(pii(a,b)); &#125;else&#123; w.pu_b(pii(a,b)); &#125; &#125; sort(q.begin(),q.end()); sort(w.begin(),w.end(),cmp); int ans=0; for(auto i:q)&#123; if(r&gt;=i.fi)&#123; r+=i.se; ans++; &#125;else&#123; break; &#125; &#125; int maxx=0; for(auto i:w)&#123; for(int j=max(i.fi,-i.se);j&lt;=r;j++)&#123; dp[j+i.se]=max(dp[j]+1,dp[j+i.se]); maxx=max(dp[j+i.se],maxx); &#125; &#125; out(ans+maxx,1); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校-Day1]]></title>
    <url>%2F2019%2F08%2F13%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-Day1%2F</url>
    <content type="text"><![CDATA[B. Integration题意已知 $\Large \int_{0}^{\infty} \frac{1}{1+x^{2}} \mathrm{d} x=\frac{\pi}{2}$ ，求 $\Large\frac{1}{\pi} \int_{0}^{\infty} \frac{1}{\prod_{i=1}^{n}\left(a_{i}^{2}+x^{2}\right)} \mathrm{d} x$ 题解由 $\large\frac 1 a\times \frac 1 b=(\frac 1 a-\frac 1 b)\times \frac 1 {(b-a)}$ ，获得启发，化乘为加，令 $\large c_i=\prod\limits_{j\ne i}\frac 1 {a_j^2-a_i^2}$ ，则 $\large\prod \frac 1 {(a_i^2+x^2)}=\sum \frac {c_i}{a_i^2+x^2}$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;void in(initializer_list&lt;int*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%d",*ptr);&#125;void in(initializer_list&lt;ll*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lld",*ptr);&#125;void in(initializer_list&lt;db*&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)scanf("%lf",*ptr);&#125;void out(initializer_list&lt;int&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d ",*ptr);&#125;void outln(initializer_list&lt;int&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%d\n",*ptr);&#125;void out(initializer_list&lt;ll&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld ",*ptr);&#125;void outln(initializer_list&lt;ll&gt; li)&#123;for(auto ptr=li.begin();ptr!=li.end();ptr++)printf("%lld\n",*ptr);&#125;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;c)&#123;return scanf("%c",&amp;c);&#125;void out(int a,bool ln)&#123;printf("%d%c",a,ln? '\n':' ');&#125;void out(ll a,bool ln)&#123;printf("%lld%c",a,ln? '\n':' ');&#125;void out(db a,int digit,bool ln)&#123;printf("%.*f%c",digit,a,ln? '\n':' ');&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e3;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123;return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b);&#125;int a[N];ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; while(~in(n))&#123; for1(i,n)in(a[i]); // if(n==1)&#123; // out(qPow(2ll*a[1],mod-2,mod),1); // continue; // &#125; ll ans=0; for1(i,n)&#123; ll tm=1; for1(j,n)&#123; if(j!=i)&#123; tm=tm*((1ll*a[j]*a[j]%mod-1ll*a[i]*a[i]%mod+mod)%mod)%mod; // tm=tm*qPow((1ll*a[j]*a[j]%mod-1ll*a[i]*a[i]%mod+mod)%mod,mod-2,mod)%mod; &#125; &#125; ans=(ans+qPow(2*a[i],mod-2,mod)*qPow(tm,mod-2,mod)%mod)%mod; &#125; out(ans,1); &#125; return 0;&#125; C. Euclidean Distance题意给一个点 $(\frac {a_1} m,\frac {a_2} m,\cdots,\frac {a_n} m)(-m\le a_i\le m)$ ，找到一个点 $P(p_1,p_2,\cdots,p_n)(p_i\ge 0,\sum p_i=1)$ 使得 $\sum (\frac {a_i}m-p_i)^2$ 最小 题解对 $a_i$ 排序，逐渐减小最大的 $a_i$ ，使得序列的最大值尽可能小 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970bool cmp(int x,int y)&#123; return x&gt;y;&#125;ll gcd(ll x,ll y)&#123; return y?gcd(y,x%y):x;&#125;struct fraction&#123; ll son, mom; fraction()&#123;&#125; fraction(ll a,ll b)&#123; if(a)&#123;ll gc=gcd(abs(a),abs(b));if(b&lt;0) son=-a/gc,mom=-b/gc;else son=a/gc,mom=b/gc;&#125; else son=0,mom=1; &#125; bool operator==(const fraction &amp;x)const&#123; return son==x.son&amp;&amp;mom==x.mom; &#125; bool operator!=(const fraction &amp;x)const&#123; return !(son==x.son&amp;&amp;mom==x.mom); &#125; bool operator&lt;(const fraction &amp;y)const&#123; return son * y.mom &lt; y.son * mom; &#125; bool operator&lt;=(const fraction &amp;y)const&#123; return son * y.mom &lt;= y.son * mom; &#125; fraction operator*(const fraction &amp;y)const&#123; return fraction(son*y.son,mom*y.mom); &#125; fraction operator+(const fraction &amp;y)const&#123; return fraction(son * y.mom + y.son * mom,mom*y.mom); &#125; fraction operator/(const fraction &amp;y)const&#123; return fraction(son*y.mom,mom*y.son); &#125; fraction operator-(const fraction &amp;y)const&#123; return fraction(son * y.mom - y.son * mom,mom*y.mom); &#125; void display()&#123; if(mom==1)printf("%lld\n",son); else printf("%lld/%lld\n",son,mom); &#125;&#125;;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,a[N]; while(~in(n))&#123; in(m); for0(i,n)in(a[i]); sort(a,a+n,cmp); int remain=m; int i=1; for(;i&lt;n;i++)&#123; if(i*(a[i-1]-a[i])&lt;=remain)&#123; remain-=i*(a[i-1]-a[i]); &#125;else break; &#125; fraction ans=fraction(i*a[i-1]*a[i-1]-2*remain*a[i-1],1)+fraction(remain*remain,i); for(;i&lt;n;i++)&#123; ans=ans+fraction(a[i]*a[i],1); &#125; ans=ans/fraction(m*m,1); ans.display(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客多校-Day4]]></title>
    <url>%2F2019%2F08%2F09%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-Day4%2F</url>
    <content type="text"><![CDATA[I. String题意定义两个字符串不等为 $a\ne b \&amp;\&amp; a\ne rev(b) $ 给一个字符串，问由它的子串构成的 任意两个元素都不等 的最大集合有多大 题解显然答案为 $a,rev(a)$ 中本质不同的子串的数量除 2，注意若子串为回文串则只被计了一次，所以还需要加上一个 $a$ 中本质不同回文串的数量再除 2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 4.1e5;const int M = 4.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int t1[N],t2[N],c[N],srank[N],height[N],sa[N];bool cmp(int *r,int a,int b,int l)&#123; return r[a] == r[b] &amp;&amp; r[a+l] == r[b+l];&#125;void DA(int str[],int n,int m)&#123;//m为字符串中的最大值+1 n++; int i, j, p, *x = t1, *y = t2; //第一轮基数排序，如果s 的最大值很大，可改为快速排序 for(i = 0;i &lt; m;i++)c[i] = 0; for(i = 0;i &lt; n;i++)c[x[i] = str[i]]++; for(i = 1;i &lt; m;i++)c[i] += c[i-1]; for(i = n-1;i &gt;= 0;i--)sa[--c[x[i]]] = i; for(j = 1;j &lt;= n; j &lt;&lt;= 1)&#123; p = 0; //直接利用sa 数组排序第二关键字 for(i = n-j; i &lt; n; i++)y[p++] = i;//后面的j 个数第二关键字为空的最小 for(i = 0; i &lt; n; i++)if(sa[i] &gt;= j)y[p++] = sa[i] - j;//这样数组y保存的就是按照第二关键字排序的结果 //基数排序第一关键字 for(i = 0; i &lt; m; i++)c[i] = 0; for(i = 0; i &lt; n; i++)c[x[y[i]]]++; for(i = 1; i &lt; m;i++)c[i] += c[i-1]; for(i = n-1; i &gt;= 0;i--)sa[--c[x[y[i]]]] = y[i];//根据sa 和x 数组计算新的x 数组 swap(x,y); p = 1; x[sa[0]] = 0; for(i = 1;i &lt; n;i++)x[sa[i]] = cmp(y,sa[i-1],sa[i],j)?p-1:p++; if(p &gt;= n)break; m = p;//下次基数排序的最大值 &#125; int k = 0; n--; for(i = 0;i &lt;= n;i++)srank[sa[i]] = i; for(i = 0;i &lt; n;i++)&#123; if(k)k--; j = sa[srank[i]-1]; while(str[i+k] == str[j+k])k++; height[srank[i]] = k; &#125;&#125;const int C = 26;struct Palindromic_Tree &#123; int next[N][C] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成 int fail[N] ;//fail指针，失配后跳转到fail指针指向的节点 int cnt[N] ;//cnt[i]表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的） int num[N] ;//num[i]表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数。 int len[N] ;//len[i]表示节点i表示的回文串的长度 int S[N] ;//存放添加的字符 int last ;//指向上一个字符所在的节点，方便下一次add int n ;//字符数组指针 int p ;//节点指针 int newnode ( int l ) &#123;//新建节点 for ( int i = 0 ; i &lt; C ; ++ i ) next[p][i] = 0 ; cnt[p] = 0 ; num[p] = 0 ; len[p] = l ; return p ++ ; &#125; void init () &#123;//初始化 p = 0 ; newnode ( 0 ) ; newnode ( -1 ) ; last = 0 ; n = 0 ; S[n] = -1 ;//开头放一个字符集中没有的字符，减少特判 fail[0] = 1 ; &#125; int get_fail ( int x ) &#123;//和KMP一样，失配后找一个尽量最长的 while ( S[n - len[x] - 1] != S[n] ) x = fail[x] ; return x ; &#125; void add ( int c ) &#123; c -= 'a' ; S[++ n] = c ; int cur = get_fail ( last ) ;//通过上一个回文串找这个回文串的匹配位置 if ( !next[cur][c] ) &#123;//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串 int now = newnode ( len[cur] + 2 ) ;//新建节点 fail[now] = next[get_fail ( fail[cur] )][c] ;//和AC自动机一样建立fail指针，以便失配后跳转 next[cur][c] = now ; num[now] = num[fail[now]] + 1 ; &#125; last = next[cur][c] ; cnt[last] ++ ; &#125; void count () &#123; for ( int i = p - 1 ; i &gt;= 0 ; -- i ) cnt[fail[i]] += cnt[i] ; //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！ &#125;&#125; PAM;int r[N];char s[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(s); ll n=strlen(s); s[n]='`'; PAM.init(); for0(i,n) &#123; s[2*n-i]=s[i]; PAM.add(s[i]); &#125; ll m=2*n+1; for0(i,m)r[i]=s[i]-'`'+1; r[m]=0; DA(r,m,30); ll ans=PAM.p-2+m*(m+1)/2-(n+1)*(n+1); for(int i=2;i&lt;=m;i++)ans-=height[i]; outln(ans/2); return 0;&#125;]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6635]]></title>
    <url>%2F2019%2F08%2F08%2FHDU-6635%2F</url>
    <content type="text"><![CDATA[题意给两个排列 $a , b$ ，$a$ 一开始全都封闭，从左到右遍历 $b$ ，每次释放一个 $\Large a_{b_i}$ ，问每个时刻，释放后的序列 $a$ 的 $LIS$ 题解考虑时间倒流， 看作一个完整的排列按照一定顺序依次删除每个数， 然后每次需要计算 $LIS$ 的长度。 首先在 $O(n log n) $ 的时间内求出 $LIS$，并找到任意一个 $LIS$。当删除 x 时，如果 x 不在之前找 到的那个 LIS 中，那么显然 LIS 的长度是不会变化的，否则暴力重新计算出新的 LIS 即可。因为数据随机，因此 LIS 的期望长度是 $O( \sqrt n)$，删除的 x 位于 LIS 中的概率是 $\frac 1 {\sqrt n}$ ，也就是说期望时间复杂度为$O(n \sqrt n log n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e4;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],pre[N],b[N],ans[N],cnt,n,pp[N],pr[N];bool vis[N],cho[N];void redo()&#123; cnt=0; mem0(cho); int last=0; for1(i,n)&#123; if(!vis[i])&#123; int posi=upper_bound(pre+1,pre+1+cnt,a[i])-pre; // printf("sa%d %d\n",i,a[i]); if(posi==cnt+1)&#123; pre[++cnt]=a[i]; pr[cnt]=i; pp[i]=pr[cnt-1]; last=i; // printf("sa%d\n",i); // sta[cnt].push(i); &#125;else &#123; pre[posi]=a[i]; pr[posi]=i; pp[i]=pr[posi-1]; // no[i]=posi; // sta[posi].push(i); &#125; &#125; &#125; while(last)&#123; cho[last]=1; // out(last); last=pp[last]; &#125; // puts("");&#125;void del(int x)&#123; vis[x]=1; if(cho[x])redo();&#125;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; in(t); whiel(t--)&#123; in(n); mem0(vis); for1(i,n)in(a[i]); for1(i,n)in(b[i]); redo(); for(int i=n;i&gt;0;i--)&#123; ans[i]=cnt; del(b[i]); &#125; for1(i,n)&#123; if(i==n)outln(ans[i]); else out(ans[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客-MaxAnswer]]></title>
    <url>%2F2019%2F08%2F08%2F%E8%AE%A1%E8%92%9C%E5%AE%A2-MaxAnswer%2F</url>
    <content type="text"><![CDATA[题意求数组的一个子区间，使得 子区间之和 乘以 子区间最小值 最大，求最大值 题解权值可能为负，分别考虑正负，正数使用但单调栈，负数求出最小连续子段和乘以该子段的最小值 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e5;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;stack&lt;pll&gt;sta; int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; ll x; in(n); ll ans=0,minn=0,tot=0; for0(i,n)&#123; in(x); if(tot+x&gt;0)&#123; tot=minn=0; &#125;else&#123; minn=min(minn,x); tot+=x; ans=max(ans,minn*tot); &#125; if(x&lt;=0)&#123; ll tmp=0; whiel(sta.size())&#123; tmp+=sta.top().se; ans=max(ans,sta.top().fi*tmp); sta.pop(); &#125; &#125;else&#123; ll tmp=0; while(sta.size()&amp;&amp;x&lt;=sta.top().fi)&#123; tmp+=sta.top().se; ans=max(ans,sta.top().fi*tmp); sta.pop(); &#125; sta.push(pll(x,tmp+x)); &#125; &#125; ll tmp=0; whiel(sta.size())&#123; tmp+=sta.top().se; ans=max(ans,sta.top().fi*tmp); sta.pop(); &#125; outln(ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019-牛客多校-Day5]]></title>
    <url>%2F2019%2F08%2F08%2F2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1-Day5%2F</url>
    <content type="text"><![CDATA[C. generator 2题意给出 $n, x_{0}, a, b, p \quad\left(1 \leq n \leq 10^{18}, 0 \leq x_{p}, a, b&lt;p \leq 10^{9}+9,\text{p is a prime number}\right)$ ，$q$次询问，问在序列 $x_0,x_1,\cdots,x_{n-1}$ 中最小的 $i$ ，使得 $x_i=v$ 题解需要手写Hash，对于 GSBS 中的 $c_im-r_i$ ，因为有多组，且 $a,p$ 都不变，我们可以预处理 $\large a^{im}$ ，每组样例的时间复杂度为 $\frac p m+qm $ ，所以 $m=\sqrt{\frac p q}$ 时，总的时间复杂度最小 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e6;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;struct Hash &#123; static const int MOD = 2e6+7; static const int N = 2e6; ll head[MOD + 10], nx[N], top; ll hs[N], id[N]; void init() &#123; memset(head, -1, sizeof head); top = 0; &#125; void insert(ll x, ll y) &#123;//x-key y-val ll k = x % MOD; hs[top] = x; id[top] = y; nx[top] = head[k]; head[k] = top++; &#125; ll find(ll x) &#123; ll k = x % MOD; for (int i = head[k]; i != -1; i = nx[i]) &#123; if (hs[i] == x) &#123; return id[i]; &#125; &#125; return -1; &#125;&#125;hs;ll m,n;ll BSGS(ll a, ll b, ll p) &#123; // a^x == b (mod p) if(b==1)return 0; ll ans=p-1; for (ll i = 0; i &lt; m; ++i) &#123; if(hs.find(b)&gt;=0)&#123; ans=min(ans,hs.find(b)-i); &#125; b = b * a % p; &#125; if(ans==p-1||ans&gt;=n) return -1; else return ans;&#125;int main() &#123; int t,x,a,b,q; ll p; ll v; in(t); whiel(t--)&#123; in(n); in(x,a,b); in(p); in(q); if(a==1)&#123; while(q--)&#123; in(v); ll an=(v-x+p)%p*qPow(b,p-2,p)%p; if(an&lt;n)outln(an); else outln(-1); &#125; &#125;else if(a==0)&#123; while(q--)&#123; in(v); if(v==x)outln(0); else if(v==b&amp;&amp;n&gt;1)outln(1); else outln(-1); &#125; &#125;else&#123; m = ceil(sqrt(1.0*p/q)); ll tt = qPow(a,m,p), vv= 1; hs.init(); for ( ll i = 1; ; ++i) &#123; vv = vv * tt % p; if(hs.find(vv)==-1) hs.insert(vv,i*m); if(i*m&gt;=p)break; &#125; while(q--)&#123; in(v); ll c=b*qPow(a-1,p-2,p)%p; v=(v+c)%p*qPow(x+c,p-2,p)%p; outln(BSGS(a,v,p)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6592]]></title>
    <url>%2F2019%2F08%2F07%2FHDU-6592%2F</url>
    <content type="text"><![CDATA[题意给一个序列 $a[]$ ，找出最长的单峰序列，输出该序列的下标，输出字典序最大和最小的情况 题解易证，当取第一个峰的时候字典序最小，当取最后一个峰的时候字典序最大。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3.1e5;const int M = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],f[N],g[N],pre[N],ans[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; while(~in(n))&#123; for1(i,n)in(a[i]); int len=0; for1(i,n)&#123; int posi=upper_bound(pre+1,pre+1+len,a[i])-pre; // out(posi); if(posi==len+1)&#123; if(a[i]&gt;pre[len])&#123; pre[++len]=a[i]; f[i]=len; &#125;else f[i]=len; &#125;else&#123; if(a[i]&gt;pre[posi-1])&#123; pre[posi]=a[i]; f[i]=posi; &#125;else&#123; f[i]=posi-1; &#125; &#125; &#125; // puts(""/); len=0; for1(i,n)&#123; int j=n-i+1; int posi=upper_bound(pre+1,pre+1+len,a[j])-pre; if(posi==len+1)&#123; if(a[j]&gt;pre[len])&#123; pre[++len]=a[j]; g[j]=len; &#125;else g[j]=len; &#125;else&#123; if(a[j]&gt;pre[posi-1])&#123; pre[posi]=a[j]; g[j]=posi; &#125;else&#123; g[j]=posi-1; &#125; &#125; &#125; int maxx=0,Fi=0,La=0; for1(i,n)maxx=max(maxx,f[i]+g[i]-1); for1(i,n)&#123; if(f[i]+g[i]-1==maxx)&#123; if(!Fi)Fi=i; La=i; &#125; &#125; int tail=f[Fi]; ans[tail]=Fi; for(int i=Fi-1;i&gt;0;i--)&#123; if(f[i]+1&gt;=tail&amp;&amp;f[i]&lt;f[Fi])&#123; if(a[ans[f[i]+1]]&gt;a[i])&#123; tail=f[i]; ans[f[i]]=i; &#125; &#125; &#125; // assert(tail==1); tail=f[Fi]; // cout&lt;&lt;tail&lt;&lt;endl; for(int i=Fi+1;i&lt;=n;i++)&#123; if(a[i]&lt;a[ans[tail]]&amp;&amp;g[i]+1==g[ans[tail]])&#123; ans[++tail]=i; &#125; &#125; for1(i,maxx)&#123; printf("%d%c",ans[i]," \n"[i==maxx]); &#125; tail=maxx-g[La]+1; ans[tail]=La; for(int i=La+1;i&lt;=n;i++)&#123; if(g[i]+tail&gt;=maxx&amp;&amp;g[i]&lt;g[La])&#123; if(a[ans[maxx-g[i]]]&gt;a[i])&#123; tail=maxx-g[i]+1; ans[tail]=i; &#125; &#125; &#125; // assert(tail==maxx); tail=maxx-g[La]+1; for(int i=La-1;i&gt;0;i--)&#123; if(a[i]&lt;a[ans[tail]]&amp;&amp;f[i]+1==f[ans[tail]])&#123; ans[--tail]=i; &#125; &#125; for1(i,maxx)&#123; printf("%d%c",ans[i]," \n"[i==maxx]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1195E]]></title>
    <url>%2F2019%2F07%2F29%2FCF-1195E%2F</url>
    <content type="text"><![CDATA[题意给一个 $nm(1 \leq n, m \leq 3000)$ 的矩阵，求每一个 $ab$ 的子矩阵中最小值之和 题解先求出每一行长度为 $b$ 的序列的最小值，再求每一列长度为 $a$ 的序列的最小值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3.1e3;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125; int minn[N][N],h[N][N],q[N];// q[i]表示从 i 开始长度为 len 的序列中的最小值的下标ll ans;void fun(int x,int n,int a)&#123; int l=1,r=0; for1(i,n)&#123; whiel(i-q[l]+1&gt;a&amp;&amp;l&lt;=r)l++; while(h[x][q[r]]&gt;h[x][i]&amp;&amp;l&lt;=r)r--; q[++r]=i; // cout&lt;&lt;i&lt;&lt;' '&lt;&lt;l&lt;&lt;' '&lt;&lt;q[l]&lt;&lt;endl; minn[x][i]=h[x][q[l]]; &#125;&#125;void fun2(int x,int n,int a)&#123; int l=1,r=0; for(int i=1;i&lt;=n;i++)&#123; whiel(i-q[l]+1&gt;a&amp;&amp;l&lt;=r)l++; while(minn[q[r]][x]&gt;minn[i][x]&amp;&amp;l&lt;=r)r--; q[++r]=i; if(i&gt;=a) ans+=minn[q[l]][x]; // minn[x][i]=h[x][q[l]]; &#125;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,a,b,g,x,y,z; in(n,m,a,b); in(g,x,y,z); for0(i,n*m)&#123; h[i/m+1][i%m+1]=g; g=(1ll*g*x+y)%z; &#125; // for1(i,n)&#123; // for1(j,m)&#123; // out(h[i][j]); // &#125; // puts(""); // &#125; for1(i,n)&#123; fun(i,m,b); &#125; // for1(i,m)out(minn[1][i]); // puts(""); for(int i=b;i&lt;=m;i++)&#123; fun2(i,n,a); &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1189E]]></title>
    <url>%2F2019%2F07%2F06%2FCF-1189E%2F</url>
    <content type="text"><![CDATA[E. Count Pairs题意You are given a prime number $p, n$ integers $a_{1}, a_{2}, \ldots, a_{n}(all a_i are different),$ and an integer $k$ Find the number of pairs of indexes $(i, j)(1 \leq i&lt;j \leq n)$ for which $\left(a_{i}+a_{j}\right)\left(a_{i}^{2}+a_{j}^{2}\right) \equiv k \bmod p$ 题解 (a_i-a_j)(a_i+a_j)(a_i^2+a_j^2)\equiv (a_i-a_j)k\ \bmod p\\ a_i^4-ka_i\equiv a_j^4-ka_j\bmod p代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125; unordered_map&lt;int,int&gt;m; int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,p,k; ll a; in(n,p,k); for0(i,n)&#123; in(a); a=((a*a%p*a%p*a%p-a*k%p)%p+p)%p; m[a]++; &#125; ll ans=0; for(auto i:m)&#123; ans+=1l*i.se*(i.se-1)/2; &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1183F]]></title>
    <url>%2F2019%2F06%2F30%2FCF-1183F%2F</url>
    <content type="text"><![CDATA[题意给 $n$ 个数，选至多 $3$ 个，且两两不为倍数关系，问最大值是多少 题解排序，若最大值不取 $a_n$，那只有一种可能 $\frac 1 2 a_n ,\frac 1 3 a_n,\frac 1 5 a_n $，因为如果最大值包含不为 a_n 的因子，那么显然取 a_n 更优。易证，若取 $a_n$ ，一定会取 不为 $a_n$ 因子的最大值， 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125; int a[N];unordered_set&lt;int&gt;s;int main() &#123; int q,n; in(q); while(q--)&#123; in(n); for0(i,n)&#123; in(a[i]); s.insert(a[i]); &#125; sort(a,a+n); n=unique(a,a+n)-a; int maxx=a[n-1]; int tmp=maxx; if(maxx%2==0&amp;&amp;maxx%3==0&amp;&amp;maxx%5==0&amp;&amp;s.count(maxx/2)&amp;&amp;s.count(maxx/3)&amp;&amp;s.count(maxx/5))&#123; maxx=maxx/30*31; &#125; for(int i=n-2;i&gt;=0;i--)&#123; if(tmp%a[i])&#123; for(int j=i-1;j&gt;=0;j--)&#123; if(tmp%a[j]&amp;&amp;a[i]%a[j])&#123; tmp+=a[j]; break; &#125; &#125; tmp+=a[i]; break; &#125; &#125; outln(max(maxx,tmp)); s.clear(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1183G]]></title>
    <url>%2F2019%2F06%2F28%2FCF-1183G%2F</url>
    <content type="text"><![CDATA[G. Candy Box (hard version)题意$q(1\le q\le 2e5)$ 次询问，每次询问$n(1\le n\le 2e5)$ 个物体，每个物体的种类为 $a_i(1\le a_i\le n)$，喜欢与否为 $f_i(0\le f_i\le1)$，要尽量取多的物体，要求每种物体的数量不同，在保证数量最多的情况下，要让喜欢的最少 题解按种类数排序，总数记为 $x_i$ ，$f=0$ 的数量为 $y_i$，从 $n-&gt;1$ 扫描，对于当前 $i$，将满足条件的 $y_i$ 加入优先队列 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;pii a[N];priority_queue&lt;int&gt;Q;int main() &#123; itn q,n,x,y; in(q); whiel(q--)&#123; in(n); for0(i,n)&#123; in(x,y); a[x].fi++; a[x].se+=y; &#125; sort(a+1,a+n+1); ll an1=0,an2=0; int id=n; for(itn i=n;i;i--)&#123; while(id&amp;&amp;a[id].fi&gt;=i)&#123; Q.push(a[id--].se); &#125; if(Q.size())&#123; an1+=i; an2+=min(i,Q.top()); Q.pop(); &#125; &#125; for1(i,n)a[i]=pii(0,0); whiel(Q.size())Q.pop(); out(an1); outln(an2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6223]]></title>
    <url>%2F2019%2F06%2F18%2FHDU-6223%2F</url>
    <content type="text"><![CDATA[题意长度为 $n(1\le n \le 2e6)$ 的数组 $(0\le a_i\le 9)$, 下标为 $[0,n-1]$ , 你要取 $n$ 个数构成一个长度为 $n$ 的数组 $b$ , 假设第一次选 $a[i]$ , 则 $b[1]=a[i], b[2]=a[(i^2+1)\%n],\cdots$ 输出字典序最小的 $b$ 题解显然取的下标序列存在循环节, 由打表可知, 循环节的长度不会超过 $21$, 所以我们只用枚举前 $21*20$ (循环节的最大$lcm$)位就可以找到保证 $b$ 字典序最小的起始点, 好像数据太水了,只用枚举前 21​ 位就可以了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.6e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;char s[N],ans[N];int main() &#123; int t,n; in(t); for1(ca,t)&#123; in(n); in(s); printf("Case #%d: ",ca); ll loo; for0(i,n)ans[i]='0'; for0(i,n)&#123; bool yes=0; ll ti=i; for0(j,22)&#123; if(s[ti]&lt;ans[j])&#123; if(yes)ans[j]=s[ti]; else break; &#125;else if(s[ti]&gt;ans[j])&#123; yes=1; ans[j]=s[ti]; &#125; ti=(ti*ti+1)%n; &#125; if(yes)loo=i; &#125; for0(i,n)&#123; putchar(s[loo]); loo=(loo*loo+1)%n; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客-LIS]]></title>
    <url>%2F2019%2F06%2F17%2F%E8%AE%A1%E8%92%9C%E5%AE%A2-LIS%2F</url>
    <content type="text"><![CDATA[题意从长度为 $n(\le 5e5)$ 的数组中等概率的取出一个最长上升子序列, 求每个数被选中的概率 题解$bg[i]$ 是以 $a[i]$ 为起点的 $LIS$ 的长度, $g[i]$ 是以 $a[i]$ 为起点的 $LIS$ 的数量 $en[i]$ 是以 $a[i]$ 为终点的 $LIS$ 的长度, $h[i]$ 是以 $a[i]$ 为终点的 $LIS$ 的数量 $\text{len_a}[i]$ 是以 $i$ 为起点或终点的 $LIS$ 的长度, $\text{cnt_a}[i]$ 是以 $i$ 为起点或终点的 $LIS$ 的数量 $\text{len_h}[i],\text{cnt_h}[i] $ 是树状数组的辅助数组 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e5;const ll mod = 998244353;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int bg[N],g[N],en[N],h[N],a[N],b[N],len_h[N],len_a[N],cnt_h[N],cnt_a[N];//cnt[i]极大值树,len[i]int lowbit(int x)&#123; return x&amp;(-x);&#125;void Update(int x,int y,int z,int n)&#123; if(len_a[x]==y)&#123; cnt_a[x]=(cnt_a[x]+z)%mod; &#125;else&#123; len_a[x]=y;; cnt_a[x]=z; &#125; int lx; while(x&lt;=n)&#123; len_h[x]=len_a[x]; cnt_h[x]=cnt_a[x]; lx = lowbit(x); for (int i=1; i&lt;lx; i&lt;&lt;=1) if(len_h[x-i]&gt;len_h[x])&#123; len_h[x]=len_h[x-i]; cnt_h[x]=cnt_h[x-i]; &#125;else if(len_h[x-i]==len_h[x])cnt_h[x]=(cnt_h[x]+cnt_h[x-i])%mod; // mx[x] = max(mx[x], len[x-i]); x += lowbit(x); &#125;&#125;pii query(int l,int r)&#123;//返回 （以[l,r]结尾的最长LIS , 以[l,r]结尾的最长LIS的数量) int ans = 0; int tl=l,tr=r; while(r &gt;= l)&#123; ans = max(ans,len_a[r]); r--; for(;r-lowbit(r)&gt;= l ;r-=lowbit(r))ans = max(ans,len_h[r]); &#125; l=tl;r=tr; int tot=0; while(r &gt;= l)&#123; // ans = max(ans,len_a[r]); if(len_a[r]==ans)tot=(tot+cnt_a[r])%mod; r--; for(;r-lowbit(r)&gt;= l ;r-=lowbit(r))&#123; if(len_h[r]==ans)tot=(tot+cnt_h[r])%mod; // ans = max(ans,len_h[r]); &#125; &#125; return pii(ans,tot);&#125;int qpow(ll a,ll b)&#123; ll ans=1; a%=mod; while(b)&#123; if(b%2)ans=ans*a%mod; a=a*a%mod; b/=2; &#125; return ans;&#125;int main() &#123; int n; in(n); for0(i,n)&#123; in(a[i]); b[i]=a[i]; &#125; sort(b,b+n); for0(i,n)a[i]=lower_bound(b,b+n,a[i])-b+1; int L=0; pii tmp; for0(i,n)&#123; tmp=query(1,a[i]-1); en[i]=tmp.fi+1; L=max(L,en[i]); h[i]=tmp.se; if(en[i]==1)h[i]=1; Update(a[i],en[i],h[i],n); &#125; mem0(cnt_a);mem0(cnt_h);mem0(len_a);mem0(len_h); int tot=0; for(int i=n-1;i&gt;=0;i--)&#123; tmp=query(a[i]+1,n); bg[i]=tmp.fi+1; g[i]=tmp.se; if(bg[i]==1)g[i]=1; if(bg[i]==L)tot=(tot+g[i])%mod; Update(a[i],bg[i],g[i],n); &#125; tot=qpow(tot,mod-2); for0(i,n)&#123; if(bg[i]+en[i]==L+1)&#123; out(1ll*h[i]*g[i]%mod*tot%mod); &#125;else out(0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>计蒜客</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>binary indexed tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6189]]></title>
    <url>%2F2019%2F06%2F12%2FHDU-6189%2F</url>
    <content type="text"><![CDATA[题意给出 $n(\le 30), a(1\le a\le 1e9)$ , 求在 $[1,2^n]$ 范围内有多少个 $b$ 能够满足 $a^{b} \equiv b^{a}(\bmod 2^n)$ 题解 https://blog.csdn.net/hyesuixin/article/details/77855821 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; int n,a; whiel(~in(n,a))&#123; int ta=a,k=0,maxn=1&lt;&lt;n; whiel(ta%2==0)&#123; k++; ta/=2; &#125; if(k&amp;&amp;n)&#123; itn kk=n/a; if(n%a)kk++; int ans=0; int low=n/k; if(n%k==0)low--; for1(i,low)&#123; if(qPow(a,i,maxn)==qPow(i,a,maxn))ans++; &#125; kk=1&lt;&lt;kk; ans+=(1&lt;&lt;n)/kk-low/kk; outln(ans); &#125;else &#123; puts("1"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1176D]]></title>
    <url>%2F2019%2F06%2F12%2FCF-1176D%2F</url>
    <content type="text"><![CDATA[题意 题解排序, 从大到小处理, 若当前最大的为素数, 那它一定是 $b$, 若当前最大数为合数, 那它一定是 $a$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d ",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld ",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3e6;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int Div[N];int prime[N],num_prime=0;void get_prime()&#123; for(int i=2;i&lt;N;i++)&#123; if(!Div[i]) &#123; prime[num_prime++]=i; Div[i]=-num_prime; &#125; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;N;j++)&#123; int k = i*prime[j]; Div[k] = i; if(i % prime[j] == 0) break; &#125; &#125;&#125;itn n,a[400005],cnt[N];int main() &#123; get_prime(); in(n); for0(i,2*n)&#123; in(a[i]); cnt[a[i]]++; &#125; sort(a,a+2*n); for(int i=2*n-1;i&gt;=0;i--)&#123; if(cnt[a[i]])&#123; if(Div[a[i]]&gt;0)&#123; out(a[i]); cnt[a[i]]--; cnt[Div[a[i]]]--; &#125;else&#123; int tmp=-Div[a[i]]; out(tmp); cnt[tmp]--; cnt[a[i]]--; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>number theory</tag>
        <tag>greedy</tag>
        <tag>sorting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客-数组]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%AE%A1%E8%92%9C%E5%AE%A2-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题意给出长度为 $N$ 的数组 $A$, 定义 f(l, r)=\max \left(\max \left(A_{l}, A_{l+1} \ldots A_{x}\right) \cdot(r-x+1) \cdot[l \leq x \leq r]\right)求 \sum_{i=1}^{n} \sum_{j=i}^{n} f(i, j) \bmod 10^{9}+7 题解从后往前枚举 $i$ , 用一个单调栈来存在固定 $i$ 的时候, $j\in[i,n]$ , 不同 $j$ 的 $x$ 的取值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int a,r,pre,i; //r 表示取 a 的 j 的区间的右端点 da(int _a,int _r,int _p,ll _i)&#123; a=_a; r=_r; pre=_p; i=_i; &#125; da()&#123;&#125;&#125;;stack&lt;da&gt;sta;ll fun(itn a,int l,int r)&#123; return (r-l+1ll)*(l+r)/2%mod*a%mod;&#125;int a[N];int main() &#123; itn n; ll ans=0; in(n); for1(i,n)&#123; in(a[i]); &#125; for(int i=n;i&gt;0;i--)&#123; ll r=n; whiel(sta.size())&#123; da tmp=sta.top(); if(tmp.a&lt;=a[i])&#123; sta.pop(); &#125;else&#123; ll p=(tmp.a*1ll*tmp.i-tmp.a+a[i]-a[i]*1ll*i)/(tmp.a-a[i]); if(p&gt;=tmp.r)&#123; sta.pop(); &#125;else&#123; r=p; break; &#125; &#125; &#125; // cout&lt;&lt;i&lt;&lt;' '&lt;&lt;r&lt;&lt;"\n"; assert(r&lt;=n); // assert(r&gt;=) int pre=0; if(sta.size())&#123; da tmp=sta.top(); // cout&lt;&lt;tmp.a&lt;&lt;' '&lt;&lt;tmp.i&lt;&lt;endl; pre=tmp.pre; // assert(r&gt;=tmp.i); pre=(pre+fun(tmp.a,r-tmp.i+2,tmp.r-tmp.i+1))%mod; &#125; // cout&lt;&lt;endl; sta.push(da(a[i],r,pre,i)); ans=(ans+pre+fun(a[i],1,r-i+1))%mod; &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>计蒜客</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1175D]]></title>
    <url>%2F2019%2F06%2F07%2FCF-1175D%2F</url>
    <content type="text"><![CDATA[Array Splitting题意将一个长度为 $n$ 的序列 $a_i$ 顺序不变的分为非空的 $k$ 部分, 设 $f(i)$ 表示 $a_i$ 在第 $f(i)$ 部分 求 $\sum\limits_{i=1}^na_i*f(i)$ 题解在 $[1,n]$ 中选 $k$ 个点 $b_i$ (其中一个为 1)将序列分为 $k$ 份, 答案为 $\sum\limits_{i=1}^ksuf[i]$ , $suf[i]$ 表示从 $i$ 开始的后缀和 所以直接对后缀排序, 取最大的 $k$ 个 代码1234567891011121314151617181920int a[N];ll suf[N];bool cmp(ll x,ll y)&#123; return x&gt;y;&#125;int main() &#123; int n,k; in(n,k); for0(i,n)in(a[i]); for(itn i=n-1;i&gt;=0;i--)&#123; suf[i]=suf[i+1]+a[i]; &#125; sort(suf+1,suf+n,cmp); ll ans=0; for0(i,k)&#123; ans+=suf[i]; &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1174E]]></title>
    <url>%2F2019%2F06%2F06%2FCF-1174E%2F</url>
    <content type="text"><![CDATA[Ehab and the Expected GCD Problem题意定义 $f(p)$ 表示 一个排列 $p$ 的 $g_1,g_2 \cdots g_n$ 的种类数, $g_i$ 表示该排列前 $i $ 个数的 $gcd$ $f_{max}(n)$ 表示 $n$ 的排列的最大 $f$ 值 给 $n$ 求 $f(p)=f_{max}(n)$ 的方案数 题解显然 要让 $f$ 最大, 排列的第一个数为 $2^k$ 或 $2^{k-1}3$ , 设 $dp[i][x][t]$ 表示前 $i$ 个数的 $gcd$ 为 $\large 2^{x} 3^y$ 的方案数 dp[i][x][y]=dp[i-1][x][y]*max(f[x][y]-i+1,0)+\\dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])+dp[i-1][x][y+1]*(f[x][y]-f[x][y+1]$f[x][y]$ 表示 $\Large \lfloor \frac n {2^x*3^y}\rfloor$ , 答案为 $dp[n][0][0]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int dp[N][21][3];int n;int f[21][3];int pp[N];int main() &#123; in(n); ll pre=1; for1(i,N)&#123; pre=pre*i%mod; pp[i]=pre; &#125; for0(i,21) for0(j,3)&#123; f[i][j]=n/((1&lt;&lt;i)*pow(3,j)); &#125; if(n&lt;4)&#123; if(n==2)puts("1"); else if(n==3)puts("4"); return 0; &#125; int k=0,tn=n; while(tn)&#123; tn/=2; k++; &#125; k--; dp[1][k][0]=1; if((1&lt;&lt;(k-1))*3&lt;=n)dp[1][k-1][1]=1; itn i,cnt; for(i=2;i&lt;=n;i++)&#123; itn x,y; cnt=0; for0(j,k)&#123; x=j; y=0; dp[i][x][y]=(1ll*dp[i-1][x][y]*max(f[x][y]-i+1,0)%mod+1ll*dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])%mod+1ll*dp[i-1][x][y+1]*(f[x][y]-f[x][y+1])%mod)%mod; if(dp[i][x][y])cnt++; y=1; dp[i][x][y]=(1ll*dp[i-1][x][y]*max(f[x][y]-i+1,0)%mod+1ll*dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])%mod+1ll*dp[i-1][x][y+1]*(f[x][y]-f[x][y+1])%mod)%mod; if(dp[i][x][y])cnt++; &#125; if(dp[i][0][0]&amp;&amp;cnt==1)break; &#125; // outln(i); outln(1ll*dp[i][0][0]*pp[n-i]%mod); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6284]]></title>
    <url>%2F2019%2F06%2F04%2FHDU-6284%2F</url>
    <content type="text"><![CDATA[Longest Increasing Subsequence题意有一个长度为 $n$ 的数组 $a(0\le a_i\le n)$ ,$f(x)$ 表示把 $0$ 变成 $x$ , 序列的 $LIS(严格递增)$ , 求$\sum\limits_{i=1}^ni\times f(i)$ 题解设 $bg[i], en[i]$ 分别表⽰以点 $i$ 开始、结束的 $LIS$ ⻓度，$L$ 是原来的 $LIS$ ⻓度。对于每个 $i$，找出它下⼀个 $0$ 后⾯的 $a[j]$ 满⾜ $en[i]+bg[j] = L$，那么当 $x$ 在 $[a[i] + 1, a[j] − 1]$ 的区间内时，答案是 $L + 1$. 从后往前扫, 用一个数组 $\text{max_r[i]}$ 记录扫过的最后一个 $0$ 右边区域的 $bg=i$ 的最大值 以 $0$ 为分隔, 用一个 $vector$ 存当前分块的 $ \text{max_r}$ 值, 当遇到下一个 $0$ 的时候更新 $\text{max_r}$ , 注意当 $bg=L$ 时要特殊考虑 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const int inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],bg[N],en[N],dp[N],fu[N],max_r[N];vector&lt;pii&gt; peding;int l_bound(int l,int r,int x)&#123; r--; whiel(l&lt;=r)&#123; int mid=(l+r)/2; if(dp[mid]&gt;x)l=mid+1; else r=mid-1; &#125; return l;&#125;int main() &#123; itn n; whiel(~in(n))&#123; int L=0; for1(i,n)in(a[i]); for1(i,n)max_r[i]=fu[i]=0; for1(i,n)&#123; if(a[i])&#123; if(L)&#123; if(a[i]&gt;dp[L-1])&#123; dp[L++]=a[i]; en[i]=L; &#125;else&#123; int p=lower_bound(dp,dp+L,a[i])-dp; dp[p]=min(dp[p],a[i]); en[i]=p+1; &#125; &#125;else&#123; dp[L++]=a[i]; en[i]=L; &#125; &#125; &#125; L=max(L,1); ll ans=(1ll+n)*n/2*L; L=0; for(itn i=n;i&gt;0;i--)&#123; if(a[i])&#123; if(L)&#123; if(a[i]&lt;dp[L-1])&#123; dp[L++]=a[i]; bg[i]=L; &#125;else&#123; int p=l_bound(0,L,a[i]); dp[p]=max(dp[p],a[i]); bg[i]=p+1; &#125; &#125;else&#123; dp[L++]=a[i]; bg[i]=L; &#125; &#125; &#125; max_r[0]=0; peding.clear(); for(itn i=n;i&gt;0;i--)&#123; if(a[i])&#123; if(max_r[L-en[i]]&gt;a[i])&#123; fu[a[i]+1]++; fu[max_r[L-en[i]]]--; &#125; peding.pu_b(pii(bg[i],a[i])); &#125;else&#123; max_r[0]=n+1; whiel(peding.size())&#123; pii kk=peding.back(); peding.po_b(); if(kk.fi==L)&#123; fu[1]++; fu[kk.se]--; &#125;else&#123; max_r[kk.fi]=max(max_r[kk.fi],kk.se); &#125; &#125; &#125; &#125; for1(i,n)&#123; fu[i]+=fu[i-1]; if(fu[i])ans+=i; &#125; outln(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1174D]]></title>
    <url>%2F2019%2F06%2F04%2FCF-1174D%2F</url>
    <content type="text"><![CDATA[Ehab and the Expected XOR Problem题意给 $n(1\le n\le 18),x(1\le x&lt;2^{18})$ , 构造一个数组 $a(1\le a_i&lt;2^n)$ , 使得这个数组的任意子段的异或和不为 0 或 $x$ 题解要使得这个数组的任意子段的异或和不为 0, 只需要保证数组的前缀和都不同就可以了. 假设 $A\text^B=x$ , 可以将 $[0,2^n-1]$ 分为两部分, 没部分里面的数两两异或都不为 $x$ 代码12345678910111213141516171819202122232425262728bool vis[N];vii v;int main() &#123; int n,x; in(n,x); int p=(1&lt;&lt;n); if(x&gt;=p)&#123; outln(p-1); for1(i,p-1)&#123; out(i^(i-1)); &#125; &#125;else&#123; p-=2; outln(p/2); v.pu_b(0); vis[x]=1; for1(i,p+1)&#123; if(vis[i]==0)&#123; v.pu_b(i); vis[i]=vis[i^x]=1; &#125; &#125; for1(i,(int)v.size()-1)&#123; out(v[i]^v[i-1]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>implementation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1148E]]></title>
    <url>%2F2019%2F06%2F04%2FCF-1148E%2F</url>
    <content type="text"><![CDATA[Earth Wind and Fire题意给两个长度为 $n$ 个数组 $a,b$, 如果 $a_i\le a_j$ 可以取一个 $d(0\le 2*d\le a_j-a_i)$ , 然后 $a_i+d,a_j-d$ , 问如何操作可以让 $a$ 变为 $b$ 题解对 $a,b$ 排序, 将 $a_i$ 变为 $b_i$, 用一个 $stack$ 维护 $a$ 中待加值的元素 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758pii a[N];int b[N];bool cmp(pii x,pii y)&#123; return x.fi&lt;y.fi;&#125;struct da&#123; int i,j,d; da(int q,int w,int e)&#123; i=q;j=w;d=e; &#125;&#125;;vector&lt;da&gt;v;stack&lt;int&gt;les;int main() &#123; int n; in(n); for1(i,n)&#123; in(a[i].fi); a[i].se=i; &#125; for1(i,n)in(b[i]); sort(a+1,a+1+n,cmp); sort(b+1,b+n+1); bool yes=1; for1(i,n)&#123; if(a[i].fi&gt;b[i])&#123; a[i].fi-=b[i]; while(a[i].fi&amp;&amp;les.size())&#123; int no=les.top(); les.pop(); int minn=min(a[no].fi,a[i].fi); if(a[no].fi&gt;a[i].fi)les.push(no); a[i].fi-=minn; a[no].fi-=minn; v.pu_b(da(a[no].se,a[i].se,minn)); &#125; if(a[i].fi)&#123; yes=0; break; &#125; &#125;else if(a[i].fi&lt;b[i])&#123; a[i].fi=b[i]-a[i].fi; les.push(i); &#125; &#125; if(les.size()==0&amp;&amp;yes)&#123; puts("YES"); assert(v.size()&lt;=5*n); outln((int)v.size()); for(auto i:v)&#123; printf("%d %d %d\n",i.i,i.j,i.d); &#125; &#125;else &#123; puts("NO"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6285]]></title>
    <url>%2F2019%2F06%2F03%2FHDU-6285%2F</url>
    <content type="text"><![CDATA[题意在一个 $n$ 个点的完全图中，第 $i$ 个点的权值为 $2^i$，选择一些边，需要选择一些点使得所有边至少有一个端点被覆盖，同时权值之和最小。在上述情况下，给出选择的点的权值和，问有多少种选择边的方案符合这种选点。 题解对于每一个选定的点, 总有一条边连着它和权值比它大的未被选的点, 设数量为 $cnt1$, 权值比它小的点可取可不取, 设数量为 $cnt2$, 则该点的贡献为 (2^{cnt1}-1)\times2^{cnt2}代码12345678910111213141516171819202122232425262728293031323334353637string s;ll f[N];ll fun(int a,int b)&#123; ll qq=(f[a]-1+mod)%mod; return qq*f[b]%mod;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,a,b; f[0]=1; for1(i,100005)&#123; f[i]=f[i-1]*2%mod; &#125; while(cin&gt;&gt;n&gt;&gt;s)&#123; a=b=0; ll ans=1; for(int i=0;i&lt;s.size();i++)&#123; if(s[i]=='1')a++; &#125; n-=s.size(); for(int i=s.size()-1,j=0;i&gt;=0;i--,j++)&#123; if(s[i]=='1')&#123; b++; ans=fun(n+i-a+b,j)*ans%mod; // cout&lt;&lt;n+i-a+b&lt;&lt;' '&lt;&lt;j&lt;&lt;endl; &#125; &#125; outln(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>combination</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018河北省省赛]]></title>
    <url>%2F2019%2F05%2F01%2F2018%E6%B2%B3%E5%8C%97%E7%9C%81%E7%9C%81%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[E. K Multiple Longest Commom Subsequence题意两个数组 $1\le k,n,m\le 1e3$, 问最长 $k$ 倍公共子序列是多少, $k$ 倍子序列指的是, 将子序列等分, 每份为 $k$ 个数, 且这 $k$ 个数相同. 如 $1,1,2,2$ 是一个 $2$ 倍子序列 题解$\text{pre_a[i]}$ 表示从 $i$ 开始往前数, 第 $k$ 个 $a[i]$ 的下标 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445int pre_a[N],pre_b[N];int t,k,n,m,x,a[N],b[N],cnt[N],dp[N][N];queue&lt;int&gt;que[N];int main() &#123; in(t); while(t--)&#123; in(k,n,m); mem0(pre_a); mem0(pre_b); for1(i,1000)while(que[i].size())que[i].pop(); for1(i,n)&#123; in(x); a[i]=x; que[x].push(i); if(que[x].size()==k)&#123; int qw=que[x].front(); que[x].pop(); pre_a[i]=qw; &#125; &#125; for1(i,1000)while(que[i].size())que[i].pop(); for1(i,m)&#123; in(x); b[i]=x; que[x].push(i); if(que[x].size()==k)&#123; int qw=que[x].front(); que[x].pop(); pre_b[i]=qw; &#125; &#125; mem0(dp); for1(i,n) for1(j,m)&#123; dp[i][j]=max(dp[i][j],max(dp[i-1][j],dp[i][j-1])); if(a[i]==b[j])&#123; if(pre_a[i]&amp;&amp;pre_b[j]) dp[i][j]=max(dp[i][j],dp[ pre_a[i]-1 ][ pre_b[j]-1 ]+1); &#125; &#125; outln(dp[n][m]*k); &#125; return 0;&#125; F. Defending Plan Support题意给一棵树, 每个点有权值 $\omega(i)$, 每条边有权值 $d(i,j)$, 找一个点 $x$ 使 $F(x)=\sum \omega(i)\times d(x,i)$ 最小 题解以 $1$ 为根节点画出这棵树, 设 $j$ 的父节点为 $i$, $tot=\sum\omega(i)$, $sum[i]$ 表示以 $i$ 为根节点的子树的权值和 F(j)=F(i)+d(i,j)\times(tot-2*sum[j])代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll dp[N],ans,tot;int sum[N],n,w[N],x,y,z;bool vis[N];vector&lt;pii&gt;v[N];int dfs(int rt,ll len)&#123; ans+=len*w[rt]; int tmp=w[rt]; for(auto i:v[rt])&#123; if(vis[i.fi]==0)&#123; vis[i.fi]=1; tmp+=dfs(i.fi,len+i.se); &#125; &#125; return sum[rt]=tmp;&#125;void dfs2(int rt)&#123; for(auto i:v[rt])&#123; if(vis[i.fi]==0)&#123; vis[i.fi]=1; dp[i.fi]=dp[rt]+i.se*tot-2ll*i.se*sum[i.fi]; ans=min(ans,dp[i.fi]); dfs2(i.fi); &#125; &#125;&#125;int main() &#123; in(n); for0(i,n-1)&#123; in(x,y,z); // tot+=z; v[x].pb(pii(y,z)); v[y].pb(pii(x,z)); &#125; for1(i,n)&#123; in(w[i]); tot+=w[i]; &#125; vis[1]=1; dfs(1,0); mem0(vis); vis[1]=1; dp[1]=ans; dfs2(1); outln(ans); return 0;&#125; K. Bitmap题意给一个 $n\times n(1 \leq n \leq 2000)$, 一个 $m\times m(1 \leq m \leq 1000,m\le n)$ 的矩阵, 值的范围为 $[0,255]$, 问 $A$ 中有几个 $B$, 只要每个元素相差一个定值就视为相同 题解hash, 枚举 $A$ 中 $B$ 的左上角 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e3;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;const int M=1.1e3;ull Pow[2][M],Hash[2][N][N],seed[2]=&#123;131,233&#125;,hash_b,hash2[M][M],offset;int a[N][N],b[M][M],n,m;void init()&#123; Pow[0][0]=Pow[1][0]=1; ull tmp[2]; tmp[0]=tmp[1]=0; for0(i,2) for1(j,m)&#123; Pow[i][j]=Pow[i][j-1]*seed[i]; tmp[i]+=Pow[i][j-1]; &#125; offset=tmp[0]*tmp[1]; for1(i,n) for1(j,n)&#123; Hash[0][i][j]=Hash[0][i][j-1]*seed[0]+a[i][j]; Hash[1][i][j]=Hash[1][i-1][j]*seed[1]+Hash[0][i][j]; &#125; for1(i,m)&#123; for1(j,m)hash2[i][j]=hash2[i][j-1]*seed[0]+b[i][j]; hash_b=hash_b*seed[1]+hash2[i][m]; &#125; hash_b-=b[1][1]*offset;&#125;ull get2(int x1,int y1,int x2,int y2)&#123; return Hash[1][x2][y2]-Hash[1][x1-1][y1]*Pow[1][m]; &#125;ull get(int x1,int y1,int x2,int y2)&#123; return get2(x1,y2,x2,y2)-get2(x1,y1-1,x2,y1-1)*Pow[0][m]-a[x1][y1]*offset;&#125;int main() &#123; in(n,m); for1(i,n) for1(j,n)in(a[i][j]); for1(i,m) for1(j,m)in(b[i][j]); init(); int ans=0; for(int i=1;i+m-1&lt;=n;i++) for(int j=1;j+m-1&lt;=n;j++)&#123; if(get(i,j,i+m-1,j+m-1)==hash_b)ans++; &#125; outln(ans); return 0;&#125; I. Beautiful Array题意长度为 $y$, 乘积为 $x$ 的序列的个数 如 $x=2,y=2$, $[1,2],[2,1],[-1,-2],[-2,-1]$ 题解分解 $x$, x=p_1^{a_1}*p_2^{a_2}\cdots p_m^{a_m}对方案数来说, 不同素因子是独立的, 对于 $p_i$, 其贡献相当于将 $a_i$ 个相同的球放进不同的盒子, 且允许有空, 为 \large C_{a_i+y-1}^{y-1}再考虑负数, 负号只能为偶数个, 其贡献为 \large C_y^0+C_y^2+C_y^4+\cdots=2^{y-1}代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;bool notPrime[N+1];int prime[N+1],num_prime=0;void get_prime()&#123; notPrime[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!notPrime[i]) prime[num_prime++]=i; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;=N;j++)&#123; int k = i*prime[j]; notPrime[k] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125;const int M =2.1e6;ll fac[M],inv[M];ll C(ll a,ll b)&#123; if(b&gt;a)return 0; return fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;void init()&#123;//快速计算阶乘的逆元 fac[0]=fac[1]=1; for(int i=2;i&lt;M;i++)fac[i]=fac[i-1]*i%mod; inv[M-1] = qPow(fac[M-1], mod - 2, mod); for (int i = M - 2; i &gt;= 0; i--) inv[i] = (inv[i + 1] * (i + 1)) % mod;&#125;int main() &#123; int t,x,y; in(t); get_prime(); init(); while(t--)&#123; in(x,y); if(y==0)&#123; puts("0"); continue; &#125;else if(x==0)&#123; puts("1"); continue; &#125; ll ans=1; for(int i=0;i&lt;num_prime&amp;&amp;x!=1;i++)&#123; if(x%prime[i]==0)&#123; int cnt=0; while(x%prime[i]==0)&#123; x/=prime[i]; cnt++; &#125; ans=ans*C(cnt+y-1,y-1)%mod; &#125; &#125; if(x!=1)ans=ans*y%mod; ans=ans*qPow(2,y-1,mod)%mod; outln(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccpc</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>hash</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邮局]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%82%AE%E5%B1%80%2F</url>
    <content type="text"><![CDATA[题意$n(1\le n\le50)$ 个人, $m(1\le m \le 25)$ 个车站, 选 $k(1\le k\le 10)$ 个车站, 每个人去离他最近的车站, 输出路径和最短的方案. 题解搜索剪枝, 从后往前搜索, 若对于当前状态, 某一点无法对任意一个人松弛, 就标记这个点, 之后的搜索都不再访问. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;// int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int n,m,k;struct point&#123; int x,y,no;&#125;people[55],mail[33];db G[55][33];point result[11],tmp_res[11];db ans=1e18,sum,min_dis[55];bool Not[33];db get_dis(point a,point b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;void dfs(int depth,int index)&#123; if(depth==k)&#123; if(sum&lt;ans)&#123; ans=sum; for0(i,k)result[i]=tmp_res[i]; &#125; &#125;else&#123; db tmp[55],tsum=sum; bool flag2=0;//标记 [index,m-k+depth] 这些点里有没有能够至少松弛一个人的点 for0(i,n)tmp[i]=min_dis[i]; for(int i=m-k+depth;i&gt;=index;i--)&#123; //当前已经取了 depth 个, 为了保证能够取得 k 个,所以我们最多取到 m-k+depth 点, 从这一点开始往前搜索 if(Not[i])continue; bool flag=0;//标记 i 是否能够至少松弛一个人 if(depth==0)&#123; sum=0; for0(j,n)&#123; min_dis[j]=G[j][i]; sum+=min_dis[j]; &#125; flag=1; &#125;else&#123; // for0(j,n)min_dis[j]=tmp[j]; sum=tsum; for0(j,n)&#123; if(G[j][i]&lt;tmp[j])&#123; sum-=tmp[j]-G[j][i]; min_dis[j]=G[j][i]; flag=1; &#125;else min_dis[j]=tmp[j]; &#125; &#125; if(flag)&#123; tmp_res[depth]=mail[i]; dfs(depth+1,i+1); flag2=1; &#125;else&#123; Not[i]=1; &#125; &#125; if(!flag2)&#123;//若 [index,m-k+depth] 这些点里没有能够松弛的, 就取 m-k+depth tmp_res[depth]=mail[m-k+depth+1]; dfs(depth+1,m-k+depth+1); &#125;else&#123; for0(j,n)min_dis[j]=tmp[j]; sum=tsum; &#125; &#125;&#125;int main() &#123; in(n,m,k); for0(i,n)&#123; in(people[i].x,people[i].y); &#125; for0(i,m)&#123; in(mail[i].x,mail[i].y); mail[i].no=i+1; for0(j,n)&#123; G[j][i]=get_dis(people[j],mail[i]); &#125; &#125; dfs(0,0); for0(i,k)printf("%d ",result[i].no); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[农场阳光]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%86%9C%E5%9C%BA%E9%98%B3%E5%85%89%2F</url>
    <content type="text"><![CDATA[题意求多个圆和一个矩形的面积并 题解使用自适应 Simpson 求解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;db g;int n,a,b;struct circle&#123; db x,y,r; circle()&#123;&#125; circle(int a,int b,int c,int d)&#123; x=a+c/tan(g); y=b; r=d; &#125;&#125;cir_set[N];struct seg&#123; db top,bottom; seg()&#123;&#125; seg(db a,db b)&#123; top=a; bottom=b; &#125;&#125;;bool cmp(seg x,seg y)&#123; return x.bottom&lt;y.bottom;&#125;db F(db x)&#123; vector&lt;seg&gt;v; for0(i,n)&#123; circle ci=cir_set[i]; if(fabs(x-ci.x)&lt;ci.r)&#123; db h=sqrt(ci.r*ci.r-(x-ci.x)*(x-ci.x)); v.pb(seg(ci.y+h,ci.y-h)); &#125; &#125; if(v.size()==0)return b; v.pb(seg(0,b)); sort(v.begin(),v.end(),cmp); db sta=0,ans=0; for0(i,v.size())&#123; seg se=v[i]; if(se.bottom&gt;sta)&#123; ans+=se.bottom-sta; &#125; sta=max(sta,se.top); if(sta&gt;=b)break; &#125; return ans;&#125;// 2db calc(db len,db fL,db fM,db fR)&#123; //求长度为len的[L,R]区间，中点为M的Simpson近似面积 return (fL+4*fM+fR)*len/6;&#125;db Simpson(db L,db R) &#123;//Simpson积分求区间[L,R]的面积并,F(L)=L,F(R)=R,F(M)=M,把[L,R]当成整体来拟合得到的面积是sqr db M=(L+R)/2,fL=F(L),fM=F(M),fR=F(R),sqr=calc(R-L,fL,fM,fR); db g1=calc(M-L,fL,F((L+M)/2),fM),g2=calc(R-M,fM,F((M+R)/2),fR); if(fabs(sqr-g1-g2)&lt;=eps) //把当前区间分成2半再拟合得到的答案差别很小，就不再递归下去了 return g1+g2; return Simpson(L,M)+Simpson(M,R);&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); scanf("%d%d%Lf%d",&amp;a,&amp;b,&amp;g,&amp;n); g=g*pi/180; for0(i,n)&#123; int x,y,z,r; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;r); cir_set[i]=circle(x,y,z,r); // cout&lt;&lt;cir_set[i].x&lt;&lt;' '&lt;&lt;cir_set[i].y&lt;&lt;' '&lt;&lt;cir_set[i].r&lt;&lt;endl; &#125; printf("%.2Lf\n",Simpson(0,a)); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1151]]></title>
    <url>%2F2019%2F04%2F22%2FCF-1151%2F</url>
    <content type="text"><![CDATA[E. Number of Components题意一条链, 每个点的权值为 $a_i(1\le a_i\le n)$ , $f(l,r)$ 表示仅保留权值在 $[l,r]$ 之间的点的联通分量 求 \sum\limits_{l=1}^{n} \sum\limits_{r=l}^{n} f(l, r) 题解统计每个点的贡献, 只有当取 $a_i$ 不取 $a_{i+1}$ 时, $a_i$ 才有贡献 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x; ll pre; in(n); ll ans=0; in(pre); ans+=pre*(n+1-pre); for0(i,n-1)&#123; in(x); if(x&gt;pre)&#123; ans+=(x-pre)*(n+1-x); pre=x; &#125;else if(x&lt;pre)&#123; ans+=(pre-x)*x; pre=x; &#125; &#125; outln(ans); return 0;&#125; F. Sonya and Informatics题意数组 $a$ 有 $n$ 个数, 这些数由 $0,1$ 构成, 等概率交换任意两个数的位置, 问最后得到一个不下降的数列的概率, 答案对 $1e9+7$ 取模 题解设 $x$ 表示 $0$ 的个数, $dp[i][j]$ 表示操作 $i$ 次后前 $x$ 个数中 $0$ 的个数为 $j$ 的概率, 答案为 $dp[k][x]$ 可以发现状态转移方程与 $i$ 无关, 可以用矩阵快速幂做 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[110];ll matrix[110][110];ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int n,k,x=0,xx=0;void fun(ll c[110][110],ll b[110][110])&#123; ll tmp[110][110]; mem0(tmp); for0(i,x+1) for0(j,x+1) for0(k,x+1)tmp[i][j]=(tmp[i][j]+c[i][k]*b[k][j])%mod; memcp(c,tmp);&#125;ll Com(ll a)&#123; if(a&lt;2)return 0; return a*(a-1)/2;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // cout&lt;&lt;qPow(3,mod-2,mod)&lt;&lt;endl; in(n,k); ll C=n*(n-1)/2,inv_C=qPow(C,mod-2,mod); inv_C=qPow(inv_C,k,mod); for1(i,n)&#123; in(a[i]); if(!a[i])x++; &#125; ll A=Com(x),B=Com(n-x); for1(i,x)if(!a[i])xx++; int minn=max(0,2*x-n); // cout&lt;&lt;x&lt;&lt;' '&lt;&lt;xx&lt;&lt;' '&lt;&lt;minn&lt;&lt;endl; forl(i,minn,x)&#123; int p1=0,p2=0; if(i-1&gt;=minn)&#123; matrix[i-1][i]=p1=(x-i+1)*(x-i+1); &#125; if(i+1&lt;=x)&#123; matrix[i+1][i]=p2=(i+1)*(n-2*x+i+1); &#125; matrix[i][i]=A+B+i*(x-i)+(n-2*x+i)*(x-i); &#125; ll an[110][110]; for0(i,x+1)an[i][i]=1; while(k)&#123; if(k&amp;1)fun(an,matrix); fun(matrix,matrix); k&gt;&gt;=1; &#125; outln(an[xx][x]*inv_C%mod); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[填字母游戏]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%A1%AB%E5%AD%97%E6%AF%8D%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题意一个 $1*N$ 个格子, 上面已有一些 L 和 O, 两人博弈, 谁先拼出 LOL 谁获胜, 空格数&lt;14 题解状态标记搜索 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.6e6;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int ans[N];ll pow3[23];bool iskong[23];// int wei[23];int len;// int cnt;int fun(ll status)&#123; // cnt++; int ans_status=0; ll tmp_sta=status; int *wei=new int[23]; bool have0=0; for0(i,len)&#123; int flag=tmp_sta%3; wei[i]=flag; if(flag==0)have0=1; if(iskong[i])&#123; ans_status*=3; ans_status+=flag; &#125; tmp_sta/=3; &#125; if(ans[ans_status]&lt;inf)&#123; delete [] wei; return ans[ans_status]; &#125; for(int i=0;i+2&lt;len;i++)&#123; if(wei[i]==1&amp;&amp;wei[i+1]==2&amp;&amp;wei[i+2]==1)&#123; delete [] wei; return ans[ans_status]=-1; &#125; &#125; if(!have0)&#123; delete [] wei; return ans[ans_status]=0; &#125; // if(x.find("LOL") != -1)return -1; // if(x.find("*") == -1)return 0; int res = -1; delete [] wei; // delete tmp_sta; tmp_sta=status; for0(i,len)&#123; int flag=tmp_sta%3; if(flag==0)&#123; res = max(res,-fun(status+pow3[i])); res = max(res,-fun(status+2*pow3[i])); if(res==1)break; &#125; tmp_sta/=3; &#125; // for(int i = 0;x[i];i++) // if(x[i] == '*')&#123; // x[i] = 'L'; // res = max(res,-fun(x)); // if(res == 1)return x[i] = '*',1; // x[i] = 'O'; // res = max(res,-fun(x)); // x[i] = '*'; // &#125; return ans[ans_status]=res;&#125;int main()&#123; // clock_t wei=clock(); int t; in(t); char s[23]; pow3[0]=1; for1(i,22)&#123; pow3[i]=pow3[i-1]*3; &#125; while(t--)&#123; // cnt=0; meminf(ans); mem0(iskong); in(s); // cout&lt;&lt;s&lt;&lt;endl; ll tmp=0; len=strlen(s); assert(len&lt;23); // cout&lt;&lt;len&lt;&lt;endl; for0(i,len)&#123; tmp*=3; if(s[i]=='L')tmp+=1; else if(s[i]=='O')tmp+=2; else iskong[len-i-1]=1; &#125; outln(fun(tmp)); // outln(cnt); &#125; // printf("%lu\n",clock()-wei); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1154]]></title>
    <url>%2F2019%2F04%2F19%2FCF-1154%2F</url>
    <content type="text"><![CDATA[E. Two Teams题意一个 $1\sim n$ 的排列, 从大到小删数, 当删一个数时将其左右的 $k$ 个数也删了, 若某个数是第奇数次删的输出 1, 否则输出 2 题解维护两个数组 $l[i],r[i] $ 分别表示第 $i$ 个数左边, 右边的数所在的地方 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int l[N],r[N],Map[N],ans[N],a[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,k; in(n,k); for1(i,n)&#123; in(a[i]); Map[a[i]]=i; l[i]=i-1; r[i]=i+1; &#125; int flag=-1; for(int i=n;i&gt;=1;i--)&#123; if(Map[i])&#123; int poi=Map[i],ml=poi,mr=poi; for(int i=poi,j=0;i&lt;=n&amp;&amp;j&lt;=k;j++,mr=i=r[i])&#123; ans[i]=flag; Map[a[i]]=0; &#125; ml=poi=l[poi]; for(int i=poi,j=0;i&lt;=n&amp;&amp;j&lt;k;j++,ml=i=l[i])&#123; ans[i]=flag; Map[a[i]]=0; &#125; r[ml]=mr; l[mr]=ml; if(flag==-1)flag=-2; else flag=-1; &#125; &#125; for1(i,n)out(-ans[i]); puts(""); return 0;&#125; F. Shovels Shop题意$n$ 个物品, 其价格分别为 $a_i$ , 有 $m$ 种折扣, 买 $x_i$ 件物品, 便宜的 $y_i$ 件免费, 买 $k(\le 2000)$ 件的最小花费 题解$dp[i]$ 表示买 $i$ 件物品的最小花费 $dp[i]=min(dp[i-1]+a[i],dp[i-j]+pre[i]-pre[ i-cost[j] ])$ $cost[i]$ 表示买 $i$ 件物品最小需要支付的物品数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],dp[2003],cost[2003],pre[2003];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,k,x,y; meminf(cost); in(n,m,k); for1(i,n)in(a[i]); for0(i,m)&#123; in(x,y); if(x&lt;2001) cost[x]=min(cost[x],x-y); &#125; sort(a+1,a+n+1); for1(i,k)pre[i]=pre[i-1]+a[i]; for1(i,k)&#123; dp[i]=dp[i-1]+a[i]; for1(j,i) if(cost[j]&lt;inf) dp[i]=min(dp[i],dp[i-j]+pre[i]-pre[i-cost[j]]); &#125; outln(dp[k]); return 0;&#125; G. Minimum Possible LCM题意给 $n(2\le n \le 1e6)$ 个数, 求最大的 $lcm(a_i,a_j) (1\le a_i\le 1e7)$ 题解枚举 $gcd(a_i,a_j)$ , 找到最小的 $a_i, a_j$ 时间复杂度 $O(\frac {10^7}1+\frac {10^7}2+\frac {10^7}3+\cdots+\frac {10^7}{10^7})\approx O(10^7log(10^7))$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e7;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N][3];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x,maxx=0; in(n); for1(i,n)&#123; in(x); maxx=max(maxx,x); if(a[x][0]==0)&#123; a[x][1]=i; a[x][0]=1; &#125;else if(a[x][0]==1)&#123; a[x][2]=i; a[x][0]=2; &#125; &#125; ll minn=1e18; pii ans; for1(g,maxx)&#123; ll x1=0; for(int j=g;j&lt;=maxx;j+=g)&#123; if(x1)&#123; if(a[j][0])&#123; if(x1*j/g&lt;minn)&#123; ans=pii(a[x1][1],a[j][1]); minn=x1*j/g; &#125; break; &#125; &#125;else&#123; if(a[j][0]==1)&#123; x1=j; &#125;else if(a[j][0]==2)&#123; x1=j; if(x1*x1/g&lt;minn)&#123; ans=pii(a[x1][1],a[j][2]); minn=x1*j/g; &#125; break; &#125; &#125; &#125; &#125; if(ans.fi&gt;ans.se)swap(ans.fi,ans.se); printf("%d %d\n",ans.fi,ans.se); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-ACM-ICPC-Asia-Shenyang]]></title>
    <url>%2F2019%2F04%2F14%2F2017ICPC-Shenyang%2F</url>
    <content type="text"><![CDATA[A. BBP Formula题意 \pi=\sum_{k=0}^{\infty}\frac 1 {16^k}\left( \frac 4 {8k+1}-\frac 2 {8k+4}-\frac 1 {8k+5}-\frac 1 {8k+6}\right)求 $\pi$ 十六进制表达的小数点后第 $n$ 位. 题解求十进制小数的十六进制形式, 去掉整数部分, 小数部分乘 16 得到的数的整数部分就是小数点后第一位的十六进制值, 以此类推. 16^n\sum_{k=0}^{\infty}\frac 1 {16^k} \frac 4 {8k+1} =\sum_{k=0}^{n}\frac {4*16^{n-k}\%(8k+1)} {8k+1}+\sum_{k=n+1}^{\infty}\frac 4 {16^{k-n}(8k+1)}代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int n;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;db fun(int a,int b)&#123; db ans=0; for0(i,n+1)&#123; ll w=a*qPow(16,n-i,8*i+b)%(8*i+b); ans+=(db)w/(8*i+b); &#125; ll ppow=1; for1(i,15)&#123; ppow*=16; // cout&lt;&lt;ppow&lt;&lt;endl; ans+=(db)a/ppow/(8*(i+n)+b); &#125; return ans;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; in(t); for1(ca,t)&#123; in(n); n--; db ans=fun(4,1)-fun(2,4)-fun(1,5)-fun(1,6); // cout&lt;&lt;ans&lt;&lt;endl; while(ans&lt;0)ans++; while(ans&gt;1)ans--; // cout&lt;&lt;ans&lt;&lt;endl; int k=ans*16; // cout&lt;&lt;k&lt;&lt;endl; if(k&gt;=10)printf("Case #%d: %d %c\n",ca,n+1,k-10+'A'); else printf("Case #%d: %d %d\n",ca,n+1,k); &#125; return 0;&#125; F. Heron and His Triangle题意设三角形的三条边为 $t-1,t,t+1$ ，给一个 $n(1\le n\le 1e30)$ ，求大于 $n$ 且三角形面积为整数的最小 $t$ 题解由海伦公式得 S=\sqrt {p(p-a)(p-b)(p-c)}\ ,p=\frac {a+b+c}2\\ S=\frac t 2\sqrt {3\left(\left(\frac t 2\right)^2-1\right)}\\ assume\qquad x=\frac t 2\\ x^2-3y^2=1\\ x_n=4x_{n-1}-x_{n-2}代码123456789101112131415161718192021222324252627282930import java.io.*;import java.util.*;import java.math.*; public class Main&#123; public static void main(String[] args) throws IOException&#123; Scanner sc =new Scanner(System.in); int t; t = sc.nextInt(); BigInteger n,maxn=new BigInteger("1000000000000000000000000000000"); Vector&lt;BigInteger&gt;v = new Vector&lt;&gt;(); v.add(BigInteger.valueOf(4)); v.add(BigInteger.valueOf(14)); while(v.lastElement().compareTo(maxn)==-1) &#123; int qq = v.size(); v.add(v.elementAt(qq-1).multiply(BigInteger.valueOf(4)).subtract(v.elementAt(qq-2))); &#125; while(t--!=0) &#123; n=sc.nextBigInteger(); for(Iterator&lt;BigInteger&gt; iter = v.iterator();iter.hasNext();) &#123; BigInteger tmp=iter.next(); if(tmp.compareTo(n)&gt;=0) &#123; System.out.println(tmp); break; &#125; &#125; &#125; sc.close(); &#125;&#125;]]></content>
      <categories>
        <category>icpc</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1144]]></title>
    <url>%2F2019%2F04%2F01%2FCF-1144%2F</url>
    <content type="text"><![CDATA[F. Graph Without Long Directed Paths题意一个严格递增的数列, 一个严格递减的数列, 将它们保持原相对顺序不变合并在一起. 给出合并后的数列. 题解1 (greedy)维护一个递增数列 A, 一个递减的数列 B, 当只能插入一个数列的时候插入对应数列, 当两个都不能插入时输出”NO”, 当两个都能插入时, 若下一个数大于当前数, 插入 A, 否则插入 B. 题解2 (dp)$dp[ i ][ 0 ]$表示处理完前 $i$ 个， 第 $i$ 个是递增序列序列里的元素，递减序列的最大值。 $dp[ i ][ 1 ]$表示处理完前 $i$ 个， 第 $i$ 个是递减序列序列里的元素，递增序列的最小值。 https://www.cnblogs.com/CJLHY/p/10634175.html 代码123456789101112131415161718192021222324252627282930313233343536373839int a[N],flag[N];vii Inc,Dec;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; in(n); for0(i,n)in(a[i]); Inc.pb(-1); Dec.pb(3e5); for0(i,n)&#123; if(Inc.back()&gt;=a[i]&amp;&amp;Dec.back()&lt;=a[i])&#123; puts("NO"); return 0; &#125; if(Inc.back()&gt;=a[i])&#123; flag[i]=1; Dec.pb(a[i]); continue; &#125; if(Dec.back()&lt;=a[i])&#123; Inc.pb(a[i]); continue; &#125; if(a[i+1]&gt;a[i])&#123; Inc.pb(a[i]); &#125;else &#123; flag[i]=1; Dec.pb(a[i]); &#125; &#125; puts("YES"); for0(i,n)printf("%d ",flag[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>data structure</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1139]]></title>
    <url>%2F2019%2F03%2F30%2FCF-1139%2F</url>
    <content type="text"><![CDATA[D. Steps to One题意每次从$1\sim m$从等概率的选择一个数, 直到所有选择的数的 gcd 为 1, 问操作的次数的期望是多少? 题解1设$f[n]​$表示当前 gcd 为 n 还需要的步数的期望 f[n]=1+\frac {\sum\limits_{i=1}^mf[gcd(i,n)]} m\\ \sum\limits_{i=1}^mf[gcd(i,n)]=\sum\limits_{d|n}f[d]\sum\limits_{i=1}^me[gcd(i,n)==d]\\ \sum\limits_{i=1}^me[gcd(i,n)==d]=\sum\limits_{i=1}^{\lfloor \frac m d\rfloor}\epsilon[gcd(i,\frac n d)] \\=\sum\limits_{i=1}^{\lfloor \frac m d\rfloor}\sum\limits_{t|gcd(i,\frac n d)}\mu(t)=\sum\limits_{t|\frac n d}\mu(t)\lfloor \frac m {dt}\rfloor\\ 接下来把右边f[n]的项提出来\\ (m-\lfloor\frac m n\rfloor)f[n]=m+\sum\limits_{d|n,d\ne n}f[d]\sum\limits_{t|\frac n d}\mu(t)\lfloor \frac m {dt}\rfloor\\ ans=1+\frac {\sum\limits_{i=1}^mf[i]} m题解2设$E[n|i]$表示 gcd 为 n 的倍数的期望步数 k=\lfloor\frac m n\rfloor\\ E[n|i]=\sum\limits_{j=1}^{\infty}j*\frac {k^j} {m^j}=\frac {\frac k m} {1-\frac k m}=\frac k {m-k}\\ ans=1+E[i>1]=1+\sum_{j=2}^m-\mu(j)E[j|i]代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//解1int f[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m; cin&gt;&gt;m; for1(i,m)&#123; for(int j=1;j*j&lt;=i;j++)&#123; if(i%j==0)&#123; if(i/j==j)&#123; fac[i].pb(j); &#125;else&#123; fac[i].pb(j); fac[i].pb(i/j); &#125; &#125; &#125; &#125; get_prime(); f[1]=0; ll tot=0; forl(n,2,m)&#123; ll t_tmp=m; for0(j,fac[n].size())&#123; ll d=fac[n][j]; if(d==n)continue; ll cnt=0; for0(k,fac[n/d].size())&#123; int t=fac[n/d][k]; cnt=(cnt+(ll)mu[t]*(m/d/t)%mod)%mod; &#125; t_tmp=(t_tmp+f[d]*cnt%mod)%mod; &#125; f[n]=t_tmp*qPow(m-m/n,mod-2,mod)%mod; tot=(tot+f[n])%mod; // cout&lt;&lt;f[n]&lt;&lt;endl; &#125; printf("%lld\n",(tot*qPow(m,mod-2,mod)%mod+1)%mod); return 0;&#125;//解2bool notPrime[N+1];int prime[N+1],num_prime=0,mu[N+1];void get_prime()&#123; notPrime[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!notPrime[i]) &#123; prime[num_prime++]=i; mu[i]=1; &#125; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;=N;j++)&#123; int k = i*prime[j]; notPrime[k] = 1; if(i % prime[j] == 0)break; else mu[k]=mod-mu[i]; &#125; &#125;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=ans*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return ans;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m; in(m); get_prime(); ll ans=1; forl(i,2,m)&#123; ll k=m/i; ans=(ans+mu[i]*k%mod*qpow(m-k,mod-2)%mod)%mod; &#125; printf("%lld\n",ans); return 0;&#125; 引用 https://www.cnblogs.com/zyt1253679098/p/10584706.htmlhttps://blog.csdn.net/neuq_zsmj/article/details/88830388]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>math</tag>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-883]]></title>
    <url>%2F2019%2F03%2F27%2FCF-883%2F</url>
    <content type="text"><![CDATA[I. Photo Processing题意将 n 个数分堆，要保证每堆不少于 k 个数，每堆的值为这堆数中的最大值减去最小值，取这些值中的最大值，要是这个最大值最小。 题解二分答案，$dp$ 判断是否可行。$dp[i]$ 表示将 $1\sim i$ 划分成满足条件的区间，能划分最远的地方。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],n,k,dp[N];bool check(int x)&#123; int last=0; forl(i,k,n)&#123; int j=dp[i-k]; if(a[i]-a[j+1]&lt;=x)last=i; dp[i]=last; &#125; return dp[n]==n;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(n,k); for1(i,n)in(a[i]); sort(a+1,a+1+n); int l=0,r=1e9,mid; while(l&lt;=r)&#123; mid=(l+r)/2; if(check(mid))r=mid-1; else l=mid+1; &#125; printf("%d\n",l); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包子凑数]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题意给 $n(1\le n\le 100)$ 个数$(1\le a_i\le 100)$，问由它们不能组合(加法)成的数(正整数)的个数，若有无穷个输出”INF”。 题解若它们的公共 gcd 不为1，输出 INF，构造一个小顶堆，每次新加的值为堆顶的值加$a_i$ ，弹出堆顶，可证最大不可表示的值不会超过1e4，所以当堆顶大于1e4的时候跳出循环。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;priority_queue&lt;int,vii,greater&lt;int&gt; &gt;que;bool vis[11000];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,a[110]; mem0(vis); in(n); fro0(i,n)in(a[i]); if(n==1)&#123; if(a[0]==1)puts("0"); else puts("INF"); &#125;else&#123; int gc=a[0]; for1(i,n-1)gc=gcd(gc,a[i]); if(gc==1)&#123; int ans=0; sort(a,a+n); fro0(i,n)&#123; vis[a[i]]=1; que.push(a[i]); &#125; while(1)&#123; int to=que.top(); que.pop(); if(to&gt;=1e4)break; fro0(i,n)&#123; int now=to+a[i]; if(now&lt;=1e4&amp;&amp;vis[now]==0)&#123; vis[now]=1; que.push(now); &#125; &#125; &#125; for1(i,1e4)if(!vis[i])ans++; printf("%d\n",ans); &#125;else puts("INF"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小朋友排队]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%8E%92%E9%98%9F%2F</url>
    <content type="text"><![CDATA[题意n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。 题解每个人的不高兴度为它的逆序对数(在它前面大于它的，在它后面小于它的)，使用树状数组从前从后分别跑一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int h,no,cnt; da()&#123;&#125; da(int a,int b)&#123; h=a; no=b; cnt=0; &#125; oper(da)&#123; if(h==y.h)return no&lt;y.no; else return h&lt;y.h; &#125;&#125;a[N];int b[N],n,h;;itn lowbit(int x)&#123; return x&amp;(-x);&#125;int add(int x)&#123; int tmp=0; for(int i=x;i;i-=lowbit(i))&#123; tmp+=b[i]; &#125; for(itn i=x;i&lt;=n;i+=lowbit(i))&#123; b[i]++; &#125; return tmp;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(n); fro0(i,n)&#123; in(h); a[i]=da(h,i+1); &#125; sort(a,a+n); ll ans=0; fro0(i,n)&#123; a[i].cnt+=i-add(a[i].no); &#125; mem0(b); forr(i,n-1,0)&#123; a[i].cnt+=add(a[i].no); ans+=(ll)a[i].cnt*(a[i].cnt+1)/2; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>binary indexed tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[波动数列]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%B3%A2%E5%8A%A8%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题意长度为 n 和为 s 而且后一项总是比前一项增加 a 或者减少 b 的整数数列可能有多少种。$1&lt;=n&lt;=1e3，-1e9&lt;=s&lt;=1e9，1&lt;=a, b&lt;=1e6$ 题解设数列首项为$a_1$，增量为$d_1,d_2,\cdots,d_{n-1}$，则$\large na_1+\sum\limits_{i=1}^{n-1}(n-i-1)d_i=s$因为$a_1$可以取任意值，所以$\large \sum\limits_{i=1}^{n-1}(n-i-1)d_i\equiv s (mod n)$$dp[i][j]$表示长度为$i$，$\large \sum\limits_{k=1}^{i-1}(n-k-1)d_k mod n=j$ 的方案数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e8+7;const int N = 1.1e3;const db eps = 1e-8;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;ll dp[N][N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,s,a,b,nxt; in(n,s,a,b); s=(s%n+n)%n,a%=n,b%=n; dp[1][0]=1; for1(i,n-1)&#123; for0(j,n)&#123; nxt=(j+a*(n-i)%n)%n; dp[i+1][nxt]=(dp[i+1][nxt]+dp[i][j])%mod; nxt=(j-b*(n-i)%n+n)%n; dp[i+1][nxt]=(dp[i+1][nxt]+dp[i][j])%mod; &#125; &#125; printf("%lld\n",dp[n][s]); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁感冒]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%9A%82%E8%9A%81%E6%84%9F%E5%86%92%2F</url>
    <content type="text"><![CDATA[题意长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。 题解首先明白两只蚂蚁碰撞之后掉头和穿行过去是一样的，可以把穿行看做碰撞后掉头了，然后两个蚂蚁交换了，而是哪一只蚂蚁对结果不影响。那么，假如第一只感冒蚂蚁向右走，那么碰到所有想左走的都会被感染，而感染后的蚂蚁必定是向左走的，那么他会把左边向右走的都感染了。向左走的也是这样。所以 ans = 左边向右走的 + 右边向左走的 + 1（本身）。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int num; bool kind; da()&#123;&#125; da (int a,bool b)&#123; num=a; kind=b; &#125; bool operator &lt;(const da y)const&#123; return num&lt;y.num; &#125;&#125;a[55];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x; ind(n); for0(i,n)&#123; ind(x); if(x&lt;0)&#123; a[i]=da(-x,0); &#125;else a[i]=da(x,1); &#125; x=a[0].num; bool flag=a[0].kind,right=0; sort(a,a+n); int l=0,r=0; for0(i,n)&#123; if(a[i].num==x)&#123; right=1; continue; &#125; if(right&amp;&amp;a[i].kind==0)&#123; r++; &#125;else if(!right&amp;&amp;a[i].kind)&#123; l++; &#125; &#125; int ans=1; if(l&amp;&amp;r)ans+=l+r; else if(flag)&#123; ans+=r; &#125;else ans+=l; printf("%d\n",ans); return 0;&#125; 引用https://blog.csdn.net/y990041769/article/details/21941711]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>similar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-11]]></title>
    <url>%2F2019%2F03%2F22%2FCF-11%2F</url>
    <content type="text"><![CDATA[D. A Simple Task题意求出一个n个点m个边的图，求简单环有多少（没有重复点和边）。（n&lt;20） 题解用S能记录状态（有多少个点在路径中），那么如何找环能确保不重不漏啦，对于一个环，找出他的特异性记录，一个环，如果以最小点为环的“起始点”，则每个环都被记录啦两次。用dp[s][i]表示路径s的当前点为i的次数，枚举下一点，如果形成环就加上答案，否则记录下一边。由于题目求的是超过三个点的简单环，而之前所求两个点也会被记录。减掉就可以啦。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(25)using namespace std;ll dp[1&lt;&lt;19][N];int n,m;bool a[N][N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); scanf("%d%d",&amp;n,&amp;m); int u,v; ll ans=0; for0(i,m)&#123; scanf("%d%d",&amp;u,&amp;v); u--;v--; a[u][v]=a[v][u]=1; &#125; for0(i,n)dp[1&lt;&lt;i][i]=1; for(int i=1;i&lt;1&lt;&lt;n;i++)&#123; int st; for0(k,n) if(i&amp;(1&lt;&lt;k))&#123; st=k; break; &#125; for(int k=st+1;k&lt;n;k++)&#123; if(dp[i][k]==0)continue; if(a[k][st]&amp;&amp;__builtin_popcount(i)&gt;2)ans+=dp[i][k]; &#125; for(int j=st;j&lt;n;j++)&#123; if(dp[i][j]==0)continue; for(int k=st+1;k&lt;n;k++) if(a[j][k]&amp;&amp;!(i&amp;(1&lt;&lt;k)))dp[i+(1&lt;&lt;k)][k]+=dp[i][j]; &#125; &#125; printf("%lld\n",ans/2); return 0;&#125; 引用 https://blog.csdn.net/m0_37953323/article/details/77169608]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4651]]></title>
    <url>%2F2019%2F03%2F22%2FHDU-4651%2F</url>
    <content type="text"><![CDATA[题意整数拆分，$(1\le n\le 10^5)$ 题解使用五边形定理 P(n)=\sum\limits_{k=1}^n(-1)^{k+1}\left [P\left( n-\frac 1 2k(3k-1)\right)+P\left( n-\frac 1 2k(3k+1)\right )\right ]其中n-\frac 1 2k(3k-1)>=0 , n-\frac 1 2k(3k+1)>=0 ，注意两个条件要分开判断，有大于0的就加上相应的f，不是两个同时成立或者不成立 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(1.1e5)using namespace std;int p[N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); p[0]=1; for1(i,100005)&#123; ll fl=1,an=0,flag=1; while(1)&#123; ll tmp=fl*(3*fl-1)/2; if(i-tmp&lt;0)break; an=(an+flag*p[i-tmp]+mod)%mod; tmp=fl*(3*fl+1)/2; if(i-tmp&lt;0)break; an=(an+flag*p[i-tmp]+mod)%mod; fl++; flag*=-1; &#125; p[i]=an; // printf("%d\n",tmp); &#125; int t,n; ind(t); while(t--)&#123; ind(n); printf("%d\n",p[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂题]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%9D%82%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1题意将整数n拆分为m个数的和，输出这m个数or的最小值。 题解要想使或值最小，那么m个二进制数中的最高位应尽量小，假如存在k使$(2^k-1)m &gt; n &gt; (2^{k-1}-1)*m$，所以m个二进制数中至少有一个数的最高位为k。因为是取各位取或，所以此时应让尽量多的数的第k位为1，$ans += 2^k$，从高位向低位递推，直到n变为0。 2题意 \Large\sum\limits_{i=1}^n\lfloor\frac n i\rfloor代码123456789101112//solution1int k=sqrt(n+0.1);for (int i = 1; i &lt;= k; i++) &#123; ans+=n/i; if (n/(i+1)&lt;i)break; else ans+=(n/i-n/(i+1))*i;&#125;//solution2for (int i = 1; i &lt;= k; i++) ans+=n/i;ans*=2;ans-=k*k; 3题意设一个排列，当i为奇数，a[i]&gt;a[i-1]，求满足条件的长度为n的数量 题解设答案是 $f(n)$考虑最⼤大的数的位置是 i，则变成一个长度为 i-1 的数列列和一个长度为 n-i 的数列列所以 $f(n)=\sum\frac {f(i)f(n-i-1)} n$所以 $f(x)’=f(x)^2+1$解得 $f(x)=tan(x)$ 4题解n+1个数由1-n 组成，只有一个重复的，找出来。 代码123456789101112131415161718192021int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int low = nums[0], fast = nums[nums[0]]; while (low != fast) &#123; low = nums[low]; fast = nums[nums[fast]]; &#125; fast = 0; while (low != fast) &#123; low = nums[low]; fast = nums[fast]; &#125; return low;&#125;int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[abs(nums[i]) - 1] &lt; 0) return abs(nums[i]); nums[abs(nums[i]) - 1] *= -1; &#125; return -1;&#125; 5 法一: 求每个点左边连续比它大的最左边的下标，保存在l[]数组里,求每个点右边连续比它大的最右边的下标，保存在r[]数组里 法二: 维护一个单调栈, 如果h大于栈顶元素，则入栈, 否则，将栈内元素出栈，直到满足上面的条件。出栈时，我们要将出栈元素对之后问题的影响全部考虑进行处理，才能保证做法的正确性。 6 只需n+m-1个就可以填满, 当插入点(x1,y1) 时有关系x1&lt;=&gt;y1 当插入点(x2,y1) 时有关系 x2&lt;=&gt;y1&lt;=&gt;x1 当插入点(x1,y2) 时有关系 y2&lt;=&gt;x1&lt;=&gt;y1&lt;=&gt;x2 用并查集来连接 7给你一个序列n个数组成，然后让你在里面找到m个子序列，让这m个子序列的和最大。 12345dp[i][j]表示的是第j个数字在第i个子序列时的当前最优值。dp[i][j] = maxx(dp[i][j-1] + num[j] ,maxx(dp[i-1][k]) + num[j]); k是从1到j-1.可以这么理解这个转移方程，对于当前的这个数字，如果把他放到第i个子序列中有两种情况，一个是他作为第i个子序列的第一个数字，另一个就是不作为第一个数字，作为第一个数字的时候是 max(dp[i-2][k] + num[j]) 1&lt;=k&lt;i 的意思是从之前的所有中找到i-1个子序列的最大值+当前的值，不做为第一个的时候那么他前面的那个数字一定是i序列的，同一个子序列，又不是作为第一个，那么前面的那个货就一定是同一个子序列的，那么当前的值是dp[i][j-1] + num[j],在两种决策中选择一个最有的就行了，还有就是maxx(dp[i-1][k]+num[j])的这个地方可以开一个数组记录下来，不能每次都跑，跑不起，再有就是这个题目没有给m的范围，所以开不了二维数组（目测不是很大，大的话会超时，但是肯定是先超内存在超时，所以为了保险，还是吧dp[][]压缩成一维的）那么状态转移就边成这样了dp[j]表示的是 j这个人在当前的这个子序列中的最优值，mk[j]表示的是在上一个子序列中1--j的dp的最大值，所以就变成 dp[j] = maxx(dp[j-1] + num[j] ,mk[j-1]+num[j]);还是 max(作为i个子序列的第一个元素，不是第一个元素取一个最大值)。在解释下代码的核心部分。 8给一个函数 12345678910int f(int x,int y)&#123; int c=0; while(y&gt;0)&#123; c++; t=x%y; x=y; y=t; &#125; return c*x*x;&#125; 给出n,m,p，求$\Large\sum\limits_{i=1}^n\sum\limits_{j=1}^m\lfloor\frac {i*j} {f(i,j)}\rfloor$ ans=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{i+j*k\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor\\=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*(k+p*c))} {c*x*x}\rfloor\\ =\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor+\frac {p*j*j} {x*x}9有n家银行围成一个圈，有个人在有些银行里欠了钱，在一些银行里有存钱，欠的钱总数等于存的钱总数。现在可以有操作，如果两个银行相邻，那么就能在一个银行转任意多的钱到另一个银行。问最少的操作次数，使得在所有银行的存款钱数都为0。 首先我们要发现第一个贪心。如果有一段子串，里面的数字之和等于0，那么在这段子串中移动数字，所需要的代价为子串长度len-1，那么问题就转换成了，我们在这个圈中能找到多少段子串，里面的数字之和等于0，而且段数越多越好，记为k，那么很明显，答案就是n-k，现在问题来了，如何来求满足题意的最大的k。首先，我们考虑用前缀和来存放，如果遇到两个位置，前缀和相等，那么中间那一段数字之和肯定等于0。接下来就是一个跳跃性的思考了，那么如果某个前缀和的值出现了k次，是不是就是我们上述的k呢？答案是正确的！假如有k个位置的前缀和相等，那么中间k-1段子串内数字之和一定都是0，由于总数是0，那么最前面和最后面连着的那一段也肯定是0，所以，我们记录所有的前缀和的值，然后排序。然后用取尺法记录一个数出现的最多次数，就做完了 10将整数n拆分为m个数的和，输出这m个数or的最小值。 要想使或值最小，那么m个二进制数中的最高位应尽量小，假如存在k使$(2^k-1)m &gt; n &gt; (2^{k-1}-1)*m$，所以m个二进制数中至少有一个数的最高位为k。因为是取各位取或，所以此时应让尽量多的数的第k位为1，$ans += 2^k$，从高位向低位递推，直到n变为0。 11求a~b间素数个数(1 ≤ a ≤ b &lt; 2^31, b - a ≤ 100000). 12345678memset(visab,0,sizeof(visab));for (int i = 0; i &lt; cnt &amp;&amp; prime[i] &lt;= b; i++) &#123; LL k = a / prime[i]; if (k * prime[i] &lt; a) k++; for (LL j = k * prime[i]; j &lt;= b; j += prime[i]) &#123; visab[j - a] = 1; &#125;&#125; 12求和 \Large\sum\limits_{i=1}^n\lfloor\frac n i\rfloor123456789101112//solution1int k=sqrt(n+0.1);for (int i = 1; i &lt;= k; i++) &#123; ans+=n/i; if (n/(i+1)&lt;i)break; else ans+=(n/i-n/(i+1))*i;&#125;//solution2for (int i = 1; i &lt;= k; i++) ans+=n/i;ans*=2;ans-=k*k; 13设一个排列，当i为奇数，a[i]&gt;a[i-1]，求满足条件的长度为n的数量 设答案是 f(n) 考虑最⼤大的数的位置是 i，则变成⼀一个⻓长度为 i-1 的数列列和一个⻓长度为 n-i 的数列列 所以 f(n)=sum(f(i)f(n-i-1))/n 所以 f(x)’=f(x)^2+1 解得 f(x)=tan(x) 14n+1个数由1-n 组成，只有一个重复的，找出来。 123456789101112131415161718192021int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int low = nums[0], fast = nums[nums[0]]; while (low != fast) &#123; low = nums[low]; fast = nums[nums[fast]]; &#125; fast = 0; while (low != fast) &#123; low = nums[low]; fast = nums[fast]; &#125; return low;&#125;int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[abs(nums[i]) - 1] &lt; 0) return abs(nums[i]); nums[abs(nums[i]) - 1] *= -1; &#125; return -1;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4055 Number String]]></title>
    <url>%2F2019%2F03%2F22%2FHDU-4055%2F</url>
    <content type="text"><![CDATA[题意给你一个字符串s，s[i] = ‘D’表示排列中a[i] &gt; a[i+1]，s[i] = ‘I’表示排列中a[i] &lt; a[i+1]。 比如排列 {3, 1, 2, 7, 4, 6, 5} 表示为字符串 DIIDID。 题解很巧妙的DP做法，$dp[i][j]$表示前i个满足字符串条件的结尾为j的 i 的排列，注意是i的排列，前面并没有数大于i。那又是如何往下递推呢？ 如果s[i - 1]是’ I ‘，那么$dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + .. + dp[i-1][1]$如果s[i - 1]是‘D’，那么$dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + … + dp[i-1][i]$，因为要令当前位为j，如果前面出现过j，就令前面的所有大于等于j的数+1，就能构造出新的排列了。 比如{1, 3, 5, 2, 4}，要在第六位插入3,令 &gt;= 3的数都+1，于是就构造出新的 排列{1, 4, 6, 2, 5, 3}。然后代码的话处理出前缀和$sum[i][j]$，就不用$dp[i][j]$了。 代码123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;typedef __int64 ll; const int maxn = 1000 + 5;const int mod = 1000000007; ll sum[maxn][maxn];char s[maxn]; int main() &#123; while(scanf("%s", s) != -1) &#123; int len = strlen(s); sum[0][1] = 1; for(int i = 1;i &lt;= len; i++) &#123; for(int j = 1;j &lt;= i+1; j++) &#123; sum[i][j] = sum[i][j-1]; if(s[i-1] != 'D') sum[i][j] += sum[i-1][j-1]; if(s[i-1] != 'I') sum[i][j] += sum[i-1][i] - sum[i-1][j-1] + mod; sum[i][j] %= mod; &#125; &#125; printf("%I64d\n", sum[len][len+1]); &#125; return 0;&#125; 引用https://blog.csdn.net/jayye1994/article/details/12361481]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LightOJ-1197 Help Hanzo]]></title>
    <url>%2F2019%2F03%2F22%2FLightOJ-1197%2F</url>
    <content type="text"><![CDATA[题意求a~b间素数个数(1 ≤ a ≤ b &lt; 2^31, b - a ≤ 100000). 题解b-a这个区间比较小，所以可以用区间素数筛选的办法解决这个题目。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem1(a) memset(a, 1 , sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;const int N=100005;bool a[N+1];vector&lt;int&gt; prime;void getPrime()&#123; memset(a,true,sizeof(a)); for(int i=2;i&lt;=N;i++)&#123; if(a[i]) prime.push_back(i); for(int j=0;j&lt;(int)prime.size()&amp;&amp;i*prime[j]&lt;=N;j++)&#123; a[i*prime[j]]=false; if(!(i%prime[j])) break; &#125; &#125;&#125;int main()&#123; //ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); //freopen("in.txt", "r", stdin); ll t,a,b; bool isprime[100005]; getPrime(); //cout&lt;&lt;prime.size(); cin&gt;&gt;t; for1(k,t)&#123; int ans=0; cin&gt;&gt;a&gt;&gt;b; mem1(isprime); for(int i=0;prime[i]*prime[i]&lt;=b&amp;&amp;i&lt;(int)prime.size();i++)&#123; ll l=a/prime[i]; if (l*prime[i]&lt;a) l++; if (l&lt;2) l=2; for (; l*prime[i]&lt;=b; l++) isprime[l*prime[i]-a]=0; &#125; if (a==1) isprime[0]=0; for0(i,b-a+1) if (isprime[i])ans++; printf("Case %d: %d\n",k,ans ); &#125; return 0;&#125;]]></content>
      <categories>
        <category>lightoj</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3167 Cow Patterns]]></title>
    <url>%2F2019%2F03%2F22%2FPOJ-3167%2F</url>
    <content type="text"><![CDATA[题意一个农场主有 N 头牛，每个牛都以它身上的斑点数作为标志，以斑点数作为标准对牛进行 rank 排序，定义牛的序列的相同性为第 i 头牛及其之前的牛的比他 rank 小的数量和与他 rank 相同的数量，比如：1 4 4 3 2 1 和 2 10 10 7 3 2 是一样的模式串要求数有多少个符合要求的模式串，并输出每个符合要求的子串的起始位置。 题解定义一个函数 $getval(ch,str,l,r)$，返回的值为 $ch$ 在 $str[l~r]$ 中的真实值，即将 $str[l~r]$ 中的值排序离散化后 $ch$ 的值。则题意即为：在a串中找出一段长为m的区间[l,r]，使对任意的1≤i≤m，getval(a[l+i-1],a,l,r)均等于getval(b[i],b,1,m)getval的值，其实是返回某个数(数跟字符其实是一样的)在某堆数中的排名。是什么决定了一个数x的排名？是小于x的数的个数，等于x的数的个数。如果这两个个数与另一个y的两个个数都相等，那么x跟y在各自字符串的各自区间内的getval值就相等了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))n#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(1.1e5)using namespace std;int Next[N],sump[N][30],now[30],sums[N][30],n,k;vector&lt;int&gt;ans;bool check(int l,int r,int sump[][30],int sums[][30],int *p,int*s)&#123; int lep=0,les=0; for1(i,p[l]-1)lep+=sump[l][i]; for1(i,s[r]-1)les+=sums[r][i]-sums[r-l][i]; if(lep==les&amp;&amp;sump[l][p[l]]==sums[r][s[r]]-sums[r-l][s[r]])return 1; else return 0;&#125;void kmp_pre(int *p, int p_len, int Next[]) &#123; // Next[i] 为满足 p[i-z...i-1]=p[0...z-1] 的最大 z 值(就是 p的自身匹配) int i = 0, j = Next[0] = -1; while (i &lt; p_len) &#123; while (j != -1 &amp;&amp; !check(j,i,sump,sump,p,p)) j = Next[j]; Next[++i] = ++j; &#125;&#125;void KMP(int *p, int *s) &#123; // p 是模式串，s 是主串 int i = 0, j = 0, p_len = k, s_len =n; for1(i,p_len)&#123; memcpy(sump[i],sump[i-1],30*sizeof(int)); sump[i][p[i-1]]++; &#125; for1(i,s_len)&#123; memcpy(sums[i],sums[i-1],sizeof(sums[i])); sums[i][s[i-1]]++; &#125; kmp_pre(p, p_len, Next); while (i &lt; s_len) &#123; while (-1 != j &amp;&amp; !check(j,i,sump,sums,p,s)) j = Next[j]; i++;j++; if (j &gt;= p_len) &#123; ans.push_back(i); j = Next[j]; &#125; &#125;&#125;int p[N],S[N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int q; scanf("%d%d%d",&amp;n,&amp;k,&amp;q); for0(i,n)ind(S[i]); for0(i,k)ind(p[i]); KMP(p,S); //puts(""); printf("%d\n",(int)ans.size()); for0(i,ans.size())printf("%d\n",ans[i]-k+1); return 0;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-675]]></title>
    <url>%2F2019%2F03%2F22%2FCF-675%2F</url>
    <content type="text"><![CDATA[C. Money Transfers题意有n家银行围成一个圈，有个人在有些银行里欠了钱，在一些银行里有存钱，欠的钱总数等于存的钱总数。现在可以有操作，如果两个银行相邻，那么就能在一个银行转任意多的钱到另一个银行。问最少的操作次数，使得在所有银行的存款钱数都为0。 题解首先我们要发现第一个贪心。如果有一段子串，里面的数字之和等于0，那么在这段子串中移动数字，所需要的代价为子串长度len-1，那么问题就转换成了，我们在这个圈中能找到多少段子串，里面的数字之和等于0，而且段数越多越好，记为k，那么很明显，答案就是n-k，现在问题来了，如何来求满足题意的最大的k。首先，我们考虑用前缀和来存放，如果遇到两个位置，前缀和相等，那么中间那一段数字之和肯定等于0。接下来就是一个跳跃性的思考了，那么如果某个前缀和的值出现了k次，是不是就是我们上述的k呢？答案是正确的！假如有k个位置的前缀和相等，那么中间k-1段子串内数字之和一定都是0，由于总数是0，那么最前面和最后面连着的那一段也肯定是0，所以，我们记录所有的前缀和的值，然后排序。然后用取尺法记录一个数出现的最多次数，就做完了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;strstream&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define MOD 1000000007#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int n,maxx=1,tmp; ll pre=0; map&lt;ll,int&gt;log; cin&gt;&gt;n; for0(i, n)&#123; cin&gt;&gt;tmp; pre+=tmp; if (log.count(pre)) &#123; log[pre]++; maxx=max(maxx, log[pre]); &#125;else log[pre]=1; &#125; cout&lt;&lt;n-maxx&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-5970 最大公约数]]></title>
    <url>%2F2019%2F03%2F22%2FHDU-5970%2F</url>
    <content type="text"><![CDATA[题意给一个函数 12345678910int f(int x,int y)&#123; int c=0; while(y&gt;0)&#123; c++; t=x%y; x=y; y=t; &#125; return c*x*x;&#125; 给出n,m,p，求$\Large\sum\limits_{i=1}^n\sum\limits_{j=1}^m\lfloor\frac {i*j} {f(i,j)}\rfloor$ 题解 ans=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{i+j*k\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor\\=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*(k+p*c))} {c*x*x}\rfloor\\ =\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor+\frac {p*j*j} {x*x}代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)using namespace std;#define mod (int)(1e9 + 7)#define N (int)(1.1e5)int f[700][700], c[700][700];void fun(int x, int y) &#123; int b = 0, i = x, j = y; while (y) &#123; b++; int tmp = x % y; x = y; y = tmp; &#125; c[i][j] = b; f[i][j] = b * x * x;&#125;int main() &#123;#ifndef ONLINE_JUDGE //freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif for1(i, 666) for1(j, 666) fun(i, j); int t; ind(t); while (t--) &#123; int n, m, p; ll ans = 0; scanf("%d%d%d", &amp;n, &amp;m, &amp;p); for1(j, m) &#123; for (int i = 1; i &lt;= j &amp;&amp; i &lt;= n; i++) &#123; int k = (n - i) / j; int tt = c[i][j] * j * j / f[i][j]; for (int q = 0; q &lt; c[i][j]&amp;&amp;q&lt;=k ; q++) &#123; //if (i + q * j &gt; n) break; //ll t = (n - (i + j * q)) / (c[i][j] * j) + 1; ll t=(k-q)/c[i][j]+1; ll tmp=(i+j*q)*j/f[i][j]; ans=(ans+tmp*t%p+(t-1)*t/2%p*tt%p)%p; // ll b = (i + j * q) * j / f[i][j]; // ans = (ans + b * t % p + (t - 1) * t / 2 % p * tt % p) % p; &#125; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1050 To the Max]]></title>
    <url>%2F2019%2F03%2F21%2FPOJ-1050%2F</url>
    <content type="text"><![CDATA[题意求最大子矩阵和。 题解枚举列区间，将该区间的值压缩到一起，转化成求一维最大字段。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;vector&gt;#define ll long long#define inf 0x3f3f3f3f#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main() &#123; ios::sync_with_stdio(false); int n, a[101][101],b[101][101]; cin &gt;&gt; n; mem0(b); for0(i, n) &#123; for0(j, n)&#123; cin&gt;&gt;a[i][j]; b[i][j+1]=b[i][j]+a[i][j]; &#125; &#125; int ans=0; for0(i, n) forl(j, i+1, n)&#123; int tmp=0; for0(k, n)&#123; tmp+=b[k][j]-b[k][i]; if (tmp&lt;0) &#123; tmp=0; &#125;else if(tmp&gt;ans)&#123; ans=tmp; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1024 Max Sum Plus Plus]]></title>
    <url>%2F2019%2F03%2F21%2FHDU-1024%2F</url>
    <content type="text"><![CDATA[题意给你一个序列n个数组成，然后让你在里面找到m个子序列，让这m个子序列的和最大。 题解$dp[i][j]$表示的是第j个数字在第i个子序列时的当前最优值。$dp[i][j] = maxx(dp[i][j-1] + num[j] ,maxx(dp[i-1][k]) + num[j])$，k是从1到 $j-1$.可以这么理解这个转移方程，对于当前的这个数字，如果把他放到第i个子序列中有两种情况，一个是他作为第i个子序列的第一个数字，另一个就是不作为第一个数字，作为第一个数字的时候是 $max(dp[i-2][k] + num[j]) ,1&lt;=k&lt;i $的意思是从之前的所有中找到 $i-1$ 个子序列的最大值+当前的值，不做为第一个的时候那么他前面的那个数字一定是i序列的，同一个子序列，又不是作为第一个，那么前面的那个货就一定是同一个子序列的，那么当前的值是$dp[i][j-1] + num[j]$,在两种决策中选择一个最有的就行了，还有就是$max(dp[i-1][k]+num[j])$的这个地方可以开一个数组记录下来，不能每次都跑，跑不起，再有就是这个题目没有给m的范围，所以开不了二维数组（目测不是很大，大的话会超时，但是肯定是先超内存在超时，所以为了保险，还是吧$dp[][]$压缩成一维的）那么状态转移就边成这样了$dp[j]$表示的是 j这个人在当前的这个子序列中的最优值，mk[j]表示的是在上一个子序列中1—j的dp的最大值，所以就变成 $dp[j] = maxx(dp[j-1] + num[j] ,mk[j-1]+num[j])$;还是 max(作为i个子序列的第一个元素，不是第一个元素取一个最大值)。在解释下代码的核心部分。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;ctime&gt;#include &lt;strstream&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int d[1000006],a[1000006],pre_max[2][1000006];int main()&#123; int n,m; while (cin&gt;&gt;m&gt;&gt;n) &#123; memset(d, 0, sizeof(d)); memset(pre_max, 0, sizeof(pre_max)); for (int i=1; i&lt;=n; i++) scanf("%d",&amp;a[i]); int maxx; //pre_max[0][0]=-99999999;pre_max[1][0]=-99999999; for (int i=1; i&lt;=m; i++) &#123; maxx=-9999999; for (int j=i; j&lt;=n; j++) &#123; d[j]=max(d[j-1]+a[j], pre_max[(i+1)%2][j-1]+a[j]); maxx=max(maxx, d[j]); pre_max[i%2][j]=maxx; &#125; &#125; cout&lt;&lt;pre_max[m%2][n]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-2559 Largest Rectangle in a Histogram]]></title>
    <url>%2F2019%2F03%2F21%2FPOJ-2559%2F</url>
    <content type="text"><![CDATA[题意 求柱形图中的最大矩形面积。 题解法一: 求每个点左边连续比它大的最左边的下标，保存在 $l[]$ 数组里,求每个点右边连续比它大的最右边的下标，保存在 $r[]$ 数组里 法二: 维护一个单调栈, 如果 $h$ 大于栈顶元素，则入栈, 否则，将栈内元素出栈，直到满足上面的条件。出栈时，我们要将出栈元素对之后问题的影响全部考虑进行处理，才能保证做法的正确性。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;ctime&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int n,tmp; while (cin&gt;&gt;n&amp;&amp;n) &#123; ll ans=0; vector&lt;pair&lt;int, int&gt; &gt;sta;//点的权值 权值大于等于该点的数量 for0(i, n)&#123; cin&gt;&gt;tmp; int count=0; forn(i, sta.size()-1)&#123; if (sta[i].first&gt;tmp) &#123; count+=sta[i].second; ans=max(ans, (ll)sta[i].first*count); sta.pop_back(); &#125;else break; &#125; sta.push_back(pair&lt;int, int&gt;(tmp,count+1)); &#125; int count=0; forn(i, sta.size()-1)&#123; count+=sta[i].second; ans=max(ans, (ll)sta[i].first*count); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[城市建设]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[题意n 个城市，m 条道路，每条道路有一个权值(可能为负)，每个点有一个权值，表示修建码头的费用(为-1时表示不可以修建码头)。 题解ans1不修建码头的最小生成树ans2额外添加一个0号城市，将可建立码头的城市与它相连，求出的最小生成树当不建码头也能联通时，答案为min(ans1,ans2)，否则答案为 ans2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 2e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct Edge&#123; int u,v,c; Edge()&#123;&#125; Edge(int a,int b,int _c)&#123; u=a,v=b,c=_c; &#125; bool operator &lt;(const Edge y)const&#123; return c&lt;y.c; &#125;&#125;edge[N];int uni[N];int find_r(int x)&#123; if(x==uni[x])return x; else return uni[x]=find_r(uni[x]);&#125;int merge(Edge x)&#123; int fa=find_r(x.u),fb=find_r(x.v); if(fa!=fb)&#123; uni[fa]=fb; return 1; &#125; if(x.c&lt;0)return -1; else return 0;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,c,w,Size=0; ll ans1=0,ans2=0; scanf("%d%d",&amp;n,&amp;m); for0(i,m)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); edge[Size++]=Edge(u,v,c); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); int cnt=0; for0(i,Size)&#123; switch(merge(edge[i]))&#123; case 1: ans1+=edge[i].c; cnt++; break; case -1: ans1+=edge[i].c; &#125; &#125; for1(i,n)&#123; ind(w); if(w&gt;0)edge[Size++]=Edge(0,i,w); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); for0(i,Size)&#123; if(merge(edge[i]))ans2+=edge[i].c; &#125; if(cnt==n-1)ans2=min(ans2,ans1); printf("%lld\n",ans2); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%2F</url>
    <content type="text"><![CDATA[题意$f(x)$为斐波那契数列，求$\large\left(\sum\limits_{i=1}^nf(i)\right) mod f(m) mod p$ $0&lt;n,m,p&lt;1e18$ 题解 f(n+m)=f(n+1)f(m)+f(n)f(m-1) \\ f(n)\ mod\ f(m)=f(n-m)f(m-1)\ mod\ f(m)\\ f(n)\ mod \ f(m)=f(m-1)^{\frac n m}f(n\%m)\ mod\ f(m)\\ f(n)^2=(-1)^{n+1}+f(n-1)f(n+1)\\ f(m-1)^2\ mod\ f(m)=(-1)^m m 为偶数 $\frac n m$为偶数，$f(n) mod f(m)=f(n\%m)$ $\frac n m$为奇数，$f(n) mod f(m)=f(m-1)f(n\%m) mod f(m)$ m 为奇数 $\frac n m$为偶数，$\frac n {2m}$为偶数，$f(n) mod f(m)=f(n\%m)$ $\frac n m$为偶数，$\frac n {2m}$为奇数，$f(n) mod f(m)=f(m)-f(n\%m)$ $\frac n m$为奇数，$\frac n {2m}$为偶数，$f(n) mod f(m)=f(m-1)f(n\%m) mod f(m)$ $\frac n m$为奇数，$\frac n {2m}$为奇数，$f(n) mod f(m)=f(m)-f(m-1)f(n\%m) mod f(m)$ 简化$f(m-1)f(n\%m) mod f(m)$ 性质：若$n\ge1,r\ge2$，则$f(n)f(n+r-1)-f(n+1)f(n+r-2)=(-1)^{n+1}f(r-2)$ 令$k=n\%m,k=n+1,m-1=n+r-2$，则$f(n)f(k-1)-f(m-1)f(k)=(-1)^kf(m-k)$ 所以$f(m-1)f(k) mod f(m)=(-1)^{k+1}f(m-k) mod f(m)$ 当$k$为奇时，$f(m-1)f(n\%m) mod f(m)=f(m-k)$ 当$k$为偶时，$f(m-1)f(n\%m) mod f(m)=f(m)-f(m-k)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f; ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct matrix &#123; ll a[2][2]; matrix()&#123; mem0(a); &#125;&#125;;ll qMulti(ll x,ll y,ll mod)&#123; //O(1)快速乘 return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod; &#125;matrix mat_mul(matrix x, matrix y) &#123; matrix res; for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) res.a[i][j] = (res.a[i][j] + qMulti(x.a[i][k] , y.a[k][j],mod) ) % mod; return res;&#125;ll mat_pow(ll n) &#123; if (n &lt;= 2) return 1; n -= 2; matrix c, res; c.a[0][0] = c.a[0][1] = c.a[1][0] = 1; for (int i = 0; i &lt; 2; i++) res.a[i][i] = 1; while (n) &#123; if (n % 2) res = mat_mul(res, c); c = mat_mul(c, c); n /= 2; &#125; return (res.a[0][0] + res.a[0][1]) % mod;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll n,m,p; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; mod=p; n+=2; ll k=n/m; if(n%m==0)&#123; cout&lt;&lt;((mat_pow(m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; int Sign; if(m%2)Sign=-1; else Sign=1; if(k%2)&#123; k/=2; if(k%2==0)Sign=1; if(n%m%2==0)Sign=-Sign; if(Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; k/=2; if(k%2&amp;&amp;Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125; &#125; return 0;&#125; 引用https://blog.csdn.net/acdreamers/article/details/21822165]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形排版]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9B%BE%E5%BD%A2%E6%8E%92%E7%89%88%2F</url>
    <content type="text"><![CDATA[题意小明需要在一篇文档中加入 N 张图片，其中第 i 张图片的宽度是 Wi，高度是 Hi。假设纸张的宽度是 M，小明使用的文档编辑工具会用以下方式对图片进行自动排版： 该工具会按照图片顺序，在宽度 M 以内，将尽可能多的图片排在一行。该行的高度是行内最高的图片的高度。例如在 M=10 的纸张上依次打印 3x4, 2x2, 3x3 三张图片，则效果如下图所示，这一行高度为4。(分割线以上为列标尺，分割线以下为排版区域；数字组成的矩形为第x张图片占用的版面) 如果当前行剩余宽度大于0，并且小于下一张图片，则下一张图片会按比例缩放到宽度为当前行剩余宽度(高度向上取整)，然后放入当前行。例如再放入一张4x9的图片，由于剩余宽度是2，这张图片会被压缩到2x5，再被放入第一行的末尾。此时该行高度为5： 如果当前行剩余宽度为0，该工具会从下一行开始继续对剩余的图片进行排版，直到所有图片都处理完毕。此时所有行的总高度和就是这 N 张图片的排版高度。例如再放入11x1, 5x5, 3x4 的图片后，效果如下图所示，总高度为11： 现在由于排版高度过高，图片的先后顺序也不能改变，小明只好从 N 张图片中选择一张删除掉以降低总高度。他希望剩余N-1张图片按原顺序的排版高度最低，你能求出最低高度是多少么？ 题解预处理以第 i 张图为行首的最低高度，然后枚举删图。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;pii a[N],b[N];int suf[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m,n,w,h; scanf("%d%d",&amp;m,&amp;n); for0(i,n)&#123; scanf("%d%d",&amp;w,&amp;h); a[i]=pii(w,h); &#125; for0(i,n)&#123; w=m; h=0; int len=i; for(;len&lt;n&amp;&amp;w;len++)&#123; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; // cout&lt;&lt;h&lt;&lt;endl; b[i]=pii(len,h); &#125; // puts(""); // for0(i,n)cout&lt;&lt;b[i].first&lt;&lt;' '&lt;&lt;b[i].second&lt;&lt;endl; for(int i=n-1;i&gt;=0;i--)&#123; suf[i]=suf[b[i].first]+b[i].second; &#125; // for0(i,n)cout&lt;&lt;suf[i]&lt;&lt;endl; int ans=inf,flag=0,tot=0; while(flag&lt;n)&#123; for(int i=flag;i&lt;b[flag].first;i++)&#123; w=m; h=0; int len=flag; for(;len&lt;n&amp;&amp;w;len++)&#123; if(len==i)continue; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; ans=min(ans,tot+h+suf[len]); &#125; tot+=b[flag].second; flag=b[flag].first; // tot+= &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格子刷油漆]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%A0%BC%E5%AD%90%E5%88%B7%E6%B2%B9%E6%BC%86%2F</url>
    <content type="text"><![CDATA[题意给一个$2*N$的矩阵，可以从任意一个格子刷起，但只能移动到和它相邻的格子（可以对角），求总的方案数，对$1e9+7$取模。 题解设a[n]为起点为某一角落长度为n终点任意的情况数，b[n]为起点为某一角落长度为n终点必须同列的情况数。 $b[i]=2^{i-1}$ 当起点在四个角落，以左上角为例 情况一，先向下移动，再向右移动某个位置，情况数相当于 做长度为i-1的终点任意的情况数*2 因为不需要在回到第一列，而且到第二列的时候可能是第一行或者第二行，即$a[i-1]*2$ 情况二，从起点出发最终回到第一列的第二行，那么情况数就是b[i]。 先进入第二列，然后返回第一列另一个位置，然后再回第二列，即$22a[i-2]$ 当起点在中间 情况一，向左运动后回到第i列然后向右运动 情况二，向右运动后回到第i列然后向左运动 \sum\limits_{i=2}^{n-1}2*(b[i+1]*a[n-i]+b[n-i+2]*a[i-1]) $a[1]=1,a[2]=6$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll a[N],b[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,ans=0; b[1]=1; forl(i,2,1e3)&#123; b[i]=b[i-1]*2%mod; &#125; a[1]=1;a[2]=6; forl(i,3,1e3)&#123; a[i]=(2ll*a[i-1]+b[i]+4ll*a[i-2])%mod; &#125; ind(n); if(n==1)&#123; puts("2"); return 0; &#125; ans=4ll*a[n]%mod; forl(i,2,n-1)&#123; ans=(ans+2ll*(b[i+1]*a[n-i]%mod+b[n-i+2]*a[i-1]%mod))%mod; &#125; printf("%d\n",ans); return 0;&#125; 引用https://blog.csdn.net/qq_35078631/article/details/54730870]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高僧斗法]]></title>
    <url>%2F2019%2F03%2F20%2F%E9%AB%98%E5%83%A7%E6%96%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题意n 个物品放在阶梯，向上移动物品，不能越过挡在前面的物品，最后物品都挤在高段台阶，不能移动的输。 题解两两一组，当移动上面的，可以移动下面的相同距离，所以可以把每组之间的间距看作一堆石子，转化为 Nim 博弈。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vii v,vv;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int x; while(~ind(x))v.pb(x); int Xor=0; for(int i=0;i+1&lt;v.size();i+=2)&#123; vv.pb(v[i+1]-v[i]-1); Xor^=vv.back(); &#125; if(Xor)&#123; for0(i,v.size()-1)&#123; forl(j,v[i]+1,v[i+1]-1)&#123; if(i%2)&#123; if((Xor^vv[i/2])==vv[i/2]+j-v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125;else&#123; if((Xor^vv[i/2])==vv[i/2]-j+v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125; &#125; &#125; &#125;else puts("-1"); return 0;&#125; graph TD 1-->3 2-->3 3-->4 3-->5]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国王的烦恼]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[题意n 个点 m 条边，每条边有一个权值表示该边消失的时间，求有新的点不联通的时刻的数量。 题解以时间从大到小排序，用并查集反向建图，注意同时刻只能计一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e4;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int uni[N];int find_r(int x)&#123; if(uni[x]==x)return x; else return uni[x]=find_r(uni[x]);&#125;bool merge(int a,int b)&#123; int fa=find_r(a),fb=find_r(b); if(fa==fb)return 0; uni[fa]=fb; return 1;&#125;struct edg&#123; int u,v,w; bool operator &lt; (const edg y)const&#123; return w&gt;y.w; &#125;&#125;edge[10*N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; scanf("%d%d",&amp;n,&amp;m); for1(i,n)uni[i]=i; for0(i,m)scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); sort(edge,edge+m); int ans=0,time=0; for0(i,m)&#123; // cout&lt;&lt;edge[i].u&lt;&lt;' '&lt;&lt;edge[i].v&lt;&lt;' '&lt;&lt;edge[i].w&lt;&lt;endl; if(merge(edge[i].u,edge[i].v))&#123; if(edge[i].w!=time)&#123; time=edge[i].w; ans++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1062]]></title>
    <url>%2F2019%2F03%2F02%2FCF-1062%2F</url>
    <content type="text"><![CDATA[D. Fun with Integers题意You are given a positive integer n​ greater or equal to 2. For every pair of integers a and b (2≤|𝑎|,|𝑏|≤𝑛2≤|a|,|b|≤n), you can transform a into b if and only if there exists an integer x such that 1&lt;|x| and (a⋅x=b or b⋅x=a), where |x| denotes the absolute value of x. After such a transformation, your score increases by |x| points and you are not allowed to transform a into b nor b into a anymore. Initially, you have a score of 0. You can start at any integer and transform it as many times as you like. What is the maximum score you can achieve? 题解答案为 2~n 每个数的因子( 范围为$[2,n)$ )之和。 \Huge\sum s_i代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; ll ans=0; cin&gt;&gt;n; forl(i,2,n)&#123; ans+=1ll*i*(n/i-1); &#125; cout&lt;&lt;ans*4&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1076]]></title>
    <url>%2F2019%2F03%2F02%2FCF-1076%2F</url>
    <content type="text"><![CDATA[D. Edge Deletion题意the length of the shortest path from vertex 1 to vertex i as $d_i$ . You have to erase some edges of the graph so that at most k edges remain. Let’s call a vertex i good if there still exists a path from 1 to i with length $d_i$ after erasing the edges. Your goal is to erase the edges in such a way that the number of good vertices is maximized. 题解先跑个最短路，再搜索，取最短路上的边。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf = 0x3f3f3f3f;const ll mod = 1e9 + 7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b) &#123; return sign(a - b); &#125;struct Edge &#123; int v, w, nxt, no;&#125; edge[2 * N];int fir[N], cnt;void addedge(int u, int v, int w, int no) &#123; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].nxt = fir[u]; edge[cnt].no = no; fir[u] = cnt++;&#125;struct node &#123; int u; ll d; node(int u, ll d) : u(u), d(d) &#123;&#125; bool operator&lt;(const node &amp;a) const &#123; return d &gt; a.d; &#125;&#125;;bool used[N];ll d[N];void dijkstra() &#123; priority_queue&lt;node&gt; que; meminf(d); d[1] = 0; que.push(node(1, d[1])); while (!que.empty()) &#123; int u = que.top().u; que.pop(); if (used[u]) continue; used[u] = 1; for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] &gt; d[u] + w) &#123; d[v] = d[u] + w; que.push(node(v, d[v])); &#125; &#125; &#125;&#125;bool used_edge[N];void init() &#123; mem_1(fir); cnt = 0;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif // ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); init(); int n, m, k, u, v, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for1(i, m) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w, i); addedge(v, u, w, i); &#125; if (k == 0) &#123; puts("0\n"); return 0; &#125; dijkstra(); queue&lt;int&gt; que; que.push(1); mem0(used); used[1] = 1; int ans = 0; while (que.size()) &#123; int u = que.front(); que.pop(); for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] == d[u] + w) &#123; used_edge[edge[i].no] = 1; used[v] = 1; ans++; if (ans == k) break; que.push(v); &#125; &#125; if (ans == k) break; &#125; printf("%d\n", ans); for1(i, m) &#123; if (used_edge[i]) printf("%d ", i); &#125; puts(""); return 0;&#125; E. Vasya and a Tree题意给一颗树，将 v 和与 v 距离小于 d 的 v 的子节点的权值加上 x，输出所有节点的权值。 题解保存每个点每次加权的终点和 x。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vi;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vi node[N];int dep[N];ll change[N];bool vis[N];int maxx;void dfs(int r,int dph)&#123; dep[r]=dph; vis[r]=1; maxx=max(maxx,dph); for(int v:node[r])if(vis[v]==0)dfs(v,dph+1);&#125;struct da&#123; int end,x; da()&#123;&#125; da(int a,int b):end(a),x(b)&#123;&#125;&#125;;vector&lt;da&gt; weight[N];ll tmpc[N];void ddfs(int r,int depth,ll sum)&#123; for(auto i:weight[r])&#123; sum+=i.x; tmpc[i.end]+=i.x; &#125; change[r]+=sum; sum-=tmpc[depth]; vis[r]=1; for(int v:node[r])if(vis[v]==0)ddfs(v,depth+1,sum); for(auto i:weight[r])tmpc[i.end]-=i.x;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,d,x; ind(n); for0(i,n-1)&#123; scanf("%d%d",&amp;u,&amp;v); node[u].push_back(v); node[v].push_back(u); &#125; dfs(1,1); ind(m); for0(i,m)&#123; scanf("%d%d%d",&amp;v,&amp;d,&amp;x); weight[v].push_back(da(min(dep[v]+d,maxx),x)); &#125; mem0(vis); ddfs(1,1,0); for1(i,n)printf("%lld ",change[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
</search>
