<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计蒜客-数组]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%AE%A1%E8%92%9C%E5%AE%A2-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题意给出长度为 $N$ 的数组 $A$, 定义 f(l, r)=\max \left(\max \left(A_{l}, A_{l+1} \ldots A_{x}\right) \cdot(r-x+1) \cdot[l \leq x \leq r]\right)求 \sum_{i=1}^{n} \sum_{j=i}^{n} f(i, j) \bmod 10^{9}+7 题解从后往前枚举 $i$ , 用一个单调栈来存在固定 $i$ 的时候, $j\in[i,n]$ , 不同 $j$ 的 $x$ 的取值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int a,r,pre,i; //r 表示取 a 的 j 的区间的右端点 da(int _a,int _r,int _p,ll _i)&#123; a=_a; r=_r; pre=_p; i=_i; &#125; da()&#123;&#125;&#125;;stack&lt;da&gt;sta;ll fun(itn a,int l,int r)&#123; return (r-l+1ll)*(l+r)/2%mod*a%mod;&#125;int a[N];int main() &#123; itn n; ll ans=0; in(n); for1(i,n)&#123; in(a[i]); &#125; for(int i=n;i&gt;0;i--)&#123; ll r=n; whiel(sta.size())&#123; da tmp=sta.top(); if(tmp.a&lt;=a[i])&#123; sta.pop(); &#125;else&#123; ll p=(tmp.a*1ll*tmp.i-tmp.a+a[i]-a[i]*1ll*i)/(tmp.a-a[i]); if(p&gt;=tmp.r)&#123; sta.pop(); &#125;else&#123; r=p; break; &#125; &#125; &#125; // cout&lt;&lt;i&lt;&lt;' '&lt;&lt;r&lt;&lt;"\n"; assert(r&lt;=n); // assert(r&gt;=) int pre=0; if(sta.size())&#123; da tmp=sta.top(); // cout&lt;&lt;tmp.a&lt;&lt;' '&lt;&lt;tmp.i&lt;&lt;endl; pre=tmp.pre; // assert(r&gt;=tmp.i); pre=(pre+fun(tmp.a,r-tmp.i+2,tmp.r-tmp.i+1))%mod; &#125; // cout&lt;&lt;endl; sta.push(da(a[i],r,pre,i)); ans=(ans+pre+fun(a[i],1,r-i+1))%mod; &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>计蒜客</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1175D]]></title>
    <url>%2F2019%2F06%2F07%2FCF-1175D%2F</url>
    <content type="text"><![CDATA[Array Splitting题意将一个长度为 $n$ 的序列 $a_i$ 顺序不变的分为非空的 $k$ 部分, 设 $f(i)$ 表示 $a_i$ 在第 $f(i)$ 部分 求 $\sum\limits_{i=1}^na_i*f(i)$ 题解在 $[1,n]$ 中选 $k$ 个点 $b_i$ (其中一个为 1)将序列分为 $k$ 份, 答案为 $\sum\limits_{i=1}^ksuf[i]$ , $suf[i]$ 表示从 $i$ 开始的后缀和 所以直接对后缀排序, 取最大的 $k$ 个 代码1234567891011121314151617181920int a[N];ll suf[N];bool cmp(ll x,ll y)&#123; return x&gt;y;&#125;int main() &#123; int n,k; in(n,k); for0(i,n)in(a[i]); for(itn i=n-1;i&gt;=0;i--)&#123; suf[i]=suf[i+1]+a[i]; &#125; sort(suf+1,suf+n,cmp); ll ans=0; for0(i,k)&#123; ans+=suf[i]; &#125; outln(ans); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1174E]]></title>
    <url>%2F2019%2F06%2F06%2FCF-1174E%2F</url>
    <content type="text"><![CDATA[Ehab and the Expected GCD Problem题意定义 $f(p)$ 表示 一个排列 $p$ 的 $g_1,g_2 \cdots g_n$ 的种类数, $g_i$ 表示该排列前 $i $ 个数的 $gcd$ $f_{max}(n)$ 表示 $n$ 的排列的最大 $f$ 值 给 $n$ 求 $f(p)=f_{max}(n)$ 的方案数 题解显然 要让 $f$ 最大, 排列的第一个数为 $2^k$ 或 $2^{k-1}3$ , 设 $dp[i][x][t]$ 表示前 $i$ 个数的 $gcd$ 为 $\large 2^{x} 3^y$ 的方案数 dp[i][x][y]=dp[i-1][x][y]*max(f[x][y]-i+1,0)+\\dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])+dp[i-1][x][y+1]*(f[x][y]-f[x][y+1]$f[x][y]$ 表示 $\Large \lfloor \frac n {2^x*3^y}\rfloor$ , 答案为 $dp[n][0][0]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int dp[N][21][3];int n;int f[21][3];int pp[N];int main() &#123; in(n); ll pre=1; for1(i,N)&#123; pre=pre*i%mod; pp[i]=pre; &#125; for0(i,21) for0(j,3)&#123; f[i][j]=n/((1&lt;&lt;i)*pow(3,j)); &#125; if(n&lt;4)&#123; if(n==2)puts("1"); else if(n==3)puts("4"); return 0; &#125; int k=0,tn=n; while(tn)&#123; tn/=2; k++; &#125; k--; dp[1][k][0]=1; if((1&lt;&lt;(k-1))*3&lt;=n)dp[1][k-1][1]=1; itn i,cnt; for(i=2;i&lt;=n;i++)&#123; itn x,y; cnt=0; for0(j,k)&#123; x=j; y=0; dp[i][x][y]=(1ll*dp[i-1][x][y]*max(f[x][y]-i+1,0)%mod+1ll*dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])%mod+1ll*dp[i-1][x][y+1]*(f[x][y]-f[x][y+1])%mod)%mod; if(dp[i][x][y])cnt++; y=1; dp[i][x][y]=(1ll*dp[i-1][x][y]*max(f[x][y]-i+1,0)%mod+1ll*dp[i-1][x+1][y]*(f[x][y]-f[x+1][y])%mod+1ll*dp[i-1][x][y+1]*(f[x][y]-f[x][y+1])%mod)%mod; if(dp[i][x][y])cnt++; &#125; if(dp[i][0][0]&amp;&amp;cnt==1)break; &#125; // outln(i); outln(1ll*dp[i][0][0]*pp[n-i]%mod); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6284]]></title>
    <url>%2F2019%2F06%2F04%2FHDU-6284%2F</url>
    <content type="text"><![CDATA[Longest Increasing Subsequence题意有一个长度为 $n$ 的数组 $a(0\le a_i\le n)$ ,$f(x)$ 表示把 $0$ 变成 $x$ , 序列的 $LIS(严格递增)$ , 求$\sum\limits_{i=1}^ni\times f(i)$ 题解设 $bg[i], en[i]$ 分别表⽰以点 $i$ 开始、结束的 $LIS$ ⻓度，$L$ 是原来的 $LIS$ ⻓度。对于每个 $i$，找出它下⼀个 $0$ 后⾯的 $a[j]$ 满⾜ $en[i]+bg[j] = L$，那么当 $x$ 在 $[a[i] + 1, a[j] − 1]$ 的区间内时，答案是 $L + 1$. 从后往前扫, 用一个数组 $max_r[i]$ 记录扫过的最后一个 $0$ 右边区域的 $bg=i$ 的最大值 以 $0$ 为分隔, 用一个 $vector$ 存当前分块的 $max_r$ 值, 当遇到下一个 $0$ 的时候更新 $max_r$ , 注意当 $bg=L$ 时要特殊考虑 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pu_b push_back#define pu_f push_front#define po_b pop_back#define po_f pop_front#define fi first#define se second#define whiel while#define retrun returntypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const int inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],bg[N],en[N],dp[N],fu[N],max_r[N];vector&lt;pii&gt; peding;int l_bound(int l,int r,int x)&#123; r--; whiel(l&lt;=r)&#123; int mid=(l+r)/2; if(dp[mid]&gt;x)l=mid+1; else r=mid-1; &#125; return l;&#125;int main() &#123; itn n; whiel(~in(n))&#123; int L=0; for1(i,n)in(a[i]); for1(i,n)max_r[i]=fu[i]=0; for1(i,n)&#123; if(a[i])&#123; if(L)&#123; if(a[i]&gt;dp[L-1])&#123; dp[L++]=a[i]; en[i]=L; &#125;else&#123; int p=lower_bound(dp,dp+L,a[i])-dp; dp[p]=min(dp[p],a[i]); en[i]=p+1; &#125; &#125;else&#123; dp[L++]=a[i]; en[i]=L; &#125; &#125; &#125; L=max(L,1); ll ans=(1ll+n)*n/2*L; L=0; for(itn i=n;i&gt;0;i--)&#123; if(a[i])&#123; if(L)&#123; if(a[i]&lt;dp[L-1])&#123; dp[L++]=a[i]; bg[i]=L; &#125;else&#123; int p=l_bound(0,L,a[i]); dp[p]=max(dp[p],a[i]); bg[i]=p+1; &#125; &#125;else&#123; dp[L++]=a[i]; bg[i]=L; &#125; &#125; &#125; max_r[0]=0; peding.clear(); for(itn i=n;i&gt;0;i--)&#123; if(a[i])&#123; if(max_r[L-en[i]]&gt;a[i])&#123; fu[a[i]+1]++; fu[max_r[L-en[i]]]--; &#125; peding.pu_b(pii(bg[i],a[i])); &#125;else&#123; max_r[0]=n+1; whiel(peding.size())&#123; pii kk=peding.back(); peding.po_b(); if(kk.fi==L)&#123; fu[1]++; fu[kk.se]--; &#125;else&#123; max_r[kk.fi]=max(max_r[kk.fi],kk.se); &#125; &#125; &#125; &#125; for1(i,n)&#123; fu[i]+=fu[i-1]; if(fu[i])ans+=i; &#125; outln(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1174D]]></title>
    <url>%2F2019%2F06%2F04%2FCF-1174D%2F</url>
    <content type="text"><![CDATA[Ehab and the Expected XOR Problem题意给 $n(1\le n\le 18),x(1\le x&lt;2^{18})$ , 构造一个数组 $a(1\le a_i&lt;2^n)$ , 使得这个数组的任意子段的异或和不为 0 或 $x$ 题解要使得这个数组的任意子段的异或和不为 0, 只需要保证数组的前缀和都不同就可以了. 假设 $A\text^B=x$ , 可以将 $[0,2^n-1]$ 分为两部分, 没部分里面的数两两异或都不为 $x$ 代码12345678910111213141516171819202122232425262728bool vis[N];vii v;int main() &#123; int n,x; in(n,x); int p=(1&lt;&lt;n); if(x&gt;=p)&#123; outln(p-1); for1(i,p-1)&#123; out(i^(i-1)); &#125; &#125;else&#123; p-=2; outln(p/2); v.pu_b(0); vis[x]=1; for1(i,p+1)&#123; if(vis[i]==0)&#123; v.pu_b(i); vis[i]=vis[i^x]=1; &#125; &#125; for1(i,(int)v.size()-1)&#123; out(v[i]^v[i-1]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>implementation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1148E]]></title>
    <url>%2F2019%2F06%2F04%2FCF-1148E%2F</url>
    <content type="text"><![CDATA[Earth Wind and Fire题意给两个长度为 $n$ 个数组 $a,b$, 如果 $a_i\le a_j$ 可以取一个 $d(0\le 2*d\le a_j-a_i)$ , 然后 $a_i+d,a_j-d$ , 问如何操作可以让 $a$ 变为 $b$ 题解对 $a,b$ 排序, 将 $a_i$ 变为 $b_i$, 用一个 $stack$ 维护 $a$ 中待加值的元素 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758pii a[N];int b[N];bool cmp(pii x,pii y)&#123; return x.fi&lt;y.fi;&#125;struct da&#123; int i,j,d; da(int q,int w,int e)&#123; i=q;j=w;d=e; &#125;&#125;;vector&lt;da&gt;v;stack&lt;int&gt;les;int main() &#123; int n; in(n); for1(i,n)&#123; in(a[i].fi); a[i].se=i; &#125; for1(i,n)in(b[i]); sort(a+1,a+1+n,cmp); sort(b+1,b+n+1); bool yes=1; for1(i,n)&#123; if(a[i].fi&gt;b[i])&#123; a[i].fi-=b[i]; while(a[i].fi&amp;&amp;les.size())&#123; int no=les.top(); les.pop(); int minn=min(a[no].fi,a[i].fi); if(a[no].fi&gt;a[i].fi)les.push(no); a[i].fi-=minn; a[no].fi-=minn; v.pu_b(da(a[no].se,a[i].se,minn)); &#125; if(a[i].fi)&#123; yes=0; break; &#125; &#125;else if(a[i].fi&lt;b[i])&#123; a[i].fi=b[i]-a[i].fi; les.push(i); &#125; &#125; if(les.size()==0&amp;&amp;yes)&#123; puts("YES"); assert(v.size()&lt;=5*n); outln((int)v.size()); for(auto i:v)&#123; printf("%d %d %d\n",i.i,i.j,i.d); &#125; &#125;else &#123; puts("NO"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-6285]]></title>
    <url>%2F2019%2F06%2F03%2FHDU-6285%2F</url>
    <content type="text"><![CDATA[题意在一个 $n$ 个点的完全图中，第 $i$ 个点的权值为 $2^i$，选择一些边，需要选择一些点使得所有边至少有一个端点被覆盖，同时权值之和最小。在上述情况下，给出选择的点的权值和，问有多少种选择边的方案符合这种选点。 题解对于每一个选定的点, 总有一条边连着它和权值比它大的未被选的点, 设数量为 $cnt1$, 权值比它小的点可取可不取, 设数量为 $cnt2$, 则该点的贡献为 (2^{cnt1}-1)\times2^{cnt2}代码12345678910111213141516171819202122232425262728293031323334353637string s;ll f[N];ll fun(int a,int b)&#123; ll qq=(f[a]-1+mod)%mod; return qq*f[b]%mod;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,a,b; f[0]=1; for1(i,100005)&#123; f[i]=f[i-1]*2%mod; &#125; while(cin&gt;&gt;n&gt;&gt;s)&#123; a=b=0; ll ans=1; for(int i=0;i&lt;s.size();i++)&#123; if(s[i]=='1')a++; &#125; n-=s.size(); for(int i=s.size()-1,j=0;i&gt;=0;i--,j++)&#123; if(s[i]=='1')&#123; b++; ans=fun(n+i-a+b,j)*ans%mod; // cout&lt;&lt;n+i-a+b&lt;&lt;' '&lt;&lt;j&lt;&lt;endl; &#125; &#125; outln(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>combination</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018河北省省赛]]></title>
    <url>%2F2019%2F05%2F01%2F2018%E6%B2%B3%E5%8C%97%E7%9C%81%E7%9C%81%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[E. K Multiple Longest Commom Subsequence题意两个数组 $1\le k,n,m\le 1e3$, 问最长 $k$ 倍公共子序列是多少, $k$ 倍子序列指的是, 将子序列等分, 每份为 $k$ 个数, 且这 $k$ 个数相同. 如 $1,1,2,2$ 是一个 $2$ 倍子序列 题解$\text{pre_a[i]}$ 表示从 $i$ 开始往前数, 第 $k$ 个 $a[i]$ 的下标 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445int pre_a[N],pre_b[N];int t,k,n,m,x,a[N],b[N],cnt[N],dp[N][N];queue&lt;int&gt;que[N];int main() &#123; in(t); while(t--)&#123; in(k,n,m); mem0(pre_a); mem0(pre_b); for1(i,1000)while(que[i].size())que[i].pop(); for1(i,n)&#123; in(x); a[i]=x; que[x].push(i); if(que[x].size()==k)&#123; int qw=que[x].front(); que[x].pop(); pre_a[i]=qw; &#125; &#125; for1(i,1000)while(que[i].size())que[i].pop(); for1(i,m)&#123; in(x); b[i]=x; que[x].push(i); if(que[x].size()==k)&#123; int qw=que[x].front(); que[x].pop(); pre_b[i]=qw; &#125; &#125; mem0(dp); for1(i,n) for1(j,m)&#123; dp[i][j]=max(dp[i][j],max(dp[i-1][j],dp[i][j-1])); if(a[i]==b[j])&#123; if(pre_a[i]&amp;&amp;pre_b[j]) dp[i][j]=max(dp[i][j],dp[ pre_a[i]-1 ][ pre_b[j]-1 ]+1); &#125; &#125; outln(dp[n][m]*k); &#125; return 0;&#125; F. Defending Plan Support题意给一棵树, 每个点有权值 $\omega(i)$, 每条边有权值 $d(i,j)$, 找一个点 $x$ 使 $F(x)=\sum \omega(i)\times d(x,i)$ 最小 题解以 $1$ 为根节点画出这棵树, 设 $j$ 的父节点为 $i$, $tot=\sum\omega(i)$, $sum[i]$ 表示以 $i$ 为根节点的子树的权值和 F(j)=F(i)+d(i,j)\times(tot-2*sum[j])代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 5.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll dp[N],ans,tot;int sum[N],n,w[N],x,y,z;bool vis[N];vector&lt;pii&gt;v[N];int dfs(int rt,ll len)&#123; ans+=len*w[rt]; int tmp=w[rt]; for(auto i:v[rt])&#123; if(vis[i.fi]==0)&#123; vis[i.fi]=1; tmp+=dfs(i.fi,len+i.se); &#125; &#125; return sum[rt]=tmp;&#125;void dfs2(int rt)&#123; for(auto i:v[rt])&#123; if(vis[i.fi]==0)&#123; vis[i.fi]=1; dp[i.fi]=dp[rt]+i.se*tot-2ll*i.se*sum[i.fi]; ans=min(ans,dp[i.fi]); dfs2(i.fi); &#125; &#125;&#125;int main() &#123; in(n); for0(i,n-1)&#123; in(x,y,z); // tot+=z; v[x].pb(pii(y,z)); v[y].pb(pii(x,z)); &#125; for1(i,n)&#123; in(w[i]); tot+=w[i]; &#125; vis[1]=1; dfs(1,0); mem0(vis); vis[1]=1; dp[1]=ans; dfs2(1); outln(ans); return 0;&#125; K. Bitmap题意给一个 $n\times n(1 \leq n \leq 2000)$, 一个 $m\times m(1 \leq m \leq 1000,m\le n)$ 的矩阵, 值的范围为 $[0,255]$, 问 $A$ 中有几个 $B$, 只要每个元素相差一个定值就视为相同 题解hash, 枚举 $A$ 中 $B$ 的左上角 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e3;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;const int M=1.1e3;ull Pow[2][M],Hash[2][N][N],seed[2]=&#123;131,233&#125;,hash_b,hash2[M][M],offset;int a[N][N],b[M][M],n,m;void init()&#123; Pow[0][0]=Pow[1][0]=1; ull tmp[2]; tmp[0]=tmp[1]=0; for0(i,2) for1(j,m)&#123; Pow[i][j]=Pow[i][j-1]*seed[i]; tmp[i]+=Pow[i][j-1]; &#125; offset=tmp[0]*tmp[1]; for1(i,n) for1(j,n)&#123; Hash[0][i][j]=Hash[0][i][j-1]*seed[0]+a[i][j]; Hash[1][i][j]=Hash[1][i-1][j]*seed[1]+Hash[0][i][j]; &#125; for1(i,m)&#123; for1(j,m)hash2[i][j]=hash2[i][j-1]*seed[0]+b[i][j]; hash_b=hash_b*seed[1]+hash2[i][m]; &#125; hash_b-=b[1][1]*offset;&#125;ull get2(int x1,int y1,int x2,int y2)&#123; return Hash[1][x2][y2]-Hash[1][x1-1][y1]*Pow[1][m]; &#125;ull get(int x1,int y1,int x2,int y2)&#123; return get2(x1,y2,x2,y2)-get2(x1,y1-1,x2,y1-1)*Pow[0][m]-a[x1][y1]*offset;&#125;int main() &#123; in(n,m); for1(i,n) for1(j,n)in(a[i][j]); for1(i,m) for1(j,m)in(b[i][j]); init(); int ans=0; for(int i=1;i+m-1&lt;=n;i++) for(int j=1;j+m-1&lt;=n;j++)&#123; if(get(i,j,i+m-1,j+m-1)==hash_b)ans++; &#125; outln(ans); return 0;&#125; I. Beautiful Array题意长度为 $y$, 乘积为 $x$ 的序列的个数 如 $x=2,y=2$, $[1,2],[2,1],[-1,-2],[-2,-1]$ 题解分解 $x$, x=p_1^{a_1}*p_2^{a_2}\cdots p_m^{a_m}对方案数来说, 不同素因子是独立的, 对于 $p_i$, 其贡献相当于将 $a_i$ 个相同的球放进不同的盒子, 且允许有空, 为 \large C_{a_i+y-1}^{y-1}再考虑负数, 负号只能为偶数个, 其贡献为 \large C_y^0+C_y^2+C_y^4+\cdots=2^{y-1}代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;bool notPrime[N+1];int prime[N+1],num_prime=0;void get_prime()&#123; notPrime[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!notPrime[i]) prime[num_prime++]=i; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;=N;j++)&#123; int k = i*prime[j]; notPrime[k] = 1; if(i % prime[j] == 0) break; &#125; &#125;&#125;const int M =2.1e6;ll fac[M],inv[M];ll C(ll a,ll b)&#123; if(b&gt;a)return 0; return fac[a]*inv[b]%mod*inv[a-b]%mod;&#125;void init()&#123;//快速计算阶乘的逆元 fac[0]=fac[1]=1; for(int i=2;i&lt;M;i++)fac[i]=fac[i-1]*i%mod; inv[M-1] = qPow(fac[M-1], mod - 2, mod); for (int i = M - 2; i &gt;= 0; i--) inv[i] = (inv[i + 1] * (i + 1)) % mod;&#125;int main() &#123; int t,x,y; in(t); get_prime(); init(); while(t--)&#123; in(x,y); if(y==0)&#123; puts("0"); continue; &#125;else if(x==0)&#123; puts("1"); continue; &#125; ll ans=1; for(int i=0;i&lt;num_prime&amp;&amp;x!=1;i++)&#123; if(x%prime[i]==0)&#123; int cnt=0; while(x%prime[i]==0)&#123; x/=prime[i]; cnt++; &#125; ans=ans*C(cnt+y-1,y-1)%mod; &#125; &#125; if(x!=1)ans=ans*y%mod; ans=ans*qPow(2,y-1,mod)%mod; outln(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>省赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[邮局]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%82%AE%E5%B1%80%2F</url>
    <content type="text"><![CDATA[题意$n(1\le n\le50)$ 个人, $m(1\le m \le 25)$ 个车站, 选 $k(1\le k\le 10)$ 个车站, 每个人去离他最近的车站, 输出路径和最短的方案. 题解搜索剪枝, 从后往前搜索, 若对于当前状态, 某一点无法对任意一个人松弛, 就标记这个点, 之后的搜索都不再访问. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;// int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int n,m,k;struct point&#123; int x,y,no;&#125;people[55],mail[33];db G[55][33];point result[11],tmp_res[11];db ans=1e18,sum,min_dis[55];bool Not[33];db get_dis(point a,point b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;void dfs(int depth,int index)&#123; if(depth==k)&#123; if(sum&lt;ans)&#123; ans=sum; for0(i,k)result[i]=tmp_res[i]; &#125; &#125;else&#123; db tmp[55],tsum=sum; bool flag2=0;//标记 [index,m-k+depth] 这些点里有没有能够至少松弛一个人的点 for0(i,n)tmp[i]=min_dis[i]; for(int i=m-k+depth;i&gt;=index;i--)&#123; //当前已经取了 depth 个, 为了保证能够取得 k 个,所以我们最多取到 m-k+depth 点, 从这一点开始往前搜索 if(Not[i])continue; bool flag=0;//标记 i 是否能够至少松弛一个人 if(depth==0)&#123; sum=0; for0(j,n)&#123; min_dis[j]=G[j][i]; sum+=min_dis[j]; &#125; flag=1; &#125;else&#123; // for0(j,n)min_dis[j]=tmp[j]; sum=tsum; for0(j,n)&#123; if(G[j][i]&lt;tmp[j])&#123; sum-=tmp[j]-G[j][i]; min_dis[j]=G[j][i]; flag=1; &#125;else min_dis[j]=tmp[j]; &#125; &#125; if(flag)&#123; tmp_res[depth]=mail[i]; dfs(depth+1,i+1); flag2=1; &#125;else&#123; Not[i]=1; &#125; &#125; if(!flag2)&#123;//若 [index,m-k+depth] 这些点里没有能够松弛的, 就取 m-k+depth tmp_res[depth]=mail[m-k+depth+1]; dfs(depth+1,m-k+depth+1); &#125;else&#123; for0(j,n)min_dis[j]=tmp[j]; sum=tsum; &#125; &#125;&#125;int main() &#123; in(n,m,k); for0(i,n)&#123; in(people[i].x,people[i].y); &#125; for0(i,m)&#123; in(mail[i].x,mail[i].y); mail[i].no=i+1; for0(j,n)&#123; G[j][i]=get_dis(people[j],mail[i]); &#125; &#125; dfs(0,0); for0(i,k)printf("%d ",result[i].no); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[农场阳光]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%86%9C%E5%9C%BA%E9%98%B3%E5%85%89%2F</url>
    <content type="text"><![CDATA[题意求多个圆和一个矩形的面积并 题解使用自适应 Simpson 求解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;db g;int n,a,b;struct circle&#123; db x,y,r; circle()&#123;&#125; circle(int a,int b,int c,int d)&#123; x=a+c/tan(g); y=b; r=d; &#125;&#125;cir_set[N];struct seg&#123; db top,bottom; seg()&#123;&#125; seg(db a,db b)&#123; top=a; bottom=b; &#125;&#125;;bool cmp(seg x,seg y)&#123; return x.bottom&lt;y.bottom;&#125;db F(db x)&#123; vector&lt;seg&gt;v; for0(i,n)&#123; circle ci=cir_set[i]; if(fabs(x-ci.x)&lt;ci.r)&#123; db h=sqrt(ci.r*ci.r-(x-ci.x)*(x-ci.x)); v.pb(seg(ci.y+h,ci.y-h)); &#125; &#125; if(v.size()==0)return b; v.pb(seg(0,b)); sort(v.begin(),v.end(),cmp); db sta=0,ans=0; for0(i,v.size())&#123; seg se=v[i]; if(se.bottom&gt;sta)&#123; ans+=se.bottom-sta; &#125; sta=max(sta,se.top); if(sta&gt;=b)break; &#125; return ans;&#125;// 2db calc(db len,db fL,db fM,db fR)&#123; //求长度为len的[L,R]区间，中点为M的Simpson近似面积 return (fL+4*fM+fR)*len/6;&#125;db Simpson(db L,db R) &#123;//Simpson积分求区间[L,R]的面积并,F(L)=L,F(R)=R,F(M)=M,把[L,R]当成整体来拟合得到的面积是sqr db M=(L+R)/2,fL=F(L),fM=F(M),fR=F(R),sqr=calc(R-L,fL,fM,fR); db g1=calc(M-L,fL,F((L+M)/2),fM),g2=calc(R-M,fM,F((M+R)/2),fR); if(fabs(sqr-g1-g2)&lt;=eps) //把当前区间分成2半再拟合得到的答案差别很小，就不再递归下去了 return g1+g2; return Simpson(L,M)+Simpson(M,R);&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); scanf("%d%d%Lf%d",&amp;a,&amp;b,&amp;g,&amp;n); g=g*pi/180; for0(i,n)&#123; int x,y,z,r; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;r); cir_set[i]=circle(x,y,z,r); // cout&lt;&lt;cir_set[i].x&lt;&lt;' '&lt;&lt;cir_set[i].y&lt;&lt;' '&lt;&lt;cir_set[i].r&lt;&lt;endl; &#125; printf("%.2Lf\n",Simpson(0,a)); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1151]]></title>
    <url>%2F2019%2F04%2F22%2FCF-1151%2F</url>
    <content type="text"><![CDATA[E. Number of Components题意一条链, 每个点的权值为 $a_i(1\le a_i\le n)$ , $f(l,r)$ 表示仅保留权值在 $[l,r]$ 之间的点的联通分量 求 \sum\limits_{l=1}^{n} \sum\limits_{r=l}^{n} f(l, r) 题解统计每个点的贡献, 只有当取 $a_i$ 不取 $a_{i+1}$ 时, $a_i$ 才有贡献 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x; ll pre; in(n); ll ans=0; in(pre); ans+=pre*(n+1-pre); for0(i,n-1)&#123; in(x); if(x&gt;pre)&#123; ans+=(x-pre)*(n+1-x); pre=x; &#125;else if(x&lt;pre)&#123; ans+=(pre-x)*x; pre=x; &#125; &#125; outln(ans); return 0;&#125; F. Sonya and Informatics题意数组 $a$ 有 $n$ 个数, 这些数由 $0,1$ 构成, 等概率交换任意两个数的位置, 问最后得到一个不下降的数列的概率, 答案对 $1e9+7$ 取模 题解设 $x$ 表示 $0$ 的个数, $dp[i][j]$ 表示操作 $i$ 次后前 $x$ 个数中 $0$ 的个数为 $j$ 的概率, 答案为 $dp[k][x]$ 可以发现状态转移方程与 $i$ 无关, 可以用矩阵快速幂做 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define memcp(a,b) memcpy(a,b,sizeof(b))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[110];ll matrix[110][110];ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int n,k,x=0,xx=0;void fun(ll c[110][110],ll b[110][110])&#123; ll tmp[110][110]; mem0(tmp); for0(i,x+1) for0(j,x+1) for0(k,x+1)tmp[i][j]=(tmp[i][j]+c[i][k]*b[k][j])%mod; memcp(c,tmp);&#125;ll Com(ll a)&#123; if(a&lt;2)return 0; return a*(a-1)/2;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); // cout&lt;&lt;qPow(3,mod-2,mod)&lt;&lt;endl; in(n,k); ll C=n*(n-1)/2,inv_C=qPow(C,mod-2,mod); inv_C=qPow(inv_C,k,mod); for1(i,n)&#123; in(a[i]); if(!a[i])x++; &#125; ll A=Com(x),B=Com(n-x); for1(i,x)if(!a[i])xx++; int minn=max(0,2*x-n); // cout&lt;&lt;x&lt;&lt;' '&lt;&lt;xx&lt;&lt;' '&lt;&lt;minn&lt;&lt;endl; forl(i,minn,x)&#123; int p1=0,p2=0; if(i-1&gt;=minn)&#123; matrix[i-1][i]=p1=(x-i+1)*(x-i+1); &#125; if(i+1&lt;=x)&#123; matrix[i+1][i]=p2=(i+1)*(n-2*x+i+1); &#125; matrix[i][i]=A+B+i*(x-i)+(n-2*x+i)*(x-i); &#125; ll an[110][110]; for0(i,x+1)an[i][i]=1; while(k)&#123; if(k&amp;1)fun(an,matrix); fun(matrix,matrix); k&gt;&gt;=1; &#125; outln(an[xx][x]*inv_C%mod); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[填字母游戏]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%A1%AB%E5%AD%97%E6%AF%8D%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题意一个 $1*N$ 个格子, 上面已有一些 L 和 O, 两人博弈, 谁先拼出 LOL 谁获胜, 空格数&lt;14 题解状态标记搜索 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.6e6;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int ans[N];ll pow3[23];bool iskong[23];// int wei[23];int len;// int cnt;int fun(ll status)&#123; // cnt++; int ans_status=0; ll tmp_sta=status; int *wei=new int[23]; bool have0=0; for0(i,len)&#123; int flag=tmp_sta%3; wei[i]=flag; if(flag==0)have0=1; if(iskong[i])&#123; ans_status*=3; ans_status+=flag; &#125; tmp_sta/=3; &#125; if(ans[ans_status]&lt;inf)&#123; delete [] wei; return ans[ans_status]; &#125; for(int i=0;i+2&lt;len;i++)&#123; if(wei[i]==1&amp;&amp;wei[i+1]==2&amp;&amp;wei[i+2]==1)&#123; delete [] wei; return ans[ans_status]=-1; &#125; &#125; if(!have0)&#123; delete [] wei; return ans[ans_status]=0; &#125; // if(x.find("LOL") != -1)return -1; // if(x.find("*") == -1)return 0; int res = -1; delete [] wei; // delete tmp_sta; tmp_sta=status; for0(i,len)&#123; int flag=tmp_sta%3; if(flag==0)&#123; res = max(res,-fun(status+pow3[i])); res = max(res,-fun(status+2*pow3[i])); if(res==1)break; &#125; tmp_sta/=3; &#125; // for(int i = 0;x[i];i++) // if(x[i] == '*')&#123; // x[i] = 'L'; // res = max(res,-fun(x)); // if(res == 1)return x[i] = '*',1; // x[i] = 'O'; // res = max(res,-fun(x)); // x[i] = '*'; // &#125; return ans[ans_status]=res;&#125;int main()&#123; // clock_t wei=clock(); int t; in(t); char s[23]; pow3[0]=1; for1(i,22)&#123; pow3[i]=pow3[i-1]*3; &#125; while(t--)&#123; // cnt=0; meminf(ans); mem0(iskong); in(s); // cout&lt;&lt;s&lt;&lt;endl; ll tmp=0; len=strlen(s); assert(len&lt;23); // cout&lt;&lt;len&lt;&lt;endl; for0(i,len)&#123; tmp*=3; if(s[i]=='L')tmp+=1; else if(s[i]=='O')tmp+=2; else iskong[len-i-1]=1; &#125; outln(fun(tmp)); // outln(cnt); &#125; // printf("%lu\n",clock()-wei); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>brute force</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1154]]></title>
    <url>%2F2019%2F04%2F19%2FCF-1154%2F</url>
    <content type="text"><![CDATA[E. Two Teams题意一个 $1\sim n$ 的排列, 从大到小删数, 当删一个数时将其左右的 $k$ 个数也删了, 若某个数是第奇数次删的输出 1, 否则输出 2 题解维护两个数组 $l[i],r[i] $ 分别表示第 $i$ 个数左边, 右边的数所在的地方 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int l[N],r[N],Map[N],ans[N],a[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,k; in(n,k); for1(i,n)&#123; in(a[i]); Map[a[i]]=i; l[i]=i-1; r[i]=i+1; &#125; int flag=-1; for(int i=n;i&gt;=1;i--)&#123; if(Map[i])&#123; int poi=Map[i],ml=poi,mr=poi; for(int i=poi,j=0;i&lt;=n&amp;&amp;j&lt;=k;j++,mr=i=r[i])&#123; ans[i]=flag; Map[a[i]]=0; &#125; ml=poi=l[poi]; for(int i=poi,j=0;i&lt;=n&amp;&amp;j&lt;k;j++,ml=i=l[i])&#123; ans[i]=flag; Map[a[i]]=0; &#125; r[ml]=mr; l[mr]=ml; if(flag==-1)flag=-2; else flag=-1; &#125; &#125; for1(i,n)out(-ans[i]); puts(""); return 0;&#125; F. Shovels Shop题意$n$ 个物品, 其价格分别为 $a_i$ , 有 $m$ 种折扣, 买 $x_i$ 件物品, 便宜的 $y_i$ 件免费, 买 $k(\le 2000)$ 件的最小花费 题解$dp[i]$ 表示买 $i$ 件物品的最小花费 $dp[i]=min(dp[i-1]+a[i],dp[i-j]+pre[i]-pre[ i-cost[j] ])$ $cost[i]$ 表示买 $i$ 件物品最小需要支付的物品数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 2.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],dp[2003],cost[2003],pre[2003];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,k,x,y; meminf(cost); in(n,m,k); for1(i,n)in(a[i]); for0(i,m)&#123; in(x,y); if(x&lt;2001) cost[x]=min(cost[x],x-y); &#125; sort(a+1,a+n+1); for1(i,k)pre[i]=pre[i-1]+a[i]; for1(i,k)&#123; dp[i]=dp[i-1]+a[i]; for1(j,i) if(cost[j]&lt;inf) dp[i]=min(dp[i],dp[i-j]+pre[i]-pre[i-cost[j]]); &#125; outln(dp[k]); return 0;&#125; G. Minimum Possible LCM题意给 $n(2\le n \le 1e6)$ 个数, 求最大的 $lcm(a_i,a_j) (1\le a_i\le 1e7)$ 题解枚举 $gcd(a_i,a_j)$ , 找到最小的 $a_i, a_j$ 时间复杂度 $O(\frac {10^7}1+\frac {10^7}2+\frac {10^7}3+\cdots+\frac {10^7}{10^7})\approx O(10^7log(10^7))$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;void out(ll a)&#123;printf("%lld",a);&#125;void outln(ll a)&#123;printf("%lld\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e7;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N][3];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x,maxx=0; in(n); for1(i,n)&#123; in(x); maxx=max(maxx,x); if(a[x][0]==0)&#123; a[x][1]=i; a[x][0]=1; &#125;else if(a[x][0]==1)&#123; a[x][2]=i; a[x][0]=2; &#125; &#125; ll minn=1e18; pii ans; for1(g,maxx)&#123; ll x1=0; for(int j=g;j&lt;=maxx;j+=g)&#123; if(x1)&#123; if(a[j][0])&#123; if(x1*j/g&lt;minn)&#123; ans=pii(a[x1][1],a[j][1]); minn=x1*j/g; &#125; break; &#125; &#125;else&#123; if(a[j][0]==1)&#123; x1=j; &#125;else if(a[j][0]==2)&#123; x1=j; if(x1*x1/g&lt;minn)&#123; ans=pii(a[x1][1],a[j][2]); minn=x1*j/g; &#125; break; &#125; &#125; &#125; &#125; if(ans.fi&gt;ans.se)swap(ans.fi,ans.se); printf("%d %d\n",ans.fi,ans.se); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-ACM-ICPC-Asia-Shenyang]]></title>
    <url>%2F2019%2F04%2F14%2F2017-ACM-ICPC-Asia-Shenyang%2F</url>
    <content type="text"><![CDATA[A. BBP Formula题意 \pi=\sum_{k=0}^{\infty}\frac 1 {16^k}\left( \frac 4 {8k+1}-\frac 2 {8k+4}-\frac 1 {8k+5}-\frac 1 {8k+6}\right)求 $\pi$ 十六进制表达的小数点后第 $n$ 位. 题解求十进制小数的十六进制形式, 去掉整数部分, 小数部分乘 16 得到的数的整数部分就是小数点后第一位的十六进制值, 以此类推. 16^n\sum_{k=0}^{\infty}\frac 1 {16^k} \frac 4 {8k+1} =\sum_{k=0}^{n}\frac {4*16^{n-k}\%(8k+1)} {8k+1}+\sum_{k=n+1}^{\infty}\frac 4 {16^{k-n}(8k+1)}代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;void out(int a)&#123;printf("%d",a);&#125;void outln(int a)&#123;printf("%d\n",a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps;&#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int n;ll qPow(ll a, ll b, ll c) &#123; //求(a^b) % c ll ret = 1; while (b) &#123; if (b &amp; 0x1) ret = ret * a % c; a = a * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;db fun(int a,int b)&#123; db ans=0; for0(i,n+1)&#123; ll w=a*qPow(16,n-i,8*i+b)%(8*i+b); ans+=(db)w/(8*i+b); &#125; ll ppow=1; for1(i,15)&#123; ppow*=16; // cout&lt;&lt;ppow&lt;&lt;endl; ans+=(db)a/ppow/(8*(i+n)+b); &#125; return ans;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; in(t); for1(ca,t)&#123; in(n); n--; db ans=fun(4,1)-fun(2,4)-fun(1,5)-fun(1,6); // cout&lt;&lt;ans&lt;&lt;endl; while(ans&lt;0)ans++; while(ans&gt;1)ans--; // cout&lt;&lt;ans&lt;&lt;endl; int k=ans*16; // cout&lt;&lt;k&lt;&lt;endl; if(k&gt;=10)printf("Case #%d: %d %c\n",ca,n+1,k-10+'A'); else printf("Case #%d: %d %d\n",ca,n+1,k); &#125; return 0;&#125; F. Heron and His Triangle题意设三角形的三条边为 $t-1,t,t+1$ ，给一个 $n(1\le n\le 1e30)$ ，求大于 $n$ 且三角形面积为整数的最小 $t$ 题解由海伦公式得 S=\sqrt {p(p-a)(p-b)(p-c)}\ ,p=\frac {a+b+c}2\\ S=\frac t 2\sqrt {3\left(\left(\frac t 2\right)^2-1\right)}\\ assume\qquad x=\frac t 2\\ x^2-3y^2=1\\ x_n=4x_{n-1}-x_{n-2}代码123456789101112131415161718192021222324252627282930import java.io.*;import java.util.*;import java.math.*; public class Main&#123; public static void main(String[] args) throws IOException&#123; Scanner sc =new Scanner(System.in); int t; t = sc.nextInt(); BigInteger n,maxn=new BigInteger("1000000000000000000000000000000"); Vector&lt;BigInteger&gt;v = new Vector&lt;&gt;(); v.add(BigInteger.valueOf(4)); v.add(BigInteger.valueOf(14)); while(v.lastElement().compareTo(maxn)==-1) &#123; int qq = v.size(); v.add(v.elementAt(qq-1).multiply(BigInteger.valueOf(4)).subtract(v.elementAt(qq-2))); &#125; while(t--!=0) &#123; n=sc.nextBigInteger(); for(Iterator&lt;BigInteger&gt; iter = v.iterator();iter.hasNext();) &#123; BigInteger tmp=iter.next(); if(tmp.compareTo(n)&gt;=0) &#123; System.out.println(tmp); break; &#125; &#125; &#125; sc.close(); &#125;&#125;]]></content>
      <categories>
        <category>icpc</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1144]]></title>
    <url>%2F2019%2F04%2F01%2FCF-1144%2F</url>
    <content type="text"><![CDATA[F. Graph Without Long Directed Paths题意一个严格递增的数列, 一个严格递减的数列, 将它们保持原相对顺序不变合并在一起. 给出合并后的数列. 题解1 (greedy)维护一个递增数列 A, 一个递减的数列 B, 当只能插入一个数列的时候插入对应数列, 当两个都不能插入时输出”NO”, 当两个都能插入时, 若下一个数大于当前数, 插入 A, 否则插入 B. 题解2 (dp)$dp[ i ][ 0 ]​$表示处理完前 i 个， 第 i 个是递增序列序列里的元素，递减序列的最大值。 $dp[ i ][ 1 ]$表示处理完前 i 个， 第 i 个是递减序列序列里的元素，递增序列的最小值。 https://www.cnblogs.com/CJLHY/p/10634175.html 代码123456789101112131415161718192021222324252627282930313233343536373839int a[N],flag[N];vii Inc,Dec;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; in(n); for0(i,n)in(a[i]); Inc.pb(-1); Dec.pb(3e5); for0(i,n)&#123; if(Inc.back()&gt;=a[i]&amp;&amp;Dec.back()&lt;=a[i])&#123; puts("NO"); return 0; &#125; if(Inc.back()&gt;=a[i])&#123; flag[i]=1; Dec.pb(a[i]); continue; &#125; if(Dec.back()&lt;=a[i])&#123; Inc.pb(a[i]); continue; &#125; if(a[i+1]&gt;a[i])&#123; Inc.pb(a[i]); &#125;else &#123; flag[i]=1; Dec.pb(a[i]); &#125; &#125; puts("YES"); for0(i,n)printf("%d ",flag[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>dp</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1139]]></title>
    <url>%2F2019%2F03%2F30%2FCF-1139%2F</url>
    <content type="text"><![CDATA[D. Steps to One题意每次从$1\sim m$从等概率的选择一个数, 直到所有选择的数的 gcd 为 1, 问操作的次数的期望是多少? 题解1设$f[n]​$表示当前 gcd 为 n 还需要的步数的期望 f[n]=1+\frac {\sum\limits_{i=1}^mf[gcd(i,n)]} m\\ \sum\limits_{i=1}^mf[gcd(i,n)]=\sum\limits_{d|n}f[d]\sum\limits_{i=1}^me[gcd(i,n)==d]\\ \sum\limits_{i=1}^me[gcd(i,n)==d]=\sum\limits_{i=1}^{\lfloor \frac m d\rfloor}\epsilon[gcd(i,\frac n d)] \\=\sum\limits_{i=1}^{\lfloor \frac m d\rfloor}\sum\limits_{t|gcd(i,\frac n d)}\mu(t)=\sum\limits_{t|\frac n d}\mu(t)\lfloor \frac m {dt}\rfloor\\ 接下来把右边f[n]的项提出来\\ (m-\lfloor\frac m n\rfloor)f[n]=m+\sum\limits_{d|n,d\ne n}f[d]\sum\limits_{t|\frac n d}\mu(t)\lfloor \frac m {dt}\rfloor\\ ans=1+\frac {\sum\limits_{i=1}^mf[i]} m题解2设$E[n|i]$表示 gcd 为 n 的倍数的期望步数 k=\lfloor\frac m n\rfloor\\ E[n|i]=\sum\limits_{j=1}^{\infty}j*\frac {k^j} {m^j}=\frac {\frac k m} {1-\frac k m}=\frac k {m-k}\\ ans=1+E[i>1]=1+\sum_{j=2}^m-\mu(j)E[j|i]代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//解1int f[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m; cin&gt;&gt;m; for1(i,m)&#123; for(int j=1;j*j&lt;=i;j++)&#123; if(i%j==0)&#123; if(i/j==j)&#123; fac[i].pb(j); &#125;else&#123; fac[i].pb(j); fac[i].pb(i/j); &#125; &#125; &#125; &#125; get_prime(); f[1]=0; ll tot=0; forl(n,2,m)&#123; ll t_tmp=m; for0(j,fac[n].size())&#123; ll d=fac[n][j]; if(d==n)continue; ll cnt=0; for0(k,fac[n/d].size())&#123; int t=fac[n/d][k]; cnt=(cnt+(ll)mu[t]*(m/d/t)%mod)%mod; &#125; t_tmp=(t_tmp+f[d]*cnt%mod)%mod; &#125; f[n]=t_tmp*qPow(m-m/n,mod-2,mod)%mod; tot=(tot+f[n])%mod; // cout&lt;&lt;f[n]&lt;&lt;endl; &#125; printf("%lld\n",(tot*qPow(m,mod-2,mod)%mod+1)%mod); return 0;&#125;//解2bool notPrime[N+1];int prime[N+1],num_prime=0,mu[N+1];void get_prime()&#123; notPrime[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!notPrime[i]) &#123; prime[num_prime++]=i; mu[i]=1; &#125; for(int j=0;j&lt;num_prime&amp;&amp;(ll)i*prime[j]&lt;=N;j++)&#123; int k = i*prime[j]; notPrime[k] = 1; if(i % prime[j] == 0)break; else mu[k]=mod-mu[i]; &#125; &#125;&#125;ll qpow(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b&amp;1)ans=ans*a%mod; a=a*a%mod; b&gt;&gt;=1; &#125; return ans;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m; in(m); get_prime(); ll ans=1; forl(i,2,m)&#123; ll k=m/i; ans=(ans+mu[i]*k%mod*qpow(m-k,mod-2)%mod)%mod; &#125; printf("%lld\n",ans); return 0;&#125; 引用 https://www.cnblogs.com/zyt1253679098/p/10584706.htmlhttps://blog.csdn.net/neuq_zsmj/article/details/88830388]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>dp</tag>
        <tag>number theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-883]]></title>
    <url>%2F2019%2F03%2F27%2FCF-883%2F</url>
    <content type="text"><![CDATA[I. Photo Processing题意将 n 个数分堆，要保证每堆不少于 k 个数，每堆的值为这堆数中的最大值减去最小值，取这些值中的最大值，要是这个最大值最小。 题解二分答案，dp 判断是否可行。$dp[i]$表示将 $1\sim i$ 划分成满足条件的区间，能划分最远的地方。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;int in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;return scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;int in(int &amp;a,int &amp;b,int &amp;c)&#123;return scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;int in(int &amp;a,int &amp;b)&#123;return scanf("%d%d",&amp;a,&amp;b);&#125;int in(ll &amp;a)&#123;return scanf("%lld",&amp;a);&#125;int in(int &amp;a)&#123;return scanf("%d",&amp;a);&#125;int in(char *s)&#123;return scanf("%s",s);&#125;int in(char &amp;s)&#123;return scanf("%c",&amp;s);&#125;int in(db &amp;a)&#123;return scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 3.1e5;const ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int a[N],n,k,dp[N];bool check(int x)&#123; int last=0; forl(i,k,n)&#123; int j=dp[i-k]; if(a[i]-a[j+1]&lt;=x)last=i; dp[i]=last; &#125; return dp[n]==n;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(n,k); for1(i,n)in(a[i]); sort(a+1,a+1+n); int l=0,r=1e9,mid; while(l&lt;=r)&#123; mid=(l+r)/2; if(check(mid))r=mid-1; else l=mid+1; &#125; printf("%d\n",l); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包子凑数]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%8C%85%E5%AD%90%E5%87%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题意给 $n(1\le n\le 100)$ 个数$(1\le a_i\le 100)$，问由它们不能组合(加法)成的数(正整数)的个数，若有无穷个输出”INF”。 题解若它们的公共 gcd 不为1，输出 INF，构造一个小顶堆，每次新加的值为堆顶的值加$a_i$ ，弹出堆顶，可证最大不可表示的值不会超过1e4，所以当堆顶大于1e4的时候跳出循环。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;priority_queue&lt;int,vii,greater&lt;int&gt; &gt;que;bool vis[11000];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,a[110]; mem0(vis); in(n); fro0(i,n)in(a[i]); if(n==1)&#123; if(a[0]==1)puts("0"); else puts("INF"); &#125;else&#123; int gc=a[0]; for1(i,n-1)gc=gcd(gc,a[i]); if(gc==1)&#123; int ans=0; sort(a,a+n); fro0(i,n)&#123; vis[a[i]]=1; que.push(a[i]); &#125; while(1)&#123; int to=que.top(); que.pop(); if(to&gt;=1e4)break; fro0(i,n)&#123; int now=to+a[i]; if(now&lt;=1e4&amp;&amp;vis[now]==0)&#123; vis[now]=1; que.push(now); &#125; &#125; &#125; for1(i,1e4)if(!vis[i])ans++; printf("%d\n",ans); &#125;else puts("INF"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小朋友排队]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%8E%92%E9%98%9F%2F</url>
    <content type="text"><![CDATA[题意n 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是0。如果某个小朋友第一次被要求交换，则他的不高兴程度增加1，如果第二次要求他交换，则他的不高兴程度增加2（即不高兴程度为3），依次类推。当要求某个小朋友第k次交换时，他的不高兴程度增加k。请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。 题解每个人的不高兴度为它的逆序对数(在它前面大于它的，在它后面小于它的)，使用树状数组从前从后分别跑一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define fro1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const db eps = 1e-8;const int N = 1.1e5;ll mod = 1e9+7;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int h,no,cnt; da()&#123;&#125; da(int a,int b)&#123; h=a; no=b; cnt=0; &#125; oper(da)&#123; if(h==y.h)return no&lt;y.no; else return h&lt;y.h; &#125;&#125;a[N];int b[N],n,h;;itn lowbit(int x)&#123; return x&amp;(-x);&#125;int add(int x)&#123; int tmp=0; for(int i=x;i;i-=lowbit(i))&#123; tmp+=b[i]; &#125; for(itn i=x;i&lt;=n;i+=lowbit(i))&#123; b[i]++; &#125; return tmp;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); in(n); fro0(i,n)&#123; in(h); a[i]=da(h,i+1); &#125; sort(a,a+n); ll ans=0; fro0(i,n)&#123; a[i].cnt+=i-add(a[i].no); &#125; mem0(b); forr(i,n-1,0)&#123; a[i].cnt+=add(a[i].no); ans+=(ll)a[i].cnt*(a[i].cnt+1)/2; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>binary indexed tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[波动数列]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%B3%A2%E5%8A%A8%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题意长度为 n 和为 s 而且后一项总是比前一项增加 a 或者减少 b 的整数数列可能有多少种。$1&lt;=n&lt;=1e3，-1e9&lt;=s&lt;=1e9，1&lt;=a, b&lt;=1e6$ 题解设数列首项为$a_1$，增量为$d_1,d_2,\cdots,d_{n-1}$，则$\large na_1+\sum\limits_{i=1}^{n-1}(n-i-1)d_i=s$因为$a_1$可以取任意值，所以$\large \sum\limits_{i=1}^{n-1}(n-i-1)d_i\equiv s (mod n)$$dp[i][j]$表示长度为$i$，$\large \sum\limits_{k=1}^{i-1}(n-k-1)d_k mod n=j$ 的方案数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define fro0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define oper(type) bool operator &lt;(const type y)const#define mp make_pair#define pb push_back#define fi first#define se secondtypedef pair&lt;long long, long long&gt; pll;typedef vector&lt;long long&gt; vll;typedef pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef vector&lt;int&gt; vii;typedef long double db;typedef long long ll;typedef int itn;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e8+7;const int N = 1.1e3;const db eps = 1e-8;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;void in(int &amp;a,int &amp;b,int &amp;c,int &amp;d)&#123;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);&#125;void in(int &amp;a,int &amp;b,int &amp;c)&#123;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);&#125;void in(int &amp;a,int &amp;b)&#123;scanf("%d%d",&amp;a,&amp;b);&#125;void in(ll &amp;a)&#123;scanf("%lld",&amp;a);&#125;void in(int &amp;a)&#123;scanf("%d",&amp;a);&#125;void in(char *s)&#123;scanf("%s",s);&#125;void in(db &amp;a)&#123;scanf("%Lf",&amp;a);&#125;ll dp[N][N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,s,a,b,nxt; in(n,s,a,b); s=(s%n+n)%n,a%=n,b%=n; dp[1][0]=1; for1(i,n-1)&#123; for0(j,n)&#123; nxt=(j+a*(n-i)%n)%n; dp[i+1][nxt]=(dp[i+1][nxt]+dp[i][j])%mod; nxt=(j-b*(n-i)%n+n)%n; dp[i+1][nxt]=(dp[i+1][nxt]+dp[i][j])%mod; &#125; &#125; printf("%lld\n",dp[n][s]); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁感冒]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%9A%82%E8%9A%81%E6%84%9F%E5%86%92%2F</url>
    <content type="text"><![CDATA[题意长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。 题解首先明白两只蚂蚁碰撞之后掉头和穿行过去是一样的，可以把穿行看做碰撞后掉头了，然后两个蚂蚁交换了，而是哪一只蚂蚁对结果不影响。那么，假如第一只感冒蚂蚁向右走，那么碰到所有想左走的都会被感染，而感染后的蚂蚁必定是向左走的，那么他会把左边向右走的都感染了。向左走的也是这样。所以 ans = 左边向右走的 + 右边向左走的 + 1（本身）。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct da&#123; int num; bool kind; da()&#123;&#125; da (int a,bool b)&#123; num=a; kind=b; &#125; bool operator &lt;(const da y)const&#123; return num&lt;y.num; &#125;&#125;a[55];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,x; ind(n); for0(i,n)&#123; ind(x); if(x&lt;0)&#123; a[i]=da(-x,0); &#125;else a[i]=da(x,1); &#125; x=a[0].num; bool flag=a[0].kind,right=0; sort(a,a+n); int l=0,r=0; for0(i,n)&#123; if(a[i].num==x)&#123; right=1; continue; &#125; if(right&amp;&amp;a[i].kind==0)&#123; r++; &#125;else if(!right&amp;&amp;a[i].kind)&#123; l++; &#125; &#125; int ans=1; if(l&amp;&amp;r)ans+=l+r; else if(flag)&#123; ans+=r; &#125;else ans+=l; printf("%d\n",ans); return 0;&#125; 引用https://blog.csdn.net/y990041769/article/details/21941711]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CF-11]]></title>
    <url>%2F2019%2F03%2F22%2FCF-11%2F</url>
    <content type="text"><![CDATA[D. A Simple Task题意求出一个n个点m个边的图，求简单环有多少（没有重复点和边）。（n&lt;20） 题解用S能记录状态（有多少个点在路径中），那么如何找环能确保不重不漏啦，对于一个环，找出他的特异性记录，一个环，如果以最小点为环的“起始点”，则每个环都被记录啦两次。用dp[s][i]表示路径s的当前点为i的次数，枚举下一点，如果形成环就加上答案，否则记录下一边。由于题目求的是超过三个点的简单环，而之前所求两个点也会被记录。减掉就可以啦。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(25)using namespace std;ll dp[1&lt;&lt;19][N];int n,m;bool a[N][N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); scanf("%d%d",&amp;n,&amp;m); int u,v; ll ans=0; for0(i,m)&#123; scanf("%d%d",&amp;u,&amp;v); u--;v--; a[u][v]=a[v][u]=1; &#125; for0(i,n)dp[1&lt;&lt;i][i]=1; for(int i=1;i&lt;1&lt;&lt;n;i++)&#123; int st; for0(k,n) if(i&amp;(1&lt;&lt;k))&#123; st=k; break; &#125; for(int k=st+1;k&lt;n;k++)&#123; if(dp[i][k]==0)continue; if(a[k][st]&amp;&amp;__builtin_popcount(i)&gt;2)ans+=dp[i][k]; &#125; for(int j=st;j&lt;n;j++)&#123; if(dp[i][j]==0)continue; for(int k=st+1;k&lt;n;k++) if(a[j][k]&amp;&amp;!(i&amp;(1&lt;&lt;k)))dp[i+(1&lt;&lt;k)][k]+=dp[i][j]; &#125; &#125; printf("%lld\n",ans/2); return 0;&#125; 引用 https://blog.csdn.net/m0_37953323/article/details/77169608]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4651]]></title>
    <url>%2F2019%2F03%2F22%2FHDU-4651%2F</url>
    <content type="text"><![CDATA[题意整数拆分，$(1\le n\le 10^5)$ 题解使用五边形定理 P(n)=\sum\limits_{k=1}^n(-1)^{k+1}\left [P\left( n-\frac 1 2k(3k-1)\right)+P\left( n-\frac 1 2k(3k+1)\right )\right ]其中n-\frac 1 2k(3k-1)>=0 , n-\frac 1 2k(3k+1)>=0 ，注意两个条件要分开判断，有大于0的就加上相应的f，不是两个同时成立或者不成立 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(1.1e5)using namespace std;int p[N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); p[0]=1; for1(i,100005)&#123; ll fl=1,an=0,flag=1; while(1)&#123; ll tmp=fl*(3*fl-1)/2; if(i-tmp&lt;0)break; an=(an+flag*p[i-tmp]+mod)%mod; tmp=fl*(3*fl+1)/2; if(i-tmp&lt;0)break; an=(an+flag*p[i-tmp]+mod)%mod; fl++; flag*=-1; &#125; p[i]=an; // printf("%d\n",tmp); &#125; int t,n; ind(t); while(t--)&#123; ind(n); printf("%d\n",p[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂题]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%9D%82%E9%A2%98%2F</url>
    <content type="text"><![CDATA[One题意将整数n拆分为m个数的和，输出这m个数or的最小值。 题解要想使或值最小，那么m个二进制数中的最高位应尽量小，假如存在k使$(2^k-1)m &gt; n &gt; (2^{k-1}-1)*m$，所以m个二进制数中至少有一个数的最高位为k。因为是取各位取或，所以此时应让尽量多的数的第k位为1，$ans += 2^k$，从高位向低位递推，直到n变为0。 Two题意 \Large\sum\limits_{i=1}^n\lfloor\frac n i\rfloor代码123456789101112//solution1int k=sqrt(n+0.1);for (int i = 1; i &lt;= k; i++) &#123; ans+=n/i; if (n/(i+1)&lt;i)break; else ans+=(n/i-n/(i+1))*i;&#125;//solution2for (int i = 1; i &lt;= k; i++) ans+=n/i;ans*=2;ans-=k*k; Three题意设一个排列，当i为奇数，a[i]&gt;a[i-1]，求满足条件的长度为n的数量 题解设答案是 $f(n)$考虑最⼤大的数的位置是 i，则变成一个长度为 i-1 的数列列和一个长度为 n-i 的数列列所以 $f(n)=\sum\frac {f(i)f(n-i-1)} n$所以 $f(x)’=f(x)^2+1$解得 $f(x)=tan(x)$ Four题解n+1个数由1-n 组成，只有一个重复的，找出来。 代码123456789101112131415161718192021int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int low = nums[0], fast = nums[nums[0]]; while (low != fast) &#123; low = nums[low]; fast = nums[nums[fast]]; &#125; fast = 0; while (low != fast) &#123; low = nums[low]; fast = nums[fast]; &#125; return low;&#125;int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[abs(nums[i]) - 1] &lt; 0) return abs(nums[i]); nums[abs(nums[i]) - 1] *= -1; &#125; return -1;&#125;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-4055 Number String]]></title>
    <url>%2F2019%2F03%2F22%2FHDU-4055%2F</url>
    <content type="text"><![CDATA[题意给你一个字符串s，s[i] = ‘D’表示排列中a[i] &gt; a[i+1]，s[i] = ‘I’表示排列中a[i] &lt; a[i+1]。 比如排列 {3, 1, 2, 7, 4, 6, 5} 表示为字符串 DIIDID。 题解很巧妙的DP做法，$dp[i][j]$表示前i个满足字符串条件的结尾为j的 i 的排列，注意是i的排列，前面并没有数大于i。那又是如何往下递推呢？ 如果s[i - 1]是’ I ‘，那么$dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + .. + dp[i-1][1]$如果s[i - 1]是‘D’，那么$dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + … + dp[i-1][i]$，因为要令当前位为j，如果前面出现过j，就令前面的所有大于等于j的数+1，就能构造出新的排列了。 比如{1, 3, 5, 2, 4}，要在第六位插入3,令 &gt;= 3的数都+1，于是就构造出新的 排列{1, 4, 6, 2, 5, 3}。然后代码的话处理出前缀和$sum[i][j]$，就不用$dp[i][j]$了。 代码123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;typedef __int64 ll; const int maxn = 1000 + 5;const int mod = 1000000007; ll sum[maxn][maxn];char s[maxn]; int main() &#123; while(scanf("%s", s) != -1) &#123; int len = strlen(s); sum[0][1] = 1; for(int i = 1;i &lt;= len; i++) &#123; for(int j = 1;j &lt;= i+1; j++) &#123; sum[i][j] = sum[i][j-1]; if(s[i-1] != 'D') sum[i][j] += sum[i-1][j-1]; if(s[i-1] != 'I') sum[i][j] += sum[i-1][i] - sum[i-1][j-1] + mod; sum[i][j] %= mod; &#125; &#125; printf("%I64d\n", sum[len][len+1]); &#125; return 0;&#125; 引用https://blog.csdn.net/jayye1994/article/details/12361481]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LightOJ-1197 Help Hanzo]]></title>
    <url>%2F2019%2F03%2F22%2FLightOJ-1197%2F</url>
    <content type="text"><![CDATA[题意求a~b间素数个数(1 ≤ a ≤ b &lt; 2^31, b - a ≤ 100000). 题解b-a这个区间比较小，所以可以用区间素数筛选的办法解决这个题目。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem1(a) memset(a, 1 , sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;const int N=100005;bool a[N+1];vector&lt;int&gt; prime;void getPrime()&#123; memset(a,true,sizeof(a)); for(int i=2;i&lt;=N;i++)&#123; if(a[i]) prime.push_back(i); for(int j=0;j&lt;(int)prime.size()&amp;&amp;i*prime[j]&lt;=N;j++)&#123; a[i*prime[j]]=false; if(!(i%prime[j])) break; &#125; &#125;&#125;int main()&#123; //ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); //freopen("in.txt", "r", stdin); ll t,a,b; bool isprime[100005]; getPrime(); //cout&lt;&lt;prime.size(); cin&gt;&gt;t; for1(k,t)&#123; int ans=0; cin&gt;&gt;a&gt;&gt;b; mem1(isprime); for(int i=0;prime[i]*prime[i]&lt;=b&amp;&amp;i&lt;(int)prime.size();i++)&#123; ll l=a/prime[i]; if (l*prime[i]&lt;a) l++; if (l&lt;2) l=2; for (; l*prime[i]&lt;=b; l++) isprime[l*prime[i]-a]=0; &#125; if (a==1) isprime[0]=0; for0(i,b-a+1) if (isprime[i])ans++; printf("Case %d: %d\n",k,ans ); &#125; return 0;&#125;]]></content>
      <categories>
        <category>lightoj</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3167 Cow Patterns]]></title>
    <url>%2F2019%2F03%2F22%2FPOJ-3167%2F</url>
    <content type="text"><![CDATA[题意一个农场主有N头牛，每个牛都以它身上的斑点数作为标志，以斑点数作为标准对牛进行rank排序，定义牛的序列的相同性为第i头牛及其之前的牛的比他rank小的数量和与他rank相同的数量，比如：1 4 4 3 2 1 和 2 10 10 7 3 2 是一样的模式串要求数有多少个符合要求的模式串，并输出每个符合要求的子串的起始位置。 题解定义一个函数getval(ch,str,l,r)，返回的值为ch在$str[l~r]$中的真实值，即将$str[l~r]​$中的值排序离散化后ch的值。则题意即为：在a串中找出一段长为m的区间[l,r]，使对任意的1≤i≤m，getval(a[l+i-1],a,l,r)均等于getval(b[i],b,1,m)getval的值，其实是返回某个数(数跟字符其实是一样的)在某堆数中的排名。是什么决定了一个数x的排名？是小于x的数的个数，等于x的数的个数。如果这两个个数与另一个y的两个个数都相等，那么x跟y在各自字符串的各自区间内的getval值就相等了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))n#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(1.1e5)using namespace std;int Next[N],sump[N][30],now[30],sums[N][30],n,k;vector&lt;int&gt;ans;bool check(int l,int r,int sump[][30],int sums[][30],int *p,int*s)&#123; int lep=0,les=0; for1(i,p[l]-1)lep+=sump[l][i]; for1(i,s[r]-1)les+=sums[r][i]-sums[r-l][i]; if(lep==les&amp;&amp;sump[l][p[l]]==sums[r][s[r]]-sums[r-l][s[r]])return 1; else return 0;&#125;void kmp_pre(int *p, int p_len, int Next[]) &#123; // Next[i] 为满足 p[i-z...i-1]=p[0...z-1] 的最大 z 值(就是 p的自身匹配) int i = 0, j = Next[0] = -1; while (i &lt; p_len) &#123; while (j != -1 &amp;&amp; !check(j,i,sump,sump,p,p)) j = Next[j]; Next[++i] = ++j; &#125;&#125;void KMP(int *p, int *s) &#123; // p 是模式串，s 是主串 int i = 0, j = 0, p_len = k, s_len =n; for1(i,p_len)&#123; memcpy(sump[i],sump[i-1],30*sizeof(int)); sump[i][p[i-1]]++; &#125; for1(i,s_len)&#123; memcpy(sums[i],sums[i-1],sizeof(sums[i])); sums[i][s[i-1]]++; &#125; kmp_pre(p, p_len, Next); while (i &lt; s_len) &#123; while (-1 != j &amp;&amp; !check(j,i,sump,sums,p,s)) j = Next[j]; i++;j++; if (j &gt;= p_len) &#123; ans.push_back(i); j = Next[j]; &#125; &#125;&#125;int p[N],S[N];int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int q; scanf("%d%d%d",&amp;n,&amp;k,&amp;q); for0(i,n)ind(S[i]); for0(i,k)ind(p[i]); KMP(p,S); //puts(""); printf("%d\n",(int)ans.size()); for0(i,ans.size())printf("%d\n",ans[i]-k+1); return 0;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-675]]></title>
    <url>%2F2019%2F03%2F22%2FCF-675%2F</url>
    <content type="text"><![CDATA[C. Money Transfers题意有n家银行围成一个圈，有个人在有些银行里欠了钱，在一些银行里有存钱，欠的钱总数等于存的钱总数。现在可以有操作，如果两个银行相邻，那么就能在一个银行转任意多的钱到另一个银行。问最少的操作次数，使得在所有银行的存款钱数都为0。 题解首先我们要发现第一个贪心。如果有一段子串，里面的数字之和等于0，那么在这段子串中移动数字，所需要的代价为子串长度len-1，那么问题就转换成了，我们在这个圈中能找到多少段子串，里面的数字之和等于0，而且段数越多越好，记为k，那么很明显，答案就是n-k，现在问题来了，如何来求满足题意的最大的k。首先，我们考虑用前缀和来存放，如果遇到两个位置，前缀和相等，那么中间那一段数字之和肯定等于0。接下来就是一个跳跃性的思考了，那么如果某个前缀和的值出现了k次，是不是就是我们上述的k呢？答案是正确的！假如有k个位置的前缀和相等，那么中间k-1段子串内数字之和一定都是0，由于总数是0，那么最前面和最后面连着的那一段也肯定是0，所以，我们记录所有的前缀和的值，然后排序。然后用取尺法记录一个数出现的最多次数，就做完了 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;strstream&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define MOD 1000000007#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int n,maxx=1,tmp; ll pre=0; map&lt;ll,int&gt;log; cin&gt;&gt;n; for0(i, n)&#123; cin&gt;&gt;tmp; pre+=tmp; if (log.count(pre)) &#123; log[pre]++; maxx=max(maxx, log[pre]); &#125;else log[pre]=1; &#125; cout&lt;&lt;n-maxx&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-5970 最大公约数]]></title>
    <url>%2F2019%2F03%2F22%2FHDU-5970%2F</url>
    <content type="text"><![CDATA[题意给一个函数 12345678910int f(int x,int y)&#123; int c=0; while(y&gt;0)&#123; c++; t=x%y; x=y; y=t; &#125; return c*x*x;&#125; 给出n,m,p，求$\Large\sum\limits_{i=1}^n\sum\limits_{j=1}^m\lfloor\frac {i*j} {f(i,j)}\rfloor$ 题解 ans=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{i+j*k\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor\\=\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*(k+p*c))} {c*x*x}\rfloor\\ =\sum\limits_{j=1}^m\sum\limits_{i=1}^j\sum\limits_{k=0}^{c-1}\sum\limits_{p=0}^{i+j*(k+p*c)\le n}\lfloor\frac {j*(i+j*k)} {c*x*x}\rfloor+\frac {p*j*j} {x*x}代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)using namespace std;#define mod (int)(1e9 + 7)#define N (int)(1.1e5)int f[700][700], c[700][700];void fun(int x, int y) &#123; int b = 0, i = x, j = y; while (y) &#123; b++; int tmp = x % y; x = y; y = tmp; &#125; c[i][j] = b; f[i][j] = b * x * x;&#125;int main() &#123;#ifndef ONLINE_JUDGE //freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif for1(i, 666) for1(j, 666) fun(i, j); int t; ind(t); while (t--) &#123; int n, m, p; ll ans = 0; scanf("%d%d%d", &amp;n, &amp;m, &amp;p); for1(j, m) &#123; for (int i = 1; i &lt;= j &amp;&amp; i &lt;= n; i++) &#123; int k = (n - i) / j; int tt = c[i][j] * j * j / f[i][j]; for (int q = 0; q &lt; c[i][j]&amp;&amp;q&lt;=k ; q++) &#123; //if (i + q * j &gt; n) break; //ll t = (n - (i + j * q)) / (c[i][j] * j) + 1; ll t=(k-q)/c[i][j]+1; ll tmp=(i+j*q)*j/f[i][j]; ans=(ans+tmp*t%p+(t-1)*t/2%p*tt%p)%p; // ll b = (i + j * q) * j / f[i][j]; // ans = (ans + b * t % p + (t - 1) * t / 2 % p * tt % p) % p; &#125; &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1050 To the Max]]></title>
    <url>%2F2019%2F03%2F21%2FPOJ-1050%2F</url>
    <content type="text"><![CDATA[题意求最大子矩阵和。 题解枚举列区间，将该区间的值压缩到一起，转化成求一维最大字段。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;vector&gt;#define ll long long#define inf 0x3f3f3f3f#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main() &#123; ios::sync_with_stdio(false); int n, a[101][101],b[101][101]; cin &gt;&gt; n; mem0(b); for0(i, n) &#123; for0(j, n)&#123; cin&gt;&gt;a[i][j]; b[i][j+1]=b[i][j]+a[i][j]; &#125; &#125; int ans=0; for0(i, n) forl(j, i+1, n)&#123; int tmp=0; for0(k, n)&#123; tmp+=b[k][j]-b[k][i]; if (tmp&lt;0) &#123; tmp=0; &#125;else if(tmp&gt;ans)&#123; ans=tmp; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1024 Max Sum Plus Plus]]></title>
    <url>%2F2019%2F03%2F21%2FHDU-1024%2F</url>
    <content type="text"><![CDATA[题意给你一个序列n个数组成，然后让你在里面找到m个子序列，让这m个子序列的和最大。 题解$dp[i][j]$表示的是第j个数字在第i个子序列时的当前最优值。$dp[i][j] = maxx(dp[i][j-1] + num[j] ,maxx(dp[i-1][k]) + num[j])$，k是从1到 $j-1$.可以这么理解这个转移方程，对于当前的这个数字，如果把他放到第i个子序列中有两种情况，一个是他作为第i个子序列的第一个数字，另一个就是不作为第一个数字，作为第一个数字的时候是 $max(dp[i-2][k] + num[j]) ,1&lt;=k&lt;i $的意思是从之前的所有中找到 $i-1$ 个子序列的最大值+当前的值，不做为第一个的时候那么他前面的那个数字一定是i序列的，同一个子序列，又不是作为第一个，那么前面的那个货就一定是同一个子序列的，那么当前的值是$dp[i][j-1] + num[j]$,在两种决策中选择一个最有的就行了，还有就是$max(dp[i-1][k]+num[j])$的这个地方可以开一个数组记录下来，不能每次都跑，跑不起，再有就是这个题目没有给m的范围，所以开不了二维数组（目测不是很大，大的话会超时，但是肯定是先超内存在超时，所以为了保险，还是吧$dp[][]$压缩成一维的）那么状态转移就边成这样了$dp[j]$表示的是 j这个人在当前的这个子序列中的最优值，mk[j]表示的是在上一个子序列中1—j的dp的最大值，所以就变成 $dp[j] = maxx(dp[j-1] + num[j] ,mk[j-1]+num[j])$;还是 max(作为i个子序列的第一个元素，不是第一个元素取一个最大值)。在解释下代码的核心部分。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;ctime&gt;#include &lt;strstream&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int d[1000006],a[1000006],pre_max[2][1000006];int main()&#123; int n,m; while (cin&gt;&gt;m&gt;&gt;n) &#123; memset(d, 0, sizeof(d)); memset(pre_max, 0, sizeof(pre_max)); for (int i=1; i&lt;=n; i++) scanf("%d",&amp;a[i]); int maxx; //pre_max[0][0]=-99999999;pre_max[1][0]=-99999999; for (int i=1; i&lt;=m; i++) &#123; maxx=-9999999; for (int j=i; j&lt;=n; j++) &#123; d[j]=max(d[j-1]+a[j], pre_max[(i+1)%2][j-1]+a[j]); maxx=max(maxx, d[j]); pre_max[i%2][j]=maxx; &#125; &#125; cout&lt;&lt;pre_max[m%2][n]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-2559 Largest Rectangle in a Histogram]]></title>
    <url>%2F2019%2F03%2F21%2FPOJ-2559%2F</url>
    <content type="text"><![CDATA[题意 求柱形图中的最大矩形面积。 题解法一: 求每个点左边连续比它大的最左边的下标，保存在l[]数组里,求每个点右边连续比它大的最右边的下标，保存在r[]数组里 法二: 维护一个单调栈, 如果h大于栈顶元素，则入栈, 否则，将栈内元素出栈，直到满足上面的条件。出栈时，我们要将出栈元素对之后问题的影响全部考虑进行处理，才能保证做法的正确性。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;ctime&gt;#define ull unsigned long long#define ll long long#define inf 0x3f3f3f3f#define mod (int)1e9+7#define for0(i, n) for (int i = 0; i &lt; n; i++)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forn(i, n) for (int i = n; i &gt;= 0; i--)#define mem0(a) memset(a, 0, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define meminf(a) memset(a, inf, sizeof(a))using namespace std;int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int n,tmp; while (cin&gt;&gt;n&amp;&amp;n) &#123; ll ans=0; vector&lt;pair&lt;int, int&gt; &gt;sta; for0(i, n)&#123; cin&gt;&gt;tmp; int count=0; forn(i, sta.size()-1)&#123; if (sta[i].first&gt;tmp) &#123; count+=sta[i].second; ans=max(ans, (ll)sta[i].first*count); sta.pop_back(); &#125;else break; &#125; sta.push_back(pair&lt;int, int&gt;(tmp,count+1)); &#125; int count=0; forn(i, sta.size()-1)&#123; count+=sta[i].second; ans=max(ans, (ll)sta[i].first*count); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1012]]></title>
    <url>%2F2019%2F03%2F21%2FCF-1012%2F</url>
    <content type="text"><![CDATA[B. Chemical table题意 一个 n*m 的矩阵，当涂了三个角时，会自动涂第四个，已有一些点涂色，问最少需要涂几个点。 题解只需n+m-1个就可以填满,当插入点(x1,y1) 时有关系x1&lt;=&gt;y1当插入点(x2,y1) 时有关系 x2&lt;=&gt;y1&lt;=&gt;x1当插入点(x1,y2) 时有关系 y2&lt;=&gt;x1&lt;=&gt;y1&lt;=&gt;x2用并查集来连接 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld",&amp;lld)typedef unsigned long long ull;#define inlf(f) scanf("%lf",&amp;f)#define ind(d) scanf("%d",&amp;d)#define ins(s) scanf("%s",s)#define inf 0x3f3f3f3ftypedef long long ll;#define pi acos(-1.0)#define mod (int)(1e9+7)#define N (int)(4.1e5)using namespace std;int uni[N+1];void init()&#123; for1(i,N)uni[i]=i;&#125;int find_root(int x)&#123; if (uni[x]==x) return x; else return uni[x]=find_root(uni[x]);&#125;int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat","w",stdout);#endif //ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); init(); int n,m,q,r,c,ans=0; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for0(i,q)&#123; scanf("%d%d",&amp;r,&amp;c); uni[find_root(m+r)]=find_root(c); &#125; for1(i,n+m)if(uni[i]==i)ans++; printf("%d\n",ans-1); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[城市建设]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[题意n 个城市，m 条道路，每条道路有一个权值(可能为负)，每个点有一个权值，表示修建码头的费用(为-1时表示不可以修建码头)。 题解ans1不修建码头的最小生成树ans2额外添加一个0号城市，将可建立码头的城市与它相连，求出的最小生成树当不建码头也能联通时，答案为min(ans1,ans2)，否则答案为 ans2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 2e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct Edge&#123; int u,v,c; Edge()&#123;&#125; Edge(int a,int b,int _c)&#123; u=a,v=b,c=_c; &#125; bool operator &lt;(const Edge y)const&#123; return c&lt;y.c; &#125;&#125;edge[N];int uni[N];int find_r(int x)&#123; if(x==uni[x])return x; else return uni[x]=find_r(uni[x]);&#125;int merge(Edge x)&#123; int fa=find_r(x.u),fb=find_r(x.v); if(fa!=fb)&#123; uni[fa]=fb; return 1; &#125; if(x.c&lt;0)return -1; else return 0;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,c,w,Size=0; ll ans1=0,ans2=0; scanf("%d%d",&amp;n,&amp;m); for0(i,m)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); edge[Size++]=Edge(u,v,c); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); int cnt=0; for0(i,Size)&#123; switch(merge(edge[i]))&#123; case 1: ans1+=edge[i].c; cnt++; break; case -1: ans1+=edge[i].c; &#125; &#125; for1(i,n)&#123; ind(w); if(w&gt;0)edge[Size++]=Edge(0,i,w); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); for0(i,Size)&#123; if(merge(edge[i]))ans2+=edge[i].c; &#125; if(cnt==n-1)ans2=min(ans2,ans1); printf("%lld\n",ans2); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%2F</url>
    <content type="text"><![CDATA[题意$f(x)$为斐波那契数列，求$\large\left(\sum\limits_{i=1}^nf(i)\right) mod f(m) mod p​$ $0&lt;n,m,p&lt;1e18$ 题解 f(n+m)=f(n+1)f(m)+f(n)f(m-1) \\ f(n)\ mod\ f(m)=f(n-m)f(m-1)\ mod\ f(m)\\ f(n)\ mod \ f(m)=f(m-1)^{\frac n m}f(n\%m)\ mod\ f(m)\\ f(n)^2=(-1)^{n+1}+f(n-1)f(n+1)\\ f(m-1)^2\ mod\ f(m)=(-1)^m m 为偶数 $\frac n m​$为偶数，$f(n) mod f(m)=f(n\%m)​$ $\frac n m​$为奇数，$f(n) mod f(m)=f(m-1)f(n\%m) mod f(m)​$ m 为奇数 $\frac n m$为偶数，$\frac n {2m}$为偶数，$f(n) mod f(m)=f(n\%m)$ $\frac n m$为偶数，$\frac n {2m}$为奇数，$f(n) mod f(m)=f(m)-f(n\%m)$ $\frac n m​$为奇数，$\frac n {2m}​$为偶数，$f(n) mod f(m)=f(m-1)f(n\%m) mod f(m)​$ $\frac n m$为奇数，$\frac n {2m}$为奇数，$f(n) mod f(m)=f(m)-f(m-1)f(n\%m) mod f(m)$ 简化$f(m-1)f(n\%m) mod f(m)​$ 性质：若$n\ge1,r\ge2$，则$f(n)f(n+r-1)-f(n+1)f(n+r-2)=(-1)^{n+1}f(r-2)$ 令$k=n\%m,k=n+1,m-1=n+r-2$，则$f(n)f(k-1)-f(m-1)f(k)=(-1)^kf(m-k)$ 所以$f(m-1)f(k) mod f(m)=(-1)^{k+1}f(m-k) mod f(m)$ 当$k$为奇时，$f(m-1)f(n\%m) mod f(m)=f(m-k)$ 当$k$为偶时，$f(m-1)f(n\%m) mod f(m)=f(m)-f(m-k)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f; ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct matrix &#123; ll a[2][2]; matrix()&#123; mem0(a); &#125;&#125;;ll qMulti(ll x,ll y,ll mod)&#123; //O(1)快速乘 return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod; &#125;matrix mat_mul(matrix x, matrix y) &#123; matrix res; for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) res.a[i][j] = (res.a[i][j] + qMulti(x.a[i][k] , y.a[k][j],mod) ) % mod; return res;&#125;ll mat_pow(ll n) &#123; if (n &lt;= 2) return 1; n -= 2; matrix c, res; c.a[0][0] = c.a[0][1] = c.a[1][0] = 1; for (int i = 0; i &lt; 2; i++) res.a[i][i] = 1; while (n) &#123; if (n % 2) res = mat_mul(res, c); c = mat_mul(c, c); n /= 2; &#125; return (res.a[0][0] + res.a[0][1]) % mod;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll n,m,p; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; mod=p; n+=2; ll k=n/m; if(n%m==0)&#123; cout&lt;&lt;((mat_pow(m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; int Sign; if(m%2)Sign=-1; else Sign=1; if(k%2)&#123; k/=2; if(k%2==0)Sign=1; if(n%m%2==0)Sign=-Sign; if(Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; k/=2; if(k%2&amp;&amp;Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125; &#125; return 0;&#125; 引用https://blog.csdn.net/acdreamers/article/details/21822165]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形排版]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9B%BE%E5%BD%A2%E6%8E%92%E7%89%88%2F</url>
    <content type="text"><![CDATA[题意小明需要在一篇文档中加入 N 张图片，其中第 i 张图片的宽度是 Wi，高度是 Hi。假设纸张的宽度是 M，小明使用的文档编辑工具会用以下方式对图片进行自动排版： 该工具会按照图片顺序，在宽度 M 以内，将尽可能多的图片排在一行。该行的高度是行内最高的图片的高度。例如在 M=10 的纸张上依次打印 3x4, 2x2, 3x3 三张图片，则效果如下图所示，这一行高度为4。(分割线以上为列标尺，分割线以下为排版区域；数字组成的矩形为第x张图片占用的版面) 如果当前行剩余宽度大于0，并且小于下一张图片，则下一张图片会按比例缩放到宽度为当前行剩余宽度(高度向上取整)，然后放入当前行。例如再放入一张4x9的图片，由于剩余宽度是2，这张图片会被压缩到2x5，再被放入第一行的末尾。此时该行高度为5： 如果当前行剩余宽度为0，该工具会从下一行开始继续对剩余的图片进行排版，直到所有图片都处理完毕。此时所有行的总高度和就是这 N 张图片的排版高度。例如再放入11x1, 5x5, 3x4 的图片后，效果如下图所示，总高度为11： 现在由于排版高度过高，图片的先后顺序也不能改变，小明只好从 N 张图片中选择一张删除掉以降低总高度。他希望剩余N-1张图片按原顺序的排版高度最低，你能求出最低高度是多少么？ 题解预处理以第 i 张图为行首的最低高度，然后枚举删图。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;pii a[N],b[N];int suf[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m,n,w,h; scanf("%d%d",&amp;m,&amp;n); for0(i,n)&#123; scanf("%d%d",&amp;w,&amp;h); a[i]=pii(w,h); &#125; for0(i,n)&#123; w=m; h=0; int len=i; for(;len&lt;n&amp;&amp;w;len++)&#123; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; // cout&lt;&lt;h&lt;&lt;endl; b[i]=pii(len,h); &#125; // puts(""); // for0(i,n)cout&lt;&lt;b[i].first&lt;&lt;' '&lt;&lt;b[i].second&lt;&lt;endl; for(int i=n-1;i&gt;=0;i--)&#123; suf[i]=suf[b[i].first]+b[i].second; &#125; // for0(i,n)cout&lt;&lt;suf[i]&lt;&lt;endl; int ans=inf,flag=0,tot=0; while(flag&lt;n)&#123; for(int i=flag;i&lt;b[flag].first;i++)&#123; w=m; h=0; int len=flag; for(;len&lt;n&amp;&amp;w;len++)&#123; if(len==i)continue; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; ans=min(ans,tot+h+suf[len]); &#125; tot+=b[flag].second; flag=b[flag].first; // tot+= &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格子刷油漆]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%A0%BC%E5%AD%90%E5%88%B7%E6%B2%B9%E6%BC%86%2F</url>
    <content type="text"><![CDATA[题意给一个$2*N$的矩阵，可以从任意一个格子刷起，但只能移动到和它相邻的格子（可以对角），求总的方案数，对$1e9+7$取模。 题解设a[n]为起点为某一角落长度为n终点任意的情况数，b[n]为起点为某一角落长度为n终点必须同列的情况数。 $b[i]=2^{i-1}$ 当起点在四个角落，以左上角为例 情况一，先向下移动，再向右移动某个位置，情况数相当于 做长度为i-1的终点任意的情况数*2 因为不需要在回到第一列，而且到第二列的时候可能是第一行或者第二行，即$a[i-1]*2$ 情况二，从起点出发最终回到第一列的第二行，那么情况数就是b[i]。 先进入第二列，然后返回第一列另一个位置，然后再回第二列，即$22a[i-2]$ 当起点在中间 情况一，向左运动后回到第i列然后向右运动 情况二，向右运动后回到第i列然后向左运动 \sum\limits_{i=2}^{n-1}2*(b[i+1]*a[n-i]+b[n-i+2]*a[i-1]) $a[1]=1,a[2]=6$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll a[N],b[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,ans=0; b[1]=1; forl(i,2,1e3)&#123; b[i]=b[i-1]*2%mod; &#125; a[1]=1;a[2]=6; forl(i,3,1e3)&#123; a[i]=(2ll*a[i-1]+b[i]+4ll*a[i-2])%mod; &#125; ind(n); if(n==1)&#123; puts("2"); return 0; &#125; ans=4ll*a[n]%mod; forl(i,2,n-1)&#123; ans=(ans+2ll*(b[i+1]*a[n-i]%mod+b[n-i+2]*a[i-1]%mod))%mod; &#125; printf("%d\n",ans); return 0;&#125; 引用https://blog.csdn.net/qq_35078631/article/details/54730870]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高僧斗法]]></title>
    <url>%2F2019%2F03%2F20%2F%E9%AB%98%E5%83%A7%E6%96%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题意n 个物品放在阶梯，向上移动物品，不能越过挡在前面的物品，最后物品都挤在高段台阶，不能移动的输。 题解两两一组，当移动上面的，可以移动下面的相同距离，所以可以把每组之间的间距看作一堆石子，转化为 Nim 博弈。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vii v,vv;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int x; while(~ind(x))v.pb(x); int Xor=0; for(int i=0;i+1&lt;v.size();i+=2)&#123; vv.pb(v[i+1]-v[i]-1); Xor^=vv.back(); &#125; if(Xor)&#123; for0(i,v.size()-1)&#123; forl(j,v[i]+1,v[i+1]-1)&#123; if(i%2)&#123; if((Xor^vv[i/2])==vv[i/2]+j-v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125;else&#123; if((Xor^vv[i/2])==vv[i/2]-j+v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125; &#125; &#125; &#125;else puts("-1"); return 0;&#125; graph TD 1-->3 2-->3 3-->4 3-->5]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国王的烦恼]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[题意n 个点 m 条边，每条边有一个权值表示该边消失的时间，求有新的点不联通的时刻的数量。 题解以时间从大到小排序，用并查集反向建图，注意同时刻只能计一次。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e4;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int uni[N];int find_r(int x)&#123; if(uni[x]==x)return x; else return uni[x]=find_r(uni[x]);&#125;bool merge(int a,int b)&#123; int fa=find_r(a),fb=find_r(b); if(fa==fb)return 0; uni[fa]=fb; return 1;&#125;struct edg&#123; int u,v,w; bool operator &lt; (const edg y)const&#123; return w&gt;y.w; &#125;&#125;edge[10*N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; scanf("%d%d",&amp;n,&amp;m); for1(i,n)uni[i]=i; for0(i,m)scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); sort(edge,edge+m); int ans=0,time=0; for0(i,m)&#123; // cout&lt;&lt;edge[i].u&lt;&lt;' '&lt;&lt;edge[i].v&lt;&lt;' '&lt;&lt;edge[i].w&lt;&lt;endl; if(merge(edge[i].u,edge[i].v))&#123; if(edge[i].w!=time)&#123; time=edge[i].w; ans++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1062]]></title>
    <url>%2F2019%2F03%2F02%2FCF-1062%2F</url>
    <content type="text"><![CDATA[D. Fun with Integers题意You are given a positive integer n​ greater or equal to 2. For every pair of integers a and b (2≤|𝑎|,|𝑏|≤𝑛2≤|a|,|b|≤n), you can transform a into b if and only if there exists an integer x such that 1&lt;|x| and (a⋅x=b or b⋅x=a), where |x| denotes the absolute value of x. After such a transformation, your score increases by |x| points and you are not allowed to transform a into b nor b into a anymore. Initially, you have a score of 0. You can start at any integer and transform it as many times as you like. What is the maximum score you can achieve? 题解答案为 2~n 每个数的因子( 范围为$[2,n)$ )之和。 \Huge\sum s_i代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; ll ans=0; cin&gt;&gt;n; forl(i,2,n)&#123; ans+=1ll*i*(n/i-1); &#125; cout&lt;&lt;ans*4&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF-1076]]></title>
    <url>%2F2019%2F03%2F02%2FCF-1076%2F</url>
    <content type="text"><![CDATA[D. Edge Deletion题意the length of the shortest path from vertex 1 to vertex i as $d_i$ . You have to erase some edges of the graph so that at most k edges remain. Let’s call a vertex i good if there still exists a path from 1 to i with length $d_i$ after erasing the edges. Your goal is to erase the edges in such a way that the number of good vertices is maximized. 题解先跑个最短路，再搜索，取最短路上的边。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf = 0x3f3f3f3f;const ll mod = 1e9 + 7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b) &#123; return sign(a - b); &#125;struct Edge &#123; int v, w, nxt, no;&#125; edge[2 * N];int fir[N], cnt;void addedge(int u, int v, int w, int no) &#123; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].nxt = fir[u]; edge[cnt].no = no; fir[u] = cnt++;&#125;struct node &#123; int u; ll d; node(int u, ll d) : u(u), d(d) &#123;&#125; bool operator&lt;(const node &amp;a) const &#123; return d &gt; a.d; &#125;&#125;;bool used[N];ll d[N];void dijkstra() &#123; priority_queue&lt;node&gt; que; meminf(d); d[1] = 0; que.push(node(1, d[1])); while (!que.empty()) &#123; int u = que.top().u; que.pop(); if (used[u]) continue; used[u] = 1; for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] &gt; d[u] + w) &#123; d[v] = d[u] + w; que.push(node(v, d[v])); &#125; &#125; &#125;&#125;bool used_edge[N];void init() &#123; mem_1(fir); cnt = 0;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif // ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); init(); int n, m, k, u, v, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for1(i, m) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w, i); addedge(v, u, w, i); &#125; if (k == 0) &#123; puts("0\n"); return 0; &#125; dijkstra(); queue&lt;int&gt; que; que.push(1); mem0(used); used[1] = 1; int ans = 0; while (que.size()) &#123; int u = que.front(); que.pop(); for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] == d[u] + w) &#123; used_edge[edge[i].no] = 1; used[v] = 1; ans++; if (ans == k) break; que.push(v); &#125; &#125; if (ans == k) break; &#125; printf("%d\n", ans); for1(i, m) &#123; if (used_edge[i]) printf("%d ", i); &#125; puts(""); return 0;&#125; E. Vasya and a Tree题意给一颗树，将 v 和与 v 距离小于 d 的 v 的子节点的权值加上 x，输出所有节点的权值。 题解保存每个点每次加权的终点和 x。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vi;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vi node[N];int dep[N];ll change[N];bool vis[N];int maxx;void dfs(int r,int dph)&#123; dep[r]=dph; vis[r]=1; maxx=max(maxx,dph); for(int v:node[r])if(vis[v]==0)dfs(v,dph+1);&#125;struct da&#123; int end,x; da()&#123;&#125; da(int a,int b):end(a),x(b)&#123;&#125;&#125;;vector&lt;da&gt; weight[N];ll tmpc[N];void ddfs(int r,int depth,ll sum)&#123; for(auto i:weight[r])&#123; sum+=i.x; tmpc[i.end]+=i.x; &#125; change[r]+=sum; sum-=tmpc[depth]; vis[r]=1; for(int v:node[r])if(vis[v]==0)ddfs(v,depth+1,sum); for(auto i:weight[r])tmpc[i.end]-=i.x;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,d,x; ind(n); for0(i,n-1)&#123; scanf("%d%d",&amp;u,&amp;v); node[u].push_back(v); node[v].push_back(u); &#125; dfs(1,1); ind(m); for0(i,m)&#123; scanf("%d%d%d",&amp;v,&amp;d,&amp;x); weight[v].push_back(da(min(dep[v]+d,maxx),x)); &#125; mem0(vis); ddfs(1,1,0); for1(i,n)printf("%lld ",change[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
</search>
