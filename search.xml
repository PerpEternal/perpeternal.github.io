<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[åŸå¸‚å»ºè®¾]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[é¢˜æ„n ä¸ªåŸå¸‚ï¼Œm æ¡é“è·¯ï¼Œæ¯æ¡é“è·¯æœ‰ä¸€ä¸ªæƒå€¼(å¯èƒ½ä¸ºè´Ÿ)ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªæƒå€¼ï¼Œè¡¨ç¤ºä¿®å»ºç å¤´çš„è´¹ç”¨(ä¸º-1æ—¶è¡¨ç¤ºä¸å¯ä»¥ä¿®å»ºç å¤´)ã€‚ é¢˜è§£ans1ä¸ä¿®å»ºç å¤´çš„æœ€å°ç”Ÿæˆæ ‘ans2é¢å¤–æ·»åŠ ä¸€ä¸ª0å·åŸå¸‚ï¼Œå°†å¯å»ºç«‹ç å¤´çš„åŸå¸‚ä¸å®ƒç›¸è¿ï¼Œæ±‚å‡ºçš„æœ€å°ç”Ÿæˆæ ‘å½“ä¸å»ºç å¤´ä¹Ÿèƒ½è”é€šæ—¶ï¼Œç­”æ¡ˆä¸ºmin(ans1,ans2)ï¼Œå¦åˆ™ç­”æ¡ˆä¸º ans2 ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 2e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct Edge&#123; int u,v,c; Edge()&#123;&#125; Edge(int a,int b,int _c)&#123; u=a,v=b,c=_c; &#125; bool operator &lt;(const Edge y)const&#123; return c&lt;y.c; &#125;&#125;edge[N];int uni[N];int find_r(int x)&#123; if(x==uni[x])return x; else return uni[x]=find_r(uni[x]);&#125;int merge(Edge x)&#123; int fa=find_r(x.u),fb=find_r(x.v); if(fa!=fb)&#123; uni[fa]=fb; return 1; &#125; if(x.c&lt;0)return -1; else return 0;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,c,w,Size=0; ll ans1=0,ans2=0; scanf("%d%d",&amp;n,&amp;m); for0(i,m)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); edge[Size++]=Edge(u,v,c); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); int cnt=0; for0(i,Size)&#123; switch(merge(edge[i]))&#123; case 1: ans1+=edge[i].c; cnt++; break; case -1: ans1+=edge[i].c; &#125; &#125; for1(i,n)&#123; ind(w); if(w&gt;0)edge[Size++]=Edge(0,i,w); &#125; for1(i,n)uni[i]=i; sort(edge,edge+Size); for0(i,Size)&#123; if(merge(edge[i]))ans2+=edge[i].c; &#125; if(cnt==n-1)ans2=min(ans2,ans1); printf("%lld\n",ans2); return 0;&#125;]]></content>
      <categories>
        <category>è“æ¡¥æ¯</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ–æ³¢é‚£å¥‘]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%2F</url>
    <content type="text"><![CDATA[é¢˜æ„$f(x)$ä¸ºæ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œæ±‚$\large\left(\sum\limits_{i=1}^nf(i)\right)\ mod\ f(m)\ mod \ pâ€‹$ $0&lt;n,m,p&lt;1e18$ é¢˜è§£ f(n+m)=f(n+1)f(m)+f(n)f(m-1) \\ f(n)\ mod\ f(m)=f(n-m)f(m-1)\ mod\ f(m)\\ f(n)\ mod \ f(m)=f(m-1)^{\frac n m}f(n\%m)\ mod\ f(m)\\ f(n)^2=(-1)^{n+1}+f(n-1)f(n+1)\\ f(m-1)^2\ mod\ f(m)=(-1)^m m ä¸ºå¶æ•° $\frac n mâ€‹$ä¸ºå¶æ•°ï¼Œ$f(n)\ mod\ f(m)=f(n\%m)â€‹$ $\frac n mâ€‹$ä¸ºå¥‡æ•°ï¼Œ$f(n)\ mod\ f(m)=f(m-1)f(n\%m)\ mod\ f(m)â€‹$ m ä¸ºå¥‡æ•° $\frac n m$ä¸ºå¶æ•°ï¼Œ$\frac n {2m}$ä¸ºå¶æ•°ï¼Œ$f(n)\ mod\ f(m)=f(n\%m)$ $\frac n m$ä¸ºå¶æ•°ï¼Œ$\frac n {2m}$ä¸ºå¥‡æ•°ï¼Œ$f(n)\ mod\ f(m)=f(m)-f(n\%m)$ $\frac n mâ€‹$ä¸ºå¥‡æ•°ï¼Œ$\frac n {2m}â€‹$ä¸ºå¶æ•°ï¼Œ$f(n)\ mod\ f(m)=f(m-1)f(n\%m)\ mod\ f(m)â€‹$ $\frac n m$ä¸ºå¥‡æ•°ï¼Œ$\frac n {2m}$ä¸ºå¥‡æ•°ï¼Œ$f(n)\ mod\ f(m)=f(m)-f(m-1)f(n\%m)\ mod\ f(m)$ ç®€åŒ–$f(m-1)f(n\%m)\ mod\ f(m)â€‹$ æ€§è´¨ï¼šè‹¥$n\ge1,r\ge2$ï¼Œåˆ™$f(n)f(n+r-1)-f(n+1)f(n+r-2)=(-1)^{n+1}f(r-2)$ ä»¤$k=n\%m,k=n+1,m-1=n+r-2$ï¼Œåˆ™$f(n)f(k-1)-f(m-1)f(k)=(-1)^kf(m-k)$ æ‰€ä»¥$f(m-1)f(k)\ mod \ f(m)=(-1)^{k+1}f(m-k)\ mod\ f(m)$ å½“$k$ä¸ºå¥‡æ—¶ï¼Œ$f(m-1)f(n\%m)\ mod\ f(m)=f(m-k)$ å½“$k$ä¸ºå¶æ—¶ï¼Œ$f(m-1)f(n\%m)\ mod\ f(m)=f(m)-f(m-k)$ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f; ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;struct matrix &#123; ll a[2][2]; matrix()&#123; mem0(a); &#125;&#125;;ll qMulti(ll x,ll y,ll mod)&#123; //O(1)å¿«é€Ÿä¹˜ return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod; &#125;matrix mat_mul(matrix x, matrix y) &#123; matrix res; for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) res.a[i][j] = (res.a[i][j] + qMulti(x.a[i][k] , y.a[k][j],mod) ) % mod; return res;&#125;ll mat_pow(ll n) &#123; if (n &lt;= 2) return 1; n -= 2; matrix c, res; c.a[0][0] = c.a[0][1] = c.a[1][0] = 1; for (int i = 0; i &lt; 2; i++) res.a[i][i] = 1; while (n) &#123; if (n % 2) res = mat_mul(res, c); c = mat_mul(c, c); n /= 2; &#125; return (res.a[0][0] + res.a[0][1]) % mod;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); ll n,m,p; cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; mod=p; n+=2; ll k=n/m; if(n%m==0)&#123; cout&lt;&lt;((mat_pow(m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; int Sign; if(m%2)Sign=-1; else Sign=1; if(k%2)&#123; k/=2; if(k%2==0)Sign=1; if(n%m%2==0)Sign=-Sign; if(Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(m-n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else&#123; k/=2; if(k%2&amp;&amp;Sign==-1)&#123; cout&lt;&lt;((mat_pow(m)-mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125;else cout&lt;&lt;((mat_pow(n%m)-1)%p+p)%p&lt;&lt;endl; &#125; &#125; return 0;&#125; å¼•ç”¨https://blog.csdn.net/acdreamers/article/details/21822165]]></content>
      <categories>
        <category>è“æ¡¥æ¯</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å›¾å½¢æ’ç‰ˆ]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9B%BE%E5%BD%A2%E6%8E%92%E7%89%88%2F</url>
    <content type="text"><![CDATA[é¢˜æ„å°æ˜éœ€è¦åœ¨ä¸€ç¯‡æ–‡æ¡£ä¸­åŠ å…¥ N å¼ å›¾ç‰‡ï¼Œå…¶ä¸­ç¬¬ i å¼ å›¾ç‰‡çš„å®½åº¦æ˜¯ Wiï¼Œé«˜åº¦æ˜¯ Hiã€‚å‡è®¾çº¸å¼ çš„å®½åº¦æ˜¯ Mï¼Œå°æ˜ä½¿ç”¨çš„æ–‡æ¡£ç¼–è¾‘å·¥å…·ä¼šç”¨ä»¥ä¸‹æ–¹å¼å¯¹å›¾ç‰‡è¿›è¡Œè‡ªåŠ¨æ’ç‰ˆï¼š è¯¥å·¥å…·ä¼šæŒ‰ç…§å›¾ç‰‡é¡ºåºï¼Œåœ¨å®½åº¦ M ä»¥å†…ï¼Œå°†å°½å¯èƒ½å¤šçš„å›¾ç‰‡æ’åœ¨ä¸€è¡Œã€‚è¯¥è¡Œçš„é«˜åº¦æ˜¯è¡Œå†…æœ€é«˜çš„å›¾ç‰‡çš„é«˜åº¦ã€‚ä¾‹å¦‚åœ¨ M=10 çš„çº¸å¼ ä¸Šä¾æ¬¡æ‰“å° 3x4, 2x2, 3x3 ä¸‰å¼ å›¾ç‰‡ï¼Œåˆ™æ•ˆæœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œè¿™ä¸€è¡Œé«˜åº¦ä¸º4ã€‚(åˆ†å‰²çº¿ä»¥ä¸Šä¸ºåˆ—æ ‡å°ºï¼Œåˆ†å‰²çº¿ä»¥ä¸‹ä¸ºæ’ç‰ˆåŒºåŸŸï¼›æ•°å­—ç»„æˆçš„çŸ©å½¢ä¸ºç¬¬xå¼ å›¾ç‰‡å ç”¨çš„ç‰ˆé¢) å¦‚æœå½“å‰è¡Œå‰©ä½™å®½åº¦å¤§äº0ï¼Œå¹¶ä¸”å°äºä¸‹ä¸€å¼ å›¾ç‰‡ï¼Œåˆ™ä¸‹ä¸€å¼ å›¾ç‰‡ä¼šæŒ‰æ¯”ä¾‹ç¼©æ”¾åˆ°å®½åº¦ä¸ºå½“å‰è¡Œå‰©ä½™å®½åº¦(é«˜åº¦å‘ä¸Šå–æ•´)ï¼Œç„¶åæ”¾å…¥å½“å‰è¡Œã€‚ä¾‹å¦‚å†æ”¾å…¥ä¸€å¼ 4x9çš„å›¾ç‰‡ï¼Œç”±äºå‰©ä½™å®½åº¦æ˜¯2ï¼Œè¿™å¼ å›¾ç‰‡ä¼šè¢«å‹ç¼©åˆ°2x5ï¼Œå†è¢«æ”¾å…¥ç¬¬ä¸€è¡Œçš„æœ«å°¾ã€‚æ­¤æ—¶è¯¥è¡Œé«˜åº¦ä¸º5ï¼š å¦‚æœå½“å‰è¡Œå‰©ä½™å®½åº¦ä¸º0ï¼Œè¯¥å·¥å…·ä¼šä»ä¸‹ä¸€è¡Œå¼€å§‹ç»§ç»­å¯¹å‰©ä½™çš„å›¾ç‰‡è¿›è¡Œæ’ç‰ˆï¼Œç›´åˆ°æ‰€æœ‰å›¾ç‰‡éƒ½å¤„ç†å®Œæ¯•ã€‚æ­¤æ—¶æ‰€æœ‰è¡Œçš„æ€»é«˜åº¦å’Œå°±æ˜¯è¿™ N å¼ å›¾ç‰‡çš„æ’ç‰ˆé«˜åº¦ã€‚ä¾‹å¦‚å†æ”¾å…¥11x1, 5x5, 3x4 çš„å›¾ç‰‡åï¼Œæ•ˆæœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæ€»é«˜åº¦ä¸º11ï¼š ç°åœ¨ç”±äºæ’ç‰ˆé«˜åº¦è¿‡é«˜ï¼Œå›¾ç‰‡çš„å…ˆåé¡ºåºä¹Ÿä¸èƒ½æ”¹å˜ï¼Œå°æ˜åªå¥½ä» N å¼ å›¾ç‰‡ä¸­é€‰æ‹©ä¸€å¼ åˆ é™¤æ‰ä»¥é™ä½æ€»é«˜åº¦ã€‚ä»–å¸Œæœ›å‰©ä½™N-1å¼ å›¾ç‰‡æŒ‰åŸé¡ºåºçš„æ’ç‰ˆé«˜åº¦æœ€ä½ï¼Œä½ èƒ½æ±‚å‡ºæœ€ä½é«˜åº¦æ˜¯å¤šå°‘ä¹ˆï¼Ÿ é¢˜è§£é¢„å¤„ç†ä»¥ç¬¬ i å¼ å›¾ä¸ºè¡Œé¦–çš„æœ€ä½é«˜åº¦ï¼Œç„¶åæšä¸¾åˆ å›¾ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;pii a[N],b[N];int suf[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int m,n,w,h; scanf("%d%d",&amp;m,&amp;n); for0(i,n)&#123; scanf("%d%d",&amp;w,&amp;h); a[i]=pii(w,h); &#125; for0(i,n)&#123; w=m; h=0; int len=i; for(;len&lt;n&amp;&amp;w;len++)&#123; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; // cout&lt;&lt;h&lt;&lt;endl; b[i]=pii(len,h); &#125; // puts(""); // for0(i,n)cout&lt;&lt;b[i].first&lt;&lt;' '&lt;&lt;b[i].second&lt;&lt;endl; for(int i=n-1;i&gt;=0;i--)&#123; suf[i]=suf[b[i].first]+b[i].second; &#125; // for0(i,n)cout&lt;&lt;suf[i]&lt;&lt;endl; int ans=inf,flag=0,tot=0; while(flag&lt;n)&#123; for(int i=flag;i&lt;b[flag].first;i++)&#123; w=m; h=0; int len=flag; for(;len&lt;n&amp;&amp;w;len++)&#123; if(len==i)continue; if(w&gt;=a[len].first)&#123; w-=a[len].first; h=max(h,a[len].second); &#125;else&#123; int th=ceil(a[len].second*w*1.0/a[len].first); w=0; h=max(h,th); &#125; &#125; ans=min(ans,tot+h+suf[len]); &#125; tot+=b[flag].second; flag=b[flag].first; // tot+= &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>è“æ¡¥æ¯</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ ¼å­åˆ·æ²¹æ¼†]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%A0%BC%E5%AD%90%E5%88%B7%E6%B2%B9%E6%BC%86%2F</url>
    <content type="text"><![CDATA[é¢˜æ„ç»™ä¸€ä¸ª$2*N$çš„çŸ©é˜µï¼Œå¯ä»¥ä»ä»»æ„ä¸€ä¸ªæ ¼å­åˆ·èµ·ï¼Œä½†åªèƒ½ç§»åŠ¨åˆ°å’Œå®ƒç›¸é‚»çš„æ ¼å­ï¼ˆå¯ä»¥å¯¹è§’ï¼‰ï¼Œæ±‚æ€»çš„æ–¹æ¡ˆæ•°ï¼Œå¯¹$1e9+7â€‹$å–æ¨¡ã€‚ é¢˜è§£è®¾a[n]ä¸ºèµ·ç‚¹ä¸ºæŸä¸€è§’è½é•¿åº¦ä¸ºnç»ˆç‚¹ä»»æ„çš„æƒ…å†µæ•°ï¼Œb[n]ä¸ºèµ·ç‚¹ä¸ºæŸä¸€è§’è½é•¿åº¦ä¸ºnç»ˆç‚¹å¿…é¡»åŒåˆ—çš„æƒ…å†µæ•°ã€‚ $b[i]=2^{i-1}$ å½“èµ·ç‚¹åœ¨å››ä¸ªè§’è½ï¼Œä»¥å·¦ä¸Šè§’ä¸ºä¾‹ æƒ…å†µä¸€ï¼Œå…ˆå‘ä¸‹ç§»åŠ¨ï¼Œå†å‘å³ç§»åŠ¨æŸä¸ªä½ç½®ï¼Œæƒ…å†µæ•°ç›¸å½“äº åšé•¿åº¦ä¸ºi-1çš„ç»ˆç‚¹ä»»æ„çš„æƒ…å†µæ•°*2 å› ä¸ºä¸éœ€è¦åœ¨å›åˆ°ç¬¬ä¸€åˆ—ï¼Œè€Œä¸”åˆ°ç¬¬äºŒåˆ—çš„æ—¶å€™å¯èƒ½æ˜¯ç¬¬ä¸€è¡Œæˆ–è€…ç¬¬äºŒè¡Œï¼Œå³$a[i-1]*2$ æƒ…å†µäºŒï¼Œä»èµ·ç‚¹å‡ºå‘æœ€ç»ˆå›åˆ°ç¬¬ä¸€åˆ—çš„ç¬¬äºŒè¡Œï¼Œé‚£ä¹ˆæƒ…å†µæ•°å°±æ˜¯b[i]ã€‚ å…ˆè¿›å…¥ç¬¬äºŒåˆ—ï¼Œç„¶åè¿”å›ç¬¬ä¸€åˆ—å¦ä¸€ä¸ªä½ç½®ï¼Œç„¶åå†å›ç¬¬äºŒåˆ—ï¼Œå³$22a[i-2]$ å½“èµ·ç‚¹åœ¨ä¸­é—´ æƒ…å†µä¸€ï¼Œå‘å·¦è¿åŠ¨åå›åˆ°ç¬¬iåˆ—ç„¶åå‘å³è¿åŠ¨ æƒ…å†µäºŒï¼Œå‘å³è¿åŠ¨åå›åˆ°ç¬¬iåˆ—ç„¶åå‘å·¦è¿åŠ¨ \sum\limits_{i=2}^{n-1}2*(b[i+1]*a[n-i]+b[n-i+2]*a[i-1]) $a[1]=1,a[2]=6$ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;ll a[N],b[N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,ans=0; b[1]=1; forl(i,2,1e3)&#123; b[i]=b[i-1]*2%mod; &#125; a[1]=1;a[2]=6; forl(i,3,1e3)&#123; a[i]=(2ll*a[i-1]+b[i]+4ll*a[i-2])%mod; &#125; ind(n); if(n==1)&#123; puts("2"); return 0; &#125; ans=4ll*a[n]%mod; forl(i,2,n-1)&#123; ans=(ans+2ll*(b[i+1]*a[n-i]%mod+b[n-i+2]*a[i-1]%mod))%mod; &#125; printf("%d\n",ans); return 0;&#125; å¼•ç”¨https://blog.csdn.net/qq_35078631/article/details/54730870]]></content>
      <categories>
        <category>è“æ¡¥æ¯</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é«˜åƒ§æ–—æ³•]]></title>
    <url>%2F2019%2F03%2F20%2F%E9%AB%98%E5%83%A7%E6%96%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[é¢˜æ„n ä¸ªç‰©å“æ”¾åœ¨é˜¶æ¢¯ï¼Œå‘ä¸Šç§»åŠ¨ç‰©å“ï¼Œä¸èƒ½è¶Šè¿‡æŒ¡åœ¨å‰é¢çš„ç‰©å“ï¼Œæœ€åç‰©å“éƒ½æŒ¤åœ¨é«˜æ®µå°é˜¶ï¼Œä¸èƒ½ç§»åŠ¨çš„è¾“ã€‚ é¢˜è§£ä¸¤ä¸¤ä¸€ç»„ï¼Œå½“ç§»åŠ¨ä¸Šé¢çš„ï¼Œå¯ä»¥ç§»åŠ¨ä¸‹é¢çš„ç›¸åŒè·ç¦»ï¼Œæ‰€ä»¥å¯ä»¥æŠŠæ¯ç»„ä¹‹é—´çš„é—´è·çœ‹ä½œä¸€å †çŸ³å­ï¼Œè½¬åŒ–ä¸º Nim åšå¼ˆã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vii v,vv;int main() &#123;#ifdef PerpEternal freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int x; while(~ind(x))v.pb(x); int Xor=0; for(int i=0;i+1&lt;v.size();i+=2)&#123; vv.pb(v[i+1]-v[i]-1); Xor^=vv.back(); &#125; if(Xor)&#123; for0(i,v.size()-1)&#123; forl(j,v[i]+1,v[i+1]-1)&#123; if(i%2)&#123; if((Xor^vv[i/2])==vv[i/2]+j-v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125;else&#123; if((Xor^vv[i/2])==vv[i/2]-j+v[i])&#123; printf("%d %d\n",v[i],j); return 0; &#125; &#125; &#125; &#125; &#125;else puts("-1"); return 0;&#125;]]></content>
      <categories>
        <category>è“æ¡¥æ¯</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å›½ç‹çš„çƒ¦æ¼]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%83%A6%E6%81%BC%2F</url>
    <content type="text"><![CDATA[é¢˜æ„n ä¸ªç‚¹ m æ¡è¾¹ï¼Œæ¯æ¡è¾¹æœ‰ä¸€ä¸ªæƒå€¼è¡¨ç¤ºè¯¥è¾¹æ¶ˆå¤±çš„æ—¶é—´ï¼Œæ±‚æœ‰æ–°çš„ç‚¹ä¸è”é€šçš„æ—¶åˆ»çš„æ•°é‡ã€‚ é¢˜è§£ä»¥æ—¶é—´ä»å¤§åˆ°å°æ’åºï¼Œç”¨å¹¶æŸ¥é›†åå‘å»ºå›¾ï¼Œæ³¨æ„åŒæ—¶åˆ»åªèƒ½è®¡ä¸€æ¬¡ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vii;typedef long double db;typedef long long ll;const db pi = acos((db)-1);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e4;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int uni[N];int find_r(int x)&#123; if(uni[x]==x)return x; else return uni[x]=find_r(uni[x]);&#125;bool merge(int a,int b)&#123; int fa=find_r(a),fb=find_r(b); if(fa==fb)return 0; uni[fa]=fb; return 1;&#125;struct edg&#123; int u,v,w; bool operator &lt; (const edg y)const&#123; return w&gt;y.w; &#125;&#125;edge[10*N];int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m; scanf("%d%d",&amp;n,&amp;m); for1(i,n)uni[i]=i; for0(i,m)scanf("%d%d%d",&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w); sort(edge,edge+m); int ans=0,time=0; for0(i,m)&#123; // cout&lt;&lt;edge[i].u&lt;&lt;' '&lt;&lt;edge[i].v&lt;&lt;' '&lt;&lt;edge[i].w&lt;&lt;endl; if(merge(edge[i].u,edge[i].v))&#123; if(edge[i].w!=time)&#123; time=edge[i].w; ans++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>è“æ¡¥æ¯</category>
      </categories>
      <tags>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1062]]></title>
    <url>%2F2019%2F03%2F02%2FCF1062%2F</url>
    <content type="text"><![CDATA[D. Fun with Integersé¢˜æ„You are given a positive integer nâ€‹ greater or equal to 2. For every pair of integers a and b (2â‰¤|ğ‘|,|ğ‘|â‰¤ğ‘›2â‰¤|a|,|b|â‰¤n), you can transform a into b if and only if there exists an integer x such that 1&lt;|x| and (aâ‹…x=b or bâ‹…x=a), where |x| denotes the absolute value of x. After such a transformation, your score increases by |x| points and you are not allowed to transform a into b nor b into a anymore. Initially, you have a score of 0. You can start at any integer and transform it as many times as you like. What is the maximum score you can achieve? é¢˜è§£ç­”æ¡ˆä¸º 2~n æ¯ä¸ªæ•°çš„å› å­( èŒƒå›´ä¸º$[2,n)$ )ä¹‹å’Œã€‚ \Huge\sum s_iä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 1.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;int main() &#123;#ifndef ONLINE_JUDGE // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n; ll ans=0; cin&gt;&gt;n; forl(i,2,n)&#123; ans+=1ll*i*(n/i-1); &#125; cout&lt;&lt;ans*4&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1076]]></title>
    <url>%2F2019%2F03%2F02%2FCF1076%2F</url>
    <content type="text"><![CDATA[D. Edge Deletioné¢˜æ„the length of the shortest path from vertex 1 to vertex i as $d_i$ . You have to erase some edges of the graph so that at most k edges remain. Letâ€™s call a vertex i good if there still exists a path from 1 to i with length $d_i$ after erasing the edges. Your goal is to erase the edges in such a way that the number of good vertices is maximized. é¢˜è§£å…ˆè·‘ä¸ªæœ€çŸ­è·¯ï¼Œå†æœç´¢ï¼Œå–æœ€çŸ­è·¯ä¸Šçš„è¾¹ã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf = 0x3f3f3f3f;const ll mod = 1e9 + 7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b) &#123; return sign(a - b); &#125;struct Edge &#123; int v, w, nxt, no;&#125; edge[2 * N];int fir[N], cnt;void addedge(int u, int v, int w, int no) &#123; edge[cnt].v = v; edge[cnt].w = w; edge[cnt].nxt = fir[u]; edge[cnt].no = no; fir[u] = cnt++;&#125;struct node &#123; int u; ll d; node(int u, ll d) : u(u), d(d) &#123;&#125; bool operator&lt;(const node &amp;a) const &#123; return d &gt; a.d; &#125;&#125;;bool used[N];ll d[N];void dijkstra() &#123; priority_queue&lt;node&gt; que; meminf(d); d[1] = 0; que.push(node(1, d[1])); while (!que.empty()) &#123; int u = que.top().u; que.pop(); if (used[u]) continue; used[u] = 1; for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] &gt; d[u] + w) &#123; d[v] = d[u] + w; que.push(node(v, d[v])); &#125; &#125; &#125;&#125;bool used_edge[N];void init() &#123; mem_1(fir); cnt = 0;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif // ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); init(); int n, m, k, u, v, w; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for1(i, m) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w, i); addedge(v, u, w, i); &#125; if (k == 0) &#123; puts("0\n"); return 0; &#125; dijkstra(); queue&lt;int&gt; que; que.push(1); mem0(used); used[1] = 1; int ans = 0; while (que.size()) &#123; int u = que.front(); que.pop(); for (int i = fir[u]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].v; int w = edge[i].w; if (used[v]) continue; if (d[v] == d[u] + w) &#123; used_edge[edge[i].no] = 1; used[v] = 1; ans++; if (ans == k) break; que.push(v); &#125; &#125; if (ans == k) break; &#125; printf("%d\n", ans); for1(i, m) &#123; if (used_edge[i]) printf("%d ", i); &#125; puts(""); return 0;&#125; E. Vasya and a Treeé¢˜æ„ç»™ä¸€é¢—æ ‘ï¼Œå°† v å’Œä¸ v è·ç¦»å°äº d çš„ v çš„å­èŠ‚ç‚¹çš„æƒå€¼åŠ ä¸Š xï¼Œè¾“å‡ºæ‰€æœ‰èŠ‚ç‚¹çš„æƒå€¼ã€‚ é¢˜è§£ä¿å­˜æ¯ä¸ªç‚¹æ¯æ¬¡åŠ æƒçš„ç»ˆç‚¹å’Œ xã€‚ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define forl(i, l, r) for (int i = l; i &lt;= r; i++)#define forr(i, r, l) for (int i = r; i &gt;= l; i--)#define for1(i, n) for (int i = 1; i &lt;= n; i++)#define for0(i, n) for (int i = 0; i &lt; n; i++)#define meminf(a) memset(a, inf, sizeof(a))#define mem_1(a) memset(a, -1, sizeof(a))#define mem0(a) memset(a, 0, sizeof(a))#define inlld(lld) scanf("%lld", &amp;lld)#define inlf(f) scanf("%lf", &amp;f)#define ind(d) scanf("%d", &amp;d)#define ins(s) scanf("%s", s)#define mp make_pair#define pb push_back#define fi first#define se secondtypedef std::pair&lt;long long, long long&gt; pll;typedef std::vector&lt;long long&gt; vll;typedef std::pair&lt;int, int&gt; pii;typedef unsigned long long ull;typedef std::vector&lt;int&gt; vi;typedef long double db;typedef long long ll;const db pi = acos(-1.0);const ll inf =0x3f3f3f3f;const ll mod = 1e9+7;const int N = 3.1e5;const db eps = 1e-8;using namespace std;int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;int db_cmp(db a, db b)&#123; return sign(a-b); &#125;vi node[N];int dep[N];ll change[N];bool vis[N];int maxx;void dfs(int r,int dph)&#123; dep[r]=dph; vis[r]=1; maxx=max(maxx,dph); for(int v:node[r])if(vis[v]==0)dfs(v,dph+1);&#125;struct da&#123; int end,x; da()&#123;&#125; da(int a,int b):end(a),x(b)&#123;&#125;&#125;;vector&lt;da&gt; weight[N];ll tmpc[N];void ddfs(int r,int depth,ll sum)&#123; for(auto i:weight[r])&#123; sum+=i.x; tmpc[i.end]+=i.x; &#125; change[r]+=sum; sum-=tmpc[depth]; vis[r]=1; for(int v:node[r])if(vis[v]==0)ddfs(v,depth+1,sum); for(auto i:weight[r])tmpc[i.end]-=i.x;&#125;int main() &#123;#ifdef PerpEternal // freopen("/Users/perpeternal/Documents/Sketch/data/in.dat", "r", stdin); // freopen("/Users/perpeternal/Documents/Sketch/data/out.dat", "w", stdout);#endif //ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int n,m,u,v,d,x; ind(n); for0(i,n-1)&#123; scanf("%d%d",&amp;u,&amp;v); node[u].push_back(v); node[v].push_back(u); &#125; dfs(1,1); ind(m); for0(i,m)&#123; scanf("%d%d%d",&amp;v,&amp;d,&amp;x); weight[v].push_back(da(min(dep[v]+d,maxx),x)); &#125; mem0(vis); ddfs(1,1,0); for1(i,n)printf("%lld ",change[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
</search>
